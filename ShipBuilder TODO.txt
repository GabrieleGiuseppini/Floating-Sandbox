
+ See crash with Rope tool
	+ "In my case it happened when I accidentaly picken air in the rope layer and tried to make a rope with it"
		+ Rope sampler tool should not pick up nothing
+ Fix: debug assert when load ship with texture and then resize all ship to make it larger and then undo
	+ Debug assert when blitting a large region from the new (i.e. the new texture layer after undo) smaller texture
	+ Seems to be due to ModelController::RestoreTextureLayer considering earlier texture size in calculation of dirty region
		X Why did we do that?

- Do Selection/Copy'n'Cut/Paste workflow (*)

- Should ModelValidator allow for electrical particles on rope endpoints?

- Do StructuralRectangle tool (*)

================================================================================================================================================================================

- Gist:
	- Code organization:
		- ShipBuilderLib project, slave of FloatingSandbox project
		- ShipBuilder project, top-level project for standalone SB UI
			- For testing ShipBuilder alone
			- Just MainApp basically
		- All in separate ShipBuilder namespace
	- Own frame for UI
	- Model, View, Controller architecture
	- Reuses existing ResourceHelper, only need (at this moment) for separate resource directory and method is Shaders ("Game" and "ShipBuilder")
	- On the "structure: pixels vs triangles", Wreno says fine to edit in pixel mode, and allow user to eventually _view_ also in triangle mode (but not necessarily edit)
	- On the size: Wreno says "no fixed sized, allow whole world"

- Architecture:

	- MainFrame: IUserInterface
	  |------------------------------>View
	  |-------> Controller/Tools		    
		    |---->ModelController
			  |---->Model
			  |------------------------>View

	- MainFrame: owns toolboxes, etc.
		- Owns Controller and View
		- Very thin, calls into Controller for each high-level interaction (e.g. SelectTool(.), OnWorkbenchStateChanged(.))
		- Implements IUserInterface with interface required by controller, e.g. UI state changes, mouse capture, undo stack visualization
		- Owns WorkbenchState
			- Candidate for saved settings
			- Contains foreground and background materials, and settings for all tools
		- Implements ship load/save logic, giving/getting whole ShipDefinition to/from ModelController
	- Controller
		- Owns ModelController, takes reference to View
		- Main Frame calls into Controller for each user interaction, including button clicks
			- Controller->Main Frame callbacks via IUserInterface
		- Maintains UI state (e.g. grid toggle, visible layers), instructing View
		- Maintains Undo stack (not individual entries), and orchestrates undo stack visualization with IUserInterface
		- Maintains interaction state, implemented via Tools
		- Owns SelectionManager pseudo-tool
		- Owns ClipboardManager pseudo-tool
	- ModelController
		- Owns Model, takes reference to View
		- Implements all interactions and algorithms (e.g. pencil, line, flood, paste, etc.), uploading resulting changes from Model into View,
		  and creating Undo stack entries		
	- Model
		- All data, (almost) no operations (anemic), fully exported
		- Modified by ModelController
		- Knows nothing about view
		- IsDirty tracking
	- View
		- Rendering of ship, all layers
		- Rendering of tool interactions (e.g. marching ants, squares, etc.)
		- Fully OpenGL
	- Tools
		- "Extensions" of Controller
		- Implement state machines for interactions, including visual notifications (marching ants, paste mask, etc.)
		- Take references to WorkbenchState (at tool initialization time)
		- Selection tool Take references to SelectionManager (at tool initialization time), so that it can save selection to it
		- Receive input state events from Controller, and notifications of WorkbenchState changed
		- Take references to View and ModelController
		- Modify Model via ModelController
		- Instruct View for tool interactions, e.g. tool visualizations (lines, paste mask, etc.)
		- Have also reference to IUserInterface, e.g. to capture/release mouse

----------------------------------------------------------------------------------------------------------

- Workflows:
	- Create New Ship (@menu, @file panel)
		- GameController::CreateNew()
	- Create New Ship From TExture (@menu, @file panel)
		- GameController::CreateNewFromTexture()
	- Load Ship (@menu, @file panel)
		- GameController::Load()

- Dirtyness:
	- Storage is at Model
		- Include metadata
	- Manipulated by Controller via ModelController methods
		- So Controller notifies IUserInterface

- UI Controls:
	+ Button to save and go back to game (!StandaloneMode)
	+ Button to quit and go back to game (!StandaloneMode)
	+ Button to Save (acts also as SaveAs for first save; menu however has also separate SaveAs)
	+ Undo stack
	+ Add electrical/texture/ropes layer
	+ Button to open ShipMetadata dialog
	+ Resize button (canvas resize)


= StatusBar:
	+ Own class
	+ Try making it a wxPanel rather than a wxStatusBar
	+ Cctor w/UnitsSystem
		+ From Preferences
	+ Also is notified of every change in ship scale, so that it uses it to go from ship to world
		+ Notifications
		+ Used
	- Areas:
		- Canvas:
			+ WorkSpace size and icon (wxh), w/meters/feet as well
				+ GameCore::Conversions.h: MetersToFeet, etc.
			+ Coords and icon (x,y), w/meters/feet as well			
			- Selection/line/rect/etc. size and icon (wxh), w/meters/feet as well
			+ Zoom (%)
				+ MainFrame: OnViewModelChanged calls a new ReconciliateUIWithViewModel(), which does:
					+ StatusBar: set zoom
					+ RecalculateWorkCanvasPanning
			= InteractiveTool (for Material, MeasuringTape, etc.)
				+ Icon (store images/bitmaps as members)
				- MeasuringTape
				= Material under cursor (for drop tool)
		- Test physics probe w/both systems
- Tools:
	! Most tools should pan when the (captured) mouse is outside of the canvas
		- Via BaseTool::ScrollIntoViewIfNeeded, which simply forwards to IUserInterface::ScrollIntoViewIfNeeded(display logical)
	+ Tool:
		+ Stores all protected references passed from cctors: IUserInterface, ModelController, View
		+ Same abstract methods from game - but all pure
	- All tools:
		+ Pencil (S, E)
			+ Settings: Size
		+ Eraser (S, E)
			+ Settings: Size
		+ Flood (S, E)
		+ Sampler tool (*)
			+ Icon and cursor
				+ Anchor
			+ Structural, Electrical, and Ropes
			+ Need StatusBar "Current Material" first
			+ Tool:
				+ LeftMouseDown, RightMouseDown: selection
					+ Change WorkbenchState fg or bg
					+ Notify MainFrame of WorkbenchState change
						+ Test that it refreshes
				+ MouseMove: change status bar
					! Regardless of mouse being down or up
					+ Notify MainFrame of material
						+ IUserInterface notification, with name of material
				+ Zero-out material at:
					+ Tool destructor
			+ Test:
				+ Structural (sample + select)
				+ Electrical (sample + select)
				+ Ropes (sample + select)

		+ Line
		+ Measuring Tape
			+ Shift lock
			+ Notification
				+ SetToolType
					+ Invoke from MainFrame's OnToolChange onto StatusBar
					+ Icon w/2 images
				+ Status bar
			+ Start- and End-points being in window
				+ @ down: clip
				+ @ up: fix bug that shows line staying behind
				+ @ move: 
					+ Clip overlay 
					+ Clip length 
		- Rectangle
			- Settings: FillWithFore|FillWithBack|NoFill; Size
		- Selection
			- Implements selection interaction and rendering of visual feedback *during the interaction only*
			- Takes SelectionManager ref in its cctor, and populates it upon confirmation of selection made
			- Selection spec (*)
		- Ellipses
		- Traslate (aka move)
		+ Magic Eraser (for texture layer only)
			+ Tolerance (0-100): % of distance(this color, start color)/max_distance
			+ Anti-aliasing (bool): when on, alpha = distance(this color, start color)/tolerance_distance
	- Other edit operations, not via tools - via menu (and buttons?)
		+ Auto-trim (on bounding box)

= Selection/Copy'n'Paste (*):
	! Spec:
		- ~LayersRegion: container of (regions of) layers, for each layer type
			- Elec contains own region of PanelMetadata
			- It is Paste's job to ensure clipboard and target "match"
				- i.e. ignores non-existing layers (for consistency with ephemeral)
		- SelectionManager: just glorified optional<Rect> member of Controller
			- Owned by Controller, created @ cctor
			- Has reference to IUserInterface (to notify of selection on/off toggles)
			- Reset at:
				- Selection tool destroy
				- Deselect (ctrl^D/deselect button at Select tool's "Tool Settings" ribbon)
				- Controller::~Controller (obviously)
		- ClipboardManager: stores opt<LayersRegion>
			- Owned by WorkbenchState, created @ cctor
				- Owned by WorkbenchState, so we may have clipboard surviving reloads
			- Has reference to IUserInterface (to notify of clipboard full/empty toggles)
			- Never reset

	+ ShipLayers == LayersRegion
	+ Assets
		+ Selection
		+ Copy, Cut, Paste button icons		
	+ Select tool <TLayer>: populates selection Rect into SelectionManager
		+ Icon: Selector.png, ready
		+ "Tool Settings" ribbon: // - change label of ribbon to actual tool name
			+ "All Layers" checkbox 
				+ Used @ clipboard population
			+ "Deselect" button (/CTRL^D)
				+ Talks to (base) tool via dynamic_cast
		+ Tool:
			+ Cursor
			+ Mechanics:
				+ Base				
				+ Corner picking
				+ Square constraining
			+ SelectionManager notifies IUserInterface @ selection presence toggles; used for: Copy, Cut, Deselect buttons
			+ Rearc: see if can stop suspending tool at MouseLeaveWindow
				+ First test sequence of calls @:
					+ From out, L down then enter: expect: Ldown->Mmove; actual: Mmove (so subsequent Lup is unmatched)
					+ From in, L down then leave (up happening out): expect: Lup->LeftCanvas; actual: UncapturedMouseOut->Lup
				+ No more suspend @ mouse left window (& thus no more resume @ mouse enter window)
				+ But new OnLeftCanvas(), treated as a MouseMove() outside of canvas
					+ Note: *could* be engaged, in which case this MouseLeave is to be treated as Lup (with commit) followed by LeftCanvas
					+ Add above to comment
				+ Verify return comes with a MouseMove; if not, also need OnEnter()
				! Technically, state machine transitions are:
					! Leave == In->Out move
					! Move (evt. after Enter):
						- if (...state...): Out->In
						- else: In->In
				+ Tools:					
					+ Line
					+ Flood
					+ MeasuringTape
					+ Pencil (Need to handle MouseLeft)
					+ RopeEraser
					+ RopePencil
					+ Sampler
					+ Selection
					+ TextureEraser
					+ TextureMagicWand
				+ Make sure all mouse up's don't assume they are engaged
				+ Cleanup all TODO's
			+ All accesses to mouse coords: clamp to canvas when needed, do not rely on scissors
				+ Identify and fix all tools that deal with View things that require scissors
					+ LineTool
					+ MeasuringTapeTool
				+ Remove View::scissors afterwards
			+ Merge to master
			+ Tool base is not templated anymore - to allow for Ctrl^A/D
			+ Make sure selection to selection manager is Rect (so that origin always in ship) and not two corners
			+ Controller::GetCurrentToolAsSelectionTool -> SelectionTool& - with Tool::GetClass()->ToolClass {Other, Selection, Paste}
			+ Ctrl^A accel => Controller::SelectAll()
				+ If cur tool category not SelectionTool: change tool
				+ Call Controller::GetCurrentToolAsSelectionTool().SelectAll()
			+ Ctrl^D accel => Controller::Deselect()
				+ Call Controller::GetCurrentToolAsSelectionTool().Deselect()
			+ Publish size to StatusBar
				+ Clone of OnMeasuredWorldLengthChanged
				+ Between tool coordinates and sampled material
					+ We have an icon for that, "selection_size"
	+ Selection overlay: corners w/pixels
	+ Fix issue:
		+ ModelValidationDialog calls Controller::ValidateModel() from separate thread, which first suspends tool and then, when done, resumes the tool and 
		  thus *creates* the tool (after our last change), causing OpenGL calls from separate thread; fix:
			+ No thread in dialog
			+ Controller::StartValidation() -> ModelValidationSession
				+ Also suspends and stores scoped thing in Validator - cleared at Validator dctor
					+ Verify
				+ Dialog stores ValidationSession in opt session data and destroys when done
			+ Timer advances Validator until it's done
				+ And then destroy Validator in opt
			+ Do lazy vector initialization at both Next() and GetCount()
				+ And make it conditional
		+ Tests:
			+ "Fix issue" workflows
			+ Save workflow
	+ Copy & Cut:
		+ Buttons at "Edit" ribbon (new own section)
		+ Reconciliation with selection: enable/disable
		+ private Controller::CopySelectionToClipboard()
			+ Gets SelectionRect from SelectionManager, and LayerSelection from WorkbenchState::all-layers flag
			+ Then gets LayersRegion from ModelController, and shoves it into ClipboardManager
			+ Layer primitives:
				+ Buffer2D:
					+ Buffer<>::CloneRegion(Rect) -> Buffer
					+ Buffer::PasteRegion(pos, Buffer)
						+ Need to allow both pos and size to be outside of target buffer
							+ So cannot be done in terms of BlitFromRegion
						+ Add func operator
							+ And one unit test for it
					+ BlitFromRegion: takes responsibility of Paste
						+ Nuke Paste afterwards
					+ Renames: CloneRegion stays CloneRegion
				+ New plan:
					! Spec:
						! "Buffer2D knows nothing about copy'n'paste"
						X "ShipLayers only has methods for ShipFactory load options (e.g. Rotate, Flip, etc.)"
							- Which anyway end up being used by ModelController as well
					+ 1: ShipLayers: see if can make Structural optional; before we make yet another "ShipLayersRegion" class, try and
					     make ShipLayers with optional StructuralLayer, and Size (for flip/rotate)
						+ Make sure Deserializers complain if no structural layer
						X If not: make ShipLayersRegion and TODO: way to implement Rotate, Flip once
						+ Remove ShipLayers::HasXXX methods
						+ Test
							+ Add layer + Undo, X all layer types
							+ Remove lyaer + Undo, X all layer types
							+ Struc Pencil tool + undo
							+ Elect Pencil tool + undo
							+ Resize larger + undo
							+ Resize smaller + undo
							+ Rotate + undo
					X 2: Move XXXLayer() (and thus ShipLayers) methods that deal with Rope and Electric logic to ModelController,
					     except for Clone(), and for those needed by ShipFactory: Rotate(), Flip()
						- TODO: leave this be for the time being - may be we don't need much duplication of elec panel and rope logic after all
						- CloneRegion? Needed anywhere else?
						- Trim? Needed anywhere else?
						- MakeReframed? Needed anywhere else?
							- Think of making proper class for ElectricalPanel
						- Others?
			X Rewrite/reroute whole Undo machinery @ Controller/ModelController/Model/Tools in terms of these
				X TODO: think of changing tools' actions and eph visualizations wrt cloned regions: Model::Operation(...) returns LayerData
					X Which then Undo action creator pairs with origin
				X But watch out:
					X Ropes' Undo: still best to take whole layer, no risk of losing ropes
					X NOT A GOOD IDEA: methods would then be un-harmonic, for some layers would return region and not for others (e.g. Ropes)
						X Also would be not performant (continuous copy & paste vs only blit)
			+ ClipboardManager notifies IUserInterface @ population; used for: Paste		
			+ ModelController::Copy -> ShipLayers:
				+ Some layers are just buffer::CloneRegion, Ropes is Copy
			+ Test:
				+ Individual layer types are picked up
				+ "All layers" is picked up
			+ Remove diagnostic logging
		+ Controller::Cut():
			+ Invoked by MainFrame
			+ Calls CopySelectionToClipboard(...), then:
			+ ModelController::EraseRegion(selection rect, which layers) => GenericUndo				
				+ "Generic Undo": class & ModelController Undo method
					! Used for paste & cut undo, among eventually others
					+ GenericUndoPayload: kinda like ShipLayers(Region), with differences:
						+ Origin (coords)
						+ Ropes and Electrical Panel are whole, other buffers are "regions"
						+ Eventually, also ship metadata
					+ private ModelController::MakeGenericUndoPayload(rect, layer selection)
					+ public ModelController::Restore(GenericUndoPayload &&)				
				+ ModelController::EraseRegion(region, layer selection) -> GenericUndoPayload
					+ Make undo via MakeGenericUndoPayload
					+ Implement cut for each layer
					+ Return undo
				! Note: "Cut" Undo leaves clipboard populated - that's fine
			+ Store GenericUndo in UndoStack
			+ Tests:
				+ GameViz bug:
					+ Erase (Cut)
					+ RestoreTextureLayerRegionBackup (Undo of cut)
					+ MagicWand					
					+ Ephemeral texture eraser
				+ Cut for each individual layer, & Undo
					+ Ropes: completely contained, & undo
					+ Ropes: partially contained, & undo
					+ Ropes: not contained
				+ Cut for all layers, & Undo
				+ Pencil S & Undo
				+ Pencil E & Undo
					+ Verify bug existed and now fixed
				+ Line S & Undo
				+ Line E & Undo
					+ Verify bug existed and now fixed
				+ Flood & Undo
				+ TextureMagicWand & Undo
				+ TrimElectricalSubstratum & Undo
		+ Controller::Copy():
			+ Calls CopySelectionToClipboard()
	+ MainFrame::ReconciliateUIWithSelection(): enable/disable Cut, Copy, Deselect buttons
	= Paste tool:
		+ UI Reconciliation with clipboard being populated: enable/disable button
			+ Initial call from Controller cctor
		! Spec:
			- Tool not selectable by user; auto-activated @ Paste
				- Never enters "last tool" stack
				! Tool's button is always disabled, except when active: is_enabled==is_active
			- Tool gets own copy of LayersRegion at creation, and modifications happen to it (rather than to Clipboard's)
			- Exited by:
				- Selecting another tool
					- In this case, it Commit's()
				- Commit & Abort "Tool Settings" buttons
					- Controller callbacks themselves tell PasteTool e.g. of abort, then destroy the tool
					  and activate previous one for the layer
				- ~PasteTool() (e.g. because of Validation, etc.)
					- In this case, it Abort's()
						- TODO: how to distinguish from "Selecting another tool"? May be this one should Commit() as well
			- PasteTool must not get resumed after a suspension
			- Tool does Move; various "Tool Settings" buttons do rotate/flip/etc.
				- Rotate/flip/etc: Button->Ctrl->PasteTool
				- Flag for opaque vs transparent
					- Checkbox->Ctrl->PasteTool		
		= Impl:
			+ Prelims: 
				+ Make Controlller::ToolType not optional
				= Get rid of WorkbenchState::CurrentToolType altogether
					+ Controller::cctor:
						+ Set current tool from last tool for current viz
					+ Tests:
						+ Suspend/Resume: MainFrame is being refreshed now; how does it look?
						+ Removal of layers and thus change of primary viz layer => change of tool
					- Decide what to do wrt double tool notification from Controller::SetCurrentTool(.) at tool resume time
						- See if "if always suspended" below helps with this
			= Assets:
				+ Paste tool icon: paste_icon.png
				+ Cursor: pan_cursor.png
			= Tool button @ each layer
				= Reconciliation @ tool change: always disabled, except when active: is_enabled==is_active
			= Tool settings:
				+ Layout is same as Selection
				+ Flag for opaque vs transparent
					+ -> Controller::SetPaste"Opaque/Transparentness"
				+ Rotate/flip/etc
					+ -> Controller::RotatePaste()/etc.
				+ Separator
				+ Commit/Abort
					+ Assets: 
						+ confirm_40x40.png
						+ x_40x40.png
					+ Buttons
					+ -> Controller::Commit/AbortPaste
			+ Ctrl^V and button invoke Controller::Paste()
			= Controller::Paste():
				+ 0a. Clone clipboard
					+ ShipLayers::Clone
						+ Unit Tests X 2 (full, empty)
				+ 0b. Nuke current tool
				+ 1. Decide ToolType value (i.e. layer)
					+ First clipboard layer, and better if current viz layer
					+ After choice: if different layer than current, change viz
						+ Can use InternalSelectPrimaryVisualization, does not change tool
				+ 2. Instantiate tool
					+ Tool cctor takes clone of clipboard layers region (by move)
					+ Tool cctor also takes flag for opaque vs transparent (comes from WorkbenchState)
				- 3. Set tool
					- Here the tool type does not enter stack of last used
					- "Normal" new tool select notification goes out to IUserInterface
						- So now we can test "Tool settings" toolbar layout above
					- See if tool setting may be set via "normal" helper, after modifying it to ensure Paste class does not enter "last tool" stack
						- We stil need to ensure Paste class does not enter "last tool" stack because that's what's used at tool resume time now
						- Actually, see if helper really needs to set tool: if current tool is always suspended at call time,
						  the new tool will be automagically created by resume
							- Then the tool simply becomes "change tool for layer"
			- Make sure tool does not get resumed after a suspension		
			- Controller::AbortPaste()
				- Get tool as PasteTool, and invoke Abort() on it
				- Then, destroy (reset) mCurrentTool, and activate previous one for the current layer
			- Controller::CommitPaste()
				- Get tool as PasteTool, and invoke Commit() on it
				- Then, destroy (reset) mCurrentTool, and activate previous one for the current layer
			+ Controller::RotatePaste()/etc.
				+ Get tool as PasteTool, and invoke Rotate()/etc. on it
			+ Controller::SetPasteIsTransparent:
				+ Invoked by MainFrame upon toggles of settings flag
				+ Get tool as PasteTool, and invoke Set"Opaque/Transparentness"() on it
			- PasteTool:
				- cctor:
					- TODO
				- dctor:
					! If pending: commit
					- TODO
				- Leave():
					- TODO
				- Abort():
					! Undo eph viz, and make sure subsequent dctor does not see it as pending
					- TODO
				- Commit():
					! Undo eph viz, Commit, and make sure subsequent dctor does not see it as pending
					- TODO
				- Rotate()/etc.:
					! Do operation on own mPasteRegion
					- TODO
				- Set"Opaque/Transparentness" (for changes)
					- TODO
				- MouseDown():
					- TODO
				- MouseUp():
					- TODO
				- ShiftDown/Up:
					- TODO
			- ModelController::Paste(LayersRegion, origin, opaque/transparent) X 2 (ephemeral, normal) -> GenericUndoPayload
				- TODO
		- Tests:
			- Make sure none of the Paste tools may be selected by user
			- What happens after PasteTool is gone:
				- TODO
			- TODO

	- Tests:
		- Ropes paste carries with it both and only ropes w/both endpoints in region, and with one endpoint in region
	- Merge back into master

+ RenderContext:
	+ Single-threaded
	+ Initializes on same canvas that main frame initializes on
	+ Renders synchronously, on-demand via SB::MainFrame::OnPaint()
	+ ViewModel:
		+ Terminology:
			+ WorkSpace: has the pixel size of the structure (equivalent of ::World)
			+ WorkSpaceCoordinates (type @ ShipBuilderTypes)
			+ DisplayLogical: has the logical display (window) size (equivalent of ::Logical)
			+ DisplayLogicalCoordinates: the logical display coordinates (type @ ShipBuilderTypes)
			+ DisplayPixel: has the pixel display (window) size (equivalent of ::Pixel)
			+ DisplayPixelCoordinates: the pixel display coordinates (type @ ShipBuilderTypes)
		+ World coords is model pixel coords, i.e. WorkSpace
		+ Tells outside world of pan extent (for scrollbar width setting)
	+ Primitives:
		+ Background text
		+ Structural RenderColor Texture
		+ Electrical RenderColor Texture
		+ Pseudo-cursor
			+ One of many types; removed with a single call


+ WorkbenchState
	+ Independent from model - exclusively tools-related settings
		+ So no need to reset/change/update at new model creation
	+ Saves and loads (some of) its settings from json

+ Validations:
	+ Move validations to own class - ModelValidator
		+ Exports one static method
	+ Electrical connectivity validation
		! Verifies that sources are connected to sinks and viceversa - both electrical and engine
		+ Pass 1: detect "electrical sources" (generators), "electrical components" (anything that's supposed to be reachable, e.g. non-self-powered lamps, switches, engine controllers, etc.), "engine sources", "engine components"
			+ Have 2D buffer of uint8_t union with flags, incl. "visited" flags
		+ Pass 2: for each source & sink category:
			+ Flood from each element, propagating through an element if it's flagged as "connector"
				+ Use private helper for this
			+ When done, detect all "opposites" (source->sink, sink->source) that are not reachable and complain
	+ Electrical panel: not too many elements visible 

- Visualizations:
	- Electrical layer's "circuit" visualization

= Ship file format:
	+ Fixed endianness
		+ See https://github.com/voidah/archive/blob/master/archive.h
	+ FS version
		+ Only used for warnings in case materials not found and cur version > file version
	+ "File lock" which disallows editing
		! Password from user; salted -> Hash in Metadata
		! Verify hash matches when editing
	- Also includes sounds
		- Extract from other "TODO" .txt file

- Ubuntu:
	- Test User Ships folder

- Misc:
	- Localization:
		- See if can do separate extraction into separate file, which then is loaded at all times by LocalizationManager together with the other one 
	- Ruler: pick a scale (pixels to meter of original ship), then you choose how long the ruler
		- L shaped: horizontal and vertical
		- Ruler sticks to the canvas
		- Only one ruler at a time
	- Ship bootstrapper from texture
		- Uses fg and bg color for contour/interior
	- Selectable backgrounds		
	- Inherits FullScreen state and shares state changes (so, for example, if exits full screen in ShipBuilder, also Game has exited full screen)
		- How to share state changes? 
			- FullScreenManager class, shared_ptr in both
			- Looked at at each Game<->ShipBuilder switch by receiver
	+ Windows installer (or ShipBuilder::MainFrame cctor): on Windows, register shell icon handler for .shp2 files, and icon
	- Each time we StartTool() (e.g. at AddLayer, etc.) we end up refreshing modelcontroller's visualization and OpenGL visualization, twice
	- TO-SPEC:
		- What to do with background music when switching back and forth?
	- Ability to import an image to trace over it
		- Like a texture layer, but not saved and not part of the ship
	- MainFrame: add "export to image" button (in non-layer-specific ribbon) - basically a Screenshot tool
		- Screenshot for the current visualization(s), i.e. the canvas render buffer as it is
	- MaterialsPalette: make flag for making it its own wxFrame, so one can use it in a second monitor

- Ephemeral visualization rearch:
	- Current structure:
		- Tool::ctor, Tool::EndEngagement: Take orig clone
		- @ Do:
			
			- DoFillForTempVisualization
				- Layer + Render buffer, ONLY
			- DoFillForTempVisualization
			- DoFillForTempVisualization ...

			- UploadVisualization
			- RefreshView
		- @ Mend, @ End:
			- RestoreStructuralLayerRegionForEphemeralVisualization(orig clone)			

			- UploadVisualization
			- RefreshView
		! Total cost:
			- Tool create: 1 alloc + 1 full copy
			- Tool move: 1 region blit + 1 region fill + 1 full upload
			- Tool end: 1 region blit + 1 full upload
	- Proposed structure 1: token (aka "session")
		- Spec:
			- High-level:
				- The "real" model is never changed during temp visualization
				- The token/session wraps ModelController, providing the latter with own buffers when doing ops on temp viz
					- ModelController operations that happen on both model and temp viz model are implemented generically so they accept external buffers as well
						- Outsourced data:
							- Layer itself
							- Layer viz + its Dirty region == struct LayerVisualization { uq_ptr<RgbaImageData>, opt<Rect> }
			- Tool::ctor, Tool::EndEngagement: 
				- ModelController::InitiateTempVisualization() -> TempVisualizationToken
					- TempVisualizationToken::cctor: take orig clone
					- Tool stores token
			- @ Do:
				- TempVisualizationToken::DoFillForTempVisualization
					- Forwarded to ModelController
				- TempVisualizationToken::DoFillForTempVisualization
				- TempVisualizationToken::DoFillForTempVisualization ...

				- TempVisualiationToken::Render
					- UploadVisualization
					- RefreshView
			- @ Mend:
				- TempVisualizationToken::UndoTempVisualization
					- RestoreStructuralLayerRegionForEphemeralVisualization(orig clone)			

					- UploadVisualization
					- RefreshView
			- @ End (dctor):
				- Same as @Mend
			! Total cost:
				- Tool create: 1 alloc + 1 full copy
				- Tool move: 1 region blit + 1 region fill + 1 full upload
				- Tool end: 1 full upload
		- Details:
			- ModelLayerEphemeralVisualizationSession<TLayer>
				+ Not copyable, yes moveable
				- Members:
					- References to arch members:
						- ModelController &
					- TLayer mOriginalLayerClone
					- LayerVisualization mWorkVisualization
					- Session:
						- DirtyRegion == std::opt<Rect>
				- cctor(ModelController &):
					+ Take original layer clone
					+ Initialize session
						+ DirtyRegion=nullopt
				- Fill(rect, material)
					- 
				- Mend()
					-
				- ~dctor():
					- 
		- TODOs:
			+ Clone rearch

--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
DONE
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------

+ Move/merge integral coords/size from shipbuilder to game
	+ Game: "ShipSpace" and "DisplayPhysical/Logical"		
	+ ShipBuilder

+ SB::ViewModel: ortho matrix: see again why ShipSpace says positive bottom
	+ Anchor to the top

+ LayerBuffer.h: "layer buffer" types
	+ StructuralLayerBuffer == Buffer2D<StructuralElement, ShipSpace>
		+ StructuralElement = <StructuralMaterial*>
	+ ElectricalLayerBuffer == Buffer2D<ElectricalElement, ShipSpace>
		+ ElectricalMaterial = <ElectricalMaterial*, instance ID>
	+ RopesLayerBuffer == Buffer2D<RopeElement, ShipSpace>
		+ RopeElement = <StructuralMaterial*, endpoint ID>
	+ TextureLayerBuffer == Buffer2D<rgbaColor, ImageSpace>

+ Use "layer buffers" at ShipFactory
	+ ShipMaterialization class (@GameLib): four buffers
	+ static ShipFactory::MaterializeShip(...) -> ShipMaterialization
		+ See first if can make whole ShipFactory static again
		+ Also includes filling-in Ropes from rope endpoints found in structure (legacy)
			+ Throw on conflicts, like (should be) now
		+ Also includes filling-in Electrical from electrical materials found in structure (legacy)
			+ Throw on conflicts, like (should be) now
	+ ShipFactory::WhateverNow(): use MaterializeShip to get ShipMaterialization and continue from there
		+ Given that you're at it: ShipFactoryTypes::ShipFactoryPoint: nuke vec2i and replace with ShipSpaceCoordinates (and user-facing coords being ImageCoordinates)
	+ Test:
		+ Basic:
			+ Legacy ropes
			+ Native ropes
			X Legacy+Native ropes
			+ Legacy electrical
			+ Native electrical
			X Legacy+Native electrical
			+ Texture
		+ Corner cases:
			+ Ropes: too many endpoints for same Rope ID
				+ All legacy
				+ All native
		+ Both auto-texturization settings
		+ Perf (before & after)
			+ Before: ~100ms (factory including auto-text)
			+ After: ~110ms

+ Check if also old code asserted on Szerszen cargo for hull

+ Ship De/Serialization
	! Spec:
		- Ultimate ship definition consists of LayerBuffers, not images (except for Texture obviously)
		- ShipMaterialization functionality currently in ShipFactory should move to legacy ship deserializer, for formats "png" and "shp"
			- This is where we're fine with doing the "legacy" tricks, and with e.g. inserting missing structural materials for rope endpoints in the ropes layer
	+ Impl:
		+ ShipMaterialization also carries all attributes of ShipDefinition
		+ ShipDeserializer			
			+ Load(filepath, MaterialDB) -> ShipMaterialization
				+ ShipMaterialization functionality currently in ShipFactory should move to legacy ship deserializer, for formats "png" and "shp"
					+ This is where we're fine with doing the "legacy" tricks, and with e.g. inserting missing structural materials for rope endpoints in the ropes layer
				+ png
				+ shp
			+ LoadPreview(filepath, MaterialDB) -> ShipPreview
				+ png
				+ shp
			+ Save(ShipMaterialization, filepath)
				+ NOP at the moment
		+ Nuke ShipPreview.cpp
		+ Nuke ShipDefinition.*, ShipDefinitionFile.*
		+ "ShipMaterialization" -> "ShipDefinition"
		+ Use ShipDeSerializer ipv ShipDefinition::Load
			+ ShipDefinition
			+ ShipPreview
		+ ShipFactory:
			+ Nuke MaterializeShip code, just begin with ShipMaterialization (now ShipDefinition) as arg

+ Review whole need of ropes creating structural endpoints @ load type from .shp files
	+ Do at ShipFactory::Create() within the first pass on Ropes (i.e. ExtractRopeSegments => PostProcessRopesLayer())
		+ Fix Szerszen
		+ Fix hull assert
		+ Fix RopesTest for Frontiers crash
	+ And subsequently, check the need for StructuralElement to have RenderColor

+ Model contains the four new layer buffer types (1 as member, 3 as uq_ptr)

+ Merge into shipbuilder

+ Undo
	+ Hierarchy: there are four subtypes of UndoEditAction - for each of the "layer buffer" types - on top of e.g. "resize" and "all layers"
		+ These four are all implemented via a single templated class, templated on TLayerBuffer
			+ Contains TLayerBuffer and origin
		+ Apply() invokes Controller::RestoreLayer(TLayerBuffer const &, origin)
	+ Dirtyness:
		+ Model::DirtyState == {array, metadata, ...}, w/=operator
		+ Base UndoAction has DirtyState member, given via cctor & exposed via getter
		+ Controller::Undo()

+ Auto-zoom on new ModelController
	+ By Controller, at cctor (i.e. after CreateNew() and CreateForShip())
		+ Via ViewModel->CalculateIdealZoom() const -> zoom, then set in ViewModel		

+ Grid view:
	+ Button right of transparency slider
	+ Controller->View
	+ View takes it in cctor
	+ Shader

+ Toolbar rearc:
	+ File panel
	+ Ship settings panel
		+ Resize
		+ Ship metadata
	+ Tool settings panel
	+ Check in-game

+ Replace "Yes/No are you sure" with "Do you want to save your changes before continuing?" -> Yes, No, Cancel
	+ "AskUserIfSure" -> "AskUserIfSave" => returns int (wxID_YES, wxID_NO, wxID_CANCEL)
	+ On yes, call SaveShip(), and if the latter returns false, take the Cancel route

+ ShipLoadDialog: doesn't catch new file
	! It's because at open we don't scan directory unless we've changed directory
	+ Solution:
		+ At open, if haven't changed dir, build map (ordered) of <filepath, last_modif> 
		+ Then compare map with same map built at PreviewReady handling
			+ Requires message to also contain last_modif
		+ If changed: follow same path as if directory changed
		+ Also: make snapshot as above, and then also passes it to thread as replacement of thread's first step
			+ Move ShipPreviewDirectoryManager::EnumerateShipFilePaths to here basically, improving it as we may avoid storing files if not ship files

+ New/Load/Save Ship
	+ Move ShipLoadDialog/etc. under UILib
		+ Test from game:
			+ Last directory is added to both ComboBox and UIPreferences
				+ Yes when loaded
				+ No when not loaded
			+ Show ship descriptions:
				+ Works in dialog
				+ Works at load
				+ User may override
		+ Second home button
	+ New
		+ UI: menu + button
		+ Always enabled
		+ Asks user if model dirty
		+ Invoke DoNewShip()
	+ Load
		+ UI: menu + button
		+ Always enabled
		+ Asks user if model dirty
		+ Open file load dialog
		+ If OK: invoke DoLoadShip(selected filename)
		+ TEST: in Game, 2 dialogs
	+ Save:
		+ UI: menu + button 
		+ Only enabled when dirty
		+ if !mCurrentFilename: invokes SaveAs(); else: invokes private SaveShip(mCurrentFilename)
	+ SaveAs:
		+ UI: menu + button
		+ Only enabled when dirty
		+ Open file save dialog for .shp2
		+ If OK:
			+ Invoke private SaveShip(selected filename)
		
	+ DoNewShip:
		+ Do
	+ DoLoadShip:
		+ Do
		+ Store filename as mCurrentFilename
	+ DoSaveShip:
		+ Ship Preview workflow:
			+ ShipDeSerializer: split out legacy into own class
			+ ShipDeSerializer: LoadShipPreviewData() and LoadShipPreviewImage(ShipPreviewData const &)
			+ ShipPreview ("ShipPreviewData") from .shp2 contains .shp2 filepath itself
			+ ShipDeSerializer::LoadShipPreviewImage: if type is shp2, call ShipDefinitionFormatDeSerializer::LoadPreviewImage(filepath)
				+ else: type can only be png (throw if not) - call legacy LoadPreviewImage() which loads image
				+ Then resize and trim (like it was @ ShipPreview)
			+ .shp2 format: preview is own tag, image chunk saved at ship save time - but only if there's no texture
				+ Order of chunks:
					+ If has texture: metadata, texture, ...
					+ Else: metadata, preview, ...
				+ Do LoadPreview
					+ Have one single main loop for the three load calls
		+ ShipDeSerializer::Save(ShipDefinition const &)
			+ Rearc exceptions:
				+ GameCore/UserGameException
					+ With enum
					+ Exception contains enum and string array
					+ LocalizationManager::MakeErrorMessage(LocalizableGameException const &)
						+ Formats
					+ Catch-&-localize @ callers
						+ Game
						+ ShipBuilder
						+ Preview
				+ Individual methods throw directly LocalizableGameException, no post-processing
					+ DeSerializationContext: private class with file FS version, stored as pair of integers
						+ Nuke MajorMinorVersion class
				+ Unit tests for all exceptions
					+ Header
					+ Unrecognized material in structural layer
				+ Test all w/localized strings
					+ Game
					+ ShipBuilder
			+ Header
			+ Metadata
			+ Ship size section
				+ And no size at buffers
			+ Replace ShipSize with struct ("ShipAttributes" or "ShipFoundamentals") having ship size, hasTexture, hasElectricals, FS version
				+ As a section, made of sub-sections
				+ Section is checked for presence before use, and sub-sections are checked for presence before constructing ShipFoundamentals
				+ Unit tests
			+ Preview
				+ Trim in-place
				+ Make sure image trimming happens only for legacy
			+ Structural layer
				+ RLE with variable-length "u 16-bit" count encoding
					+ DeSerializationBuffer::Read/Write VarUInt16
					+ Orig: 216Kb
					+ Compressed: 30.8Kb
				+ Read
					+ Then complete unit tests
		+ Store filename as mCurrentFilename
		+ Also do load for .shp2
			+ ShipLoadDialog wildcards
			+ ShipDeSerializer::Load():
				+ Header: check (via helper)
				+ Metadata
				+ ...
				+ Verify tail

+ Add some shading around ShipSpace canvas
	+ Four 1-pixel-wide quads drawn with matte color (black)
	+ If we use the same ortho matrix, we need to calc the ship space size of 1 pixel

+ Click-And-Draw use case:
	+ Structural Pencil tool (*)
		+ UndoStack.h/cpp, w/IUndoEntry interface w/UndoEntryType enum
		+ Controller: forward mouse events to tool
		+ View:
			+ Upload method for texture *region*
		+ Application: undo is only baked and added at mouse up, containing whole affected region
			! Spec:
				+ Tool makes clone of entire region at mouse down
				+ At each pixel edit, tool updates region's origin and size
				+ At mouse up, tool makes UndoEntry with clone of material region 
			+ Impl:
				+ Pencil tool is templated on LayerType
				+ Tool has std::opt<InteractionState> with ShipSpaceRect and clone of entire region
					+ LayerTypeTraits<LayerType> gives type of LayerBuffer					
				+ At mouse down: 
					+ Model::CloneStructuralLayerBuffer() -> StructuralLayerBuffer
					X Then capture mouse
				+ At mouse up, tool makes UndoEntry with clipped clone of material region 
					+ Buffer2D has method to be "regionized" (restricted)
						+ Unit tests
					X Then release mouse
					X Then set Model::StructuralLayer as dirty
			+ ModelController::XXXRegionFill does not return UndoEntry anymore
		+ See if OnMouseOut at Tool is really needed
		+ Undo stack:
			+ Owned by Controller, given to Tool
			+ Tool's action writes into UndoStack and invokes IUserInterface notification
			+ IUserInterface notification: Undo menu item
			+ MainFrame: on Undo, call into Controller::Undo()
			+ Controller::Undo:
				+ Calls UndoAction::Apply(this)
				+ Restores dirty state
		+ UndoEntry exposes:
			+ string GetTitle()
			+ std::uint64_t GetCost()
			+ void Apply(Controller &)
				+ Double-dispatch
		+ Controller::RestoreLayerBufferRegion(...) X 4:
			+ Invoke ModelController::StructuralRegionReplace(...)
				+ assert model has layer
				+ Do
				+ Recalc derived
			+ Mark layer as dirty
			+ Notify IUserInterface of dirtyness
		+ Fill-in mouse pointer jumps
			+ Function that takes two integral endpoints and calculates line path, at GameGeometry.h
				+ UnitTests
			+ Use it at PencilTool::CheckEdit:
				+ EnagementData has optional<ShipSpaceCoords> previousEngagement
				+ When we leave CheckEdit because out of bounds, we reset previousEngagement
				+ At application:
					+ Do RegionFill along the path
				+ After we apply the edit, we set previousEngagement
		+ Tool settings: size
			+ Size panel
			+ PencilTool: use size
			+ Rearc layer visualization
				+ Move buffers from Model into ModelController
					+ Add to model controller
					+ Remove from Model
				+ ModelController:
					+ Introduce dirty system for visualization layers: Update() sets dirty region, Upload checks which, uploads, and clears
						+ Single Upload, remove four individual ones
					+ Remove visualization layers upon removal of layers
				+ Controller & Pencil: in a single helper method: 
					+ Ask ModelController to upload visualization (which is based on dirtyness of visualization buffers)
					+ Ask UIInterface to Refresh()
				+ View: terminology: "StructuralLayerVisualizationTexture"
				+ Rethink removal of layers: need to trigger "turning off" of View textures
					! Sequence is: update (@MC), upload (@C)
					+ View::HasStructural/.../Texture() -> bool
					+ MC::Upload: if MC !have && view.has => View::RemoveStructural/.../Texture()
			+ Preview: 
				+ <from Moleskine>
				+ OnCaptureLost: reset tool
					+ Instead of current implementation
				+ Tool cctor: checks IUserInterface::IsMouseInWorkCanvas, based on actual hit test				
				+ OnMouseEnter: Nothing (remove)
				+ OnMouseLeave: forwarded only if not captured (by WorkCanvas)
					+ Tool: Mend temp visualization
				+ FIX: click on scrollbar causes "view change" hence a MouseMove on tool
					+ Controller::SetCamera: only do mouse move if mouse *in* work canvas, and *not* captured by any scrollbar
			+ Anchor
	+ Structural Eraser tool:
		+ Reuse pencil tool, with extra template arg

+ Default ship name (remove TODO)
	+ Use date & time
	+ Helper to make filename (in Utils)
	+ Use it when opening SaveAs

+ Eraser cursor

+ Electrical layer:
	+ Load and Save at DeSerializer
		+ Review MaterialDatabase's electrical material maps: make one map?
			+ Test:
				+ Load png ship with legacy electrical materials
				+ Load .shp ship with instanced and non-instanced materials
	+ Full electrical layer support, like structural
		+ Model
		+ ModelController
		+ Controller
		+ Undo
		+ PencilTool
		+ MainFrame
			+ Hook load->Model
			+ Hook Model->save
			+ LayerPanel
		+ View
			+ Electrical texture parallel
	+ PencilTool: 		
		+ Fix instance index given to fill: strategy for instance ID assignment: fully assigned by ModelController
			+ All primitives invoke internal WriteElectricalParticle(.)
				+ Carefully compare before & after to retain instance ids, create new ones, or reclaim old ones			
					! Strategy to ensure only consecutive IDs, OR only "initial" ones (even if scattered): use ElectricalElementInstanceIndexFactory, member of ModelController
					+ Keep instance IDs in-sync:
						+ ModelController cctor(def):
							+ Visit electrical layer and register existing instance indices w/factory
								+ Do in helper method, which also takes care of Factory::Reset()
									+ "InitializeElectricalLayer()", sets and does the elec analysis initialization below
							! Metadata::ElectricalPanelMetadata is already consistent
						+ New:
							+ Factory::Reset()
						+ Set (Load): 
							+ Visit electrical layer and register existing instance indices w/factory
								+ Do in helper method, which also takes care of Factory::Reset()
						+ Remove:
							+ Factory::Reset()
						+ ElectricalRegionFill						
				+ Also keeps count of electrical particles (for later analysis)
					+ Count initialized - via InitializeElectricalAnalysis() - at cctor,New,Set,Remove
						+ InitializeElectricalAnalysis():
							+ count = 0
							+ if buffer != nullptr: count
					+ Keep count updated
				! Technically, also does running analysis
				! Also takes care of electrical panel: new/removed/updated-type components								
	+ Re-do:
		! Spec:
			! Temp visualization (Fill and Mend) should not update analyses, nor EPM, nor instance IDs
			! Actual committed action (e.g. fill) should update analyses, EPM, and instance IDs
			! Undo: should replace EPM as well, and re-initialize analyses
		+ Impl:
			+ ElectricalLayer contains ElectricalPanelMetadata
				+ "LayerBuffer" -> "Layer" (source file name and type names)
				+ Take map element and map using from GameTypes
				+ Remove EPM from ShipMetadata
				+ LegacyDeser: json is parsed in two phases
				+ De/Ser:
					+ ElectricalLayer has sub-tags (Buffer and ElectricalPanelMetadata)
						+ Unit tests
					+ String tag values?
						+ 'S', 'T', 'C', '1' => S << 24 + T << 16 + C << 8 + '1'
				+ ModelController:
					+ cctor(def): make sure EPM is stored
					+ New: make sure EPM is zerod
					+ Set: make sure new EPM is stored
					+ Remove: make sure EPM is nuked
			+ UndoEntry of electrical must also contain whole ElectricalPanelMetadata
				+ It's Layer + Origin
				+ Should also fly with Structural
			+ Fill and Mend/Replace are split in two:
				+ FillElectricalLayerRegionForTempVisualization and RestoreElectricalLayerRegionForTempVisualization: 
					+ Just populate layer buffer; do not update analyses, nor EPM, nor instance IDs
					+ NOTE: "ForTempVisualization" -> ForEphemeralVisualization
					+ Maintain boolean for asserting at Fill and at RestoreElectricalLayerRegionForTempVisualization
				+ Fill:
					+ Populates layer buffer, and updates analyses, EPM, and instance IDs
						+ Via WriteElectricalParticle(.)
				+ RestoreElectricalLayer: for undo only
					+ Takes also EPM (simply by Layer, arg together with Origin)
					+ Blits layer region
					+ Re-initializes layer (analyses, and instance IDs - EPM already reset)
					+ Replaces EPM in own layer (by move)
					+ Args are by move
				+ Replace(.) goes
	+ Refactor StructuralRegionReplace in the same way (w/WriteStructuralParticle, mending/replace, etc.)
		+ StructuralFill also takes material* instead of element
		+ InitializeLayer & its calls
	+ Tests:
		+ Can load electrical in game, and has panel
		+ PencilTool
			+ Instance ID assignment
		+ PencilTool + Undo
			+ Instance ID assignment
		+ Make sure loading a ship w/legacy electricals makes up an electrical layer, and saving it saves the electricals
	+ Try: do not make line if instanced electrical element
	+ View: other layers' opacity  (NO visualization type! (yet))
		+ View::Set...: stores member
		+ Set param in shader at each use of the shader (i.e. at each layer rendering)
			+ Based on mPrimaryLayer
				+ Do setter and call setter from Controller, prior to visualization update
		+ Controller must refresh (just) rendering (not whole ModelController visualization!)
		+ Primary layer dynamics:
			+ Storage @ Controller				
			+ Controller::cctor sets it in view
			+ Controller::ChangePrimaryLayer: also set in view
		+ OtherLayersOpacity dynamics:
			+ Storage at view
				+ View has it among uploaded
			+ MainFrame: @ view creation: set value on slider, via OtherLayersOpacitySliderToOpacity
			+ MainFrame: @slider change: set value on Controller, via OtherLayersOpacityToSlider
				+ Controller::SetOtherLayersOpacity: sets also in view
			+ See TODOTEST log for opacity values
		+ StructuralLayer: no white BG? Then need BG @ View
			+ Shader: need to take pixel step parameter

+ Flood tool

----------------------

+ Validations:
	! Overview:
		! Validations may either be run by user, or run automatically before saving
		! Errors prevent ship from being saved
		! Some validations also run continuously
	+ Impl:
		+ Object model:
			+ ModelValidationResults:
				+ vector<ModelValidationIssue>
				+ Errors, Warnings, Successes
			+ ModelValidationIssue:
				+ Type
		+ Dialog:
			+ Populate results
				+ ForShipSave: all errors first, then warnings - no success					
				+ ForValidation: as they come
					+ Use sizer->Insert()
				+ Message of issue must be different when success, or title + message
					+ And no Fix button
				+ Handle issues as specific
					+ ElectricSubstratum: button for trimming
						+ Fix OpenGL-on-separate-thread issue
							+ Split Controller::Validate w/SuspendTool/ResumeTool
								+ assert from Validate that it's not in eph viz
								+ Also at MakeDefinition
							+ Suspend/Resume called from main thread in validation dialog
						+ Fix issue with temp viz drawing at ResumeTool()
							+ Should Controller suspend tool automatically at LeftWindow and resume at EnterWindow?
								+ Both only if !captured
							+ Do ToolGuard RIAA - should remember whether it really suspended or not, and resume at destructor only if it did suspend
								+ And at ValidateModel: should now be able to safely simply suspend/resume
								+ And at RestoreLayerRegion
						+ Store undo at Controller::Trim
							+ ModelController::Trim must return region
					- Visualize other issue types
				+ Message before errors and message before warnings - in ForSave mode		
		+ See if can have gauge also @ save
			+ SessionData::IsInValidationWorkflow
				+ Init: false
			+ @timer end:
				+ If IsForSave && all success && !IsInValidationWorkflow:
					+ EndModal(OK)
				+ Else:
					+ IsInValidationWorkflow = true
					+ ShowResults
			+ UI:
				+ cctor: no sizes
				+ ShowModalForStandAloneValidation:
					+ this->SetMinSize(-1, -1)
					+ this->Fit()
				+ ShowModalForShipSave:
					+ Caller doesn't calc nor passes validation
					+ this->SetMinSize(-1, -1)
					+ this->Fit()
				+ ShowResults:
					+ this->SetMinSize(...size...)
					+ this->Fit()
			+ ShowResults:
				+ Not fit
			+ Fix first StartValidation @ ShowModal's: should be called after ShowModal has caused LeaveWindow on WorkCanvas
		+ Dialog open for ship save:
		+ Do validations:
			+ ShipSizeTooBig
			+ Empty structural
			+ TooManyLights
		+ Test
			+ Workflow 1: validation
			+ Workflow 2: save
				+ When there are errors
				+ When there are no errors and there are warnings
				+ When there are no errors and no warnings

+ Mattia makes ship
	+ YouTube
	+ GameJolt post

+ At selection of new primary layer (in Controller): select first tool
	+ Or remember tool per-layer
		+ Have array for all layer types (int) storing tool type
		+ Controller::SetTool:
			+ Store this tool as last tool of primary layer
		+ Controller::SetPrimaryLayer:
			+ After switching UI: set last tool for new primary layer
	+ Fix:
		+ New code creates tool (via SetTool invoked to set last tool for layer) while tool is "suspended", @ NewLayer & RemoveLayer, when we set PrimaryLayer
		+ SetTool, SetPrimaryLayer, NewLayer, RemoveLayer: they all call InternalSetTool & InternalSetPrimaryLayer

+ Eraser square?
	+ See paint: has it
	+ View: EraserSquareOverlay

+ EraserSquareOverlay -> RectOverlay
	+ Rename
	+ Try it also with normal pencil

+ Pencil electrical: not on empty structural
	+ Eph viz: red rect overlay when on empty
		+ Shader
	+ Do action: no fill when on empty

+ No flood for electrical layer
	+ Simply remove specialization
	+ Also remove ModelController::Flood specialization

+ Flood: settings: adjacent

+ UnderConstructionDialog
	+ Do at remaining layer buttons

+ Send for testing

+ Password Workflow
	+ Hash algo at ShipDeSerializer via static helper method
	+ Workflows
		+ Save: ShipDeSerializer::CalculatePasswordHash(password): +salt => hash (new GameType) => in metadata
		+ ShipBuilder::Open and Game::EditInShipBuilder and various layers' Import: after load, if ShipMetadata has password:
			+ Ask password
				+ Workflow for wrong password
					+ Dialog w/timer, EndModel @ 3rd round
					+ "Invalid password"
					+ "Retry in {}..." (iff ! last time)
					+ Max 3 times
			+ ShipDeSerializer::CalculatePasswordHash(password) => check with metadata
			+ All in own dialog, in static bool CheckPasswordProtectedEdit(shipDefinition) which includes workflow
			+ Do at:
				+ ShipBuilder::OpenForShip
				+ Menu/Button LoadShip
	+ Test:
		+ Save ship w/password
		+ 1. Load it in FS & Open ship builder
			+ Password OK
			+ Password not OK => NewShip
			+ Frame is not yet open when password is asked
				+ Fix
				+ Test:
					+ From FS:
						+ Edit PW ship => ok pwd
						+ Edit PW ship => no pwd
						+ Edit non-PW ship
						+ Create new ship
					+ From builder:
						+ Create new ship
		+ 2. Load it in builder
			+ Password OK
			+ Password not OK => no change

+ Undo stack visualization
	+ UndoPanel underneath toolbar
	+ Controller exposes GetUndoStack() const
		+ And UndoStack exposes index-based enumerator 
	+ MainFrame can tell Controller to rewind undo to a given stack entry, by index
	+ HighlightableTextButton

+ Complete Load/Save/Model
	+ Finalize storage of all other ship definition members in Model
		+ AutoTexturizationSettings
			+ Test w/PropertiesDialog
	+ ShipDeSerializer: Load/Save each of:
		+ Electrical layer
		+ Ropes layer
		+ Texture layer
			+ Using DevIL lump, see https://github.com/DentonW/DevIL/blob/master/DevIL/src-IL/src/il_io.cpp#L2490
		+ PhysicsData
		+ AutoTexturizationSettings
			+ Test
				+ w/PropertiesDialog
				+ Load .shp -> Save .shp2 -> Load .shp2 in FS

+ Metadata edit workflow:
	+ ShipPropertiesEditDialog
	+ Dialog::Open takes Controller &, Metadata const &, PhysicsProperties const &, etc.
		+ Pass bool HasTexture (to enable ArtCredits)
		+ opt<struct> mSessionData
		+ Populates all controls
		+ Flags each control as being not dirty
	+ Editing a field flags it as being dirty
	+ Ship name
	+ Author(s)
	+ Art Credits
		! Spec: we allow ModelController to carry stale credits when texture is removed - OR NOT: replace won't signal layer removal
		+ Enabled and populated only iff HasTexture
		+ ModelController: remove ArtCredits when texture is removed
			+ Test
		+ Test
	+ Year Built
	+ Edit Password
		+ Make new tab
	+ Description
		+ Separate tab
		+ Populate at startup
		+ Check for dirty @ OK
		+ Give to ModelController at OK
	+ PhysicsData
		+ Populate tab
			+ ShipOffsetVisualizationControl
				+ Zoom calculation:
					+ Integral/ShipSpace - coords to/from world
					+ Add CoordsRatio to ShipMetadata
						+ Legacy loading: 1:1
						+ New Format loading:
							+ defaults to 1:1
							+ Load it
							+ Save it
							+ Test
					+ Use it @ ShipOffsetVisualizationControl
						+ Test it w/4:1
					+ Use it @ ShipFactory
		+ Populate UI at startup
		+ Give to ModelController at OK
			+ Verify becomes dirty
			+ Verify all 3 saved
		+ See why pressure is not 1.0 at startup
	+ Auto-Texturization Settings
		+ Populate tab
			+ Radio button to handle Remove vs Setting values
			+ Whole tab disabled <=> has texture
			+ Consider using explanations
				+ Use icons, like password
				+ Auto-texturization mode "radios"
				+ Horizontal sliders, explanation below
					+ SliderControl needs to take own HORIZONTAL vs VERTICAL enum
						+ SettingsDialog
					+ Explanation below
				+ Add some V spacing around sliders
		+ Populate UI at startup
			+ Move default AutoTexturizationSettings to default cctor of AutoTexturizationSettings
				+ Out of ShipTexturizer
		+ Give to ModelController at OK
	+ At OK:
		+ For each of Metadata, PhysicsProperties, etc:
			+ Check if any of this area's controls are dirty; if so:
				+ Construct new Metadata, PhysicsProperties, etc.
					+ Set optionals to nullopt if trimmed field is empty
				+ Call Controller::ReplaceMetadata(&&), etc.
					+ Which in turn invokes IUserInterface callback for refreshes, which do NOT reach edit dialog though
			+ Make Undo entry @ Controller
				+ Try: GenericUndo, with lambda that just takes Controller and captures things
				+ For undo entry: need one single Controller method for all pieces, with opt args (e.g. opt<opt>)
				+ Test
			+ IUserInterface callback: change it to ShipNameChanged
				+ Call it also at undo
				+ Do workflow for rename here:
					+ MainFrame: compare output of MakeFilename() on new ship name with current filename, and if different && there is a current which exists as a file:
						+ Ask rename
							+ If yes:
								+ Rename file (filesystem)
								+ Change current
							+ If no:
								+ If has a current: clear current (and Save will become SaveAs)
								! If has no current: Save is already set to become SaveAs, we're OK
	+ Tests:
		+ Load & save ship w/auto-texturization settings
		+ New ship:
			+ Populate one x {...}
			+ Close
			+ Reopen - verify it's there
			+ Save - verify it's there @ load
		+ Ships with unicode chars in metadata, show well in dialog: Dsire 
			+ Load ship
			+ New ship
			+ Load .shp ship

+ Grid: highlight vertical center guide
	+ Test with odd ship width

+ Edit menu: Flip Horizontal, Vertical
	+ Buffer2D::Flip(...)
		+ Unit tests
	+ Ropes layer's buffer becomes a class, so it also has Flip()
		+ Unit tests
		+ Redo:
			+ LayerElements.h contains all layers' elements
			+ RopeLayerBuffer.h is the buffer
			+ Layers.h becomes smaller
	+ Undo: flip again
		+ New Undo form:
			+ Controller::RestoreLayer/Region: "...ForUndo"
				+ Don't set model dirtyness
			+ Controller::Flip + Controller::FlipForUndo
				+ Templated helper
					+ In undo mode: don't set model dirtyness, and don't push undo entry
		! Always do UploadVisualization+RefreshView however, as UndoStack can't do that (not all undo's must refresh viz)

+ Line tool:
	+ Settings: size
	+ Structural
	+ Electrical
		+ RAII Mend
		+ Do different algo for line tracing, to ensure pixels touch each other on the side
			+ Both at eph and non eph
			+ Not really needed - make "HUll" flag to turn or or off for structural, unused in Electrical
		+ Do not write on empty structural pixels
			+ Both at eph and non eph
			+ Verify engagement & subsequent drawing work fine (engage yes but no draw)
				+ Verify also at ElectricalPencil
		+ Dashed line overlay
			+ smoothstep and color between dashes
			+ Scissor dashed line
			+ Nail down pixel length/multiple
	+ Refactor line drawing call in LineTool as it's repeated twice
		+ Make helper
		+ Use it all all places
	+ Shift lock

+ Finalize design of Ropes layer
	! Spec:
		! Material Strategy: in Structural DB, separate palette tree - does NOT require current "ropes" to be marked as "legacy"
		! Element = start, end, StructuralMaterial *, renderColor
		! Legacy: StructuralMaterial=Ropes, RenderColor=color
		! ShipBuilder: StructuralMaterial=from ropes palette, RenderColor=from material
	+ Impl:
		+ Structural DB: separate palette tree
			+ Script
			+ MaterialsDB			
		+ Layers
		+ Legacy Deserialization
		+ ShipFactory
		+ Test
		+ SB::MaterialsPalette:
			+ Templated on layer - Material comes from TypeTraits
		+ LayerPanel for Rope
		+ New Ropes Layer workflow
		+ Test
		+ WorkbenchState		
		+ Pencil Tool
			+ View::CircleOverlay
				+ Shader
			+ Tool visualizations:
				+ Superimposed states:
					+ Overlay, at:
						+ cctor
						+ dctor
						+ MouseMove
						+ NOT at down/up X 2
					+ Engagement (i.e. line), at:
						+ Down x 2: engage if OK (if Model::IsRopeEndpointAllowed)
						+ Up x 2: disengage if engaged
						+ MouseMove: if engaged
			+ DoEdit
			+ CommitAndStopEngagement
				+ Undo
			+ ModelController::TempVisualization
		+ ModelController::Visualization
		+ ModelController::RestoreRopesForEphViz takes whole orig layer
		+ No check for end engagement
		+ IsApplicable: also ship rect
		+ View::RopesLayer
			+ Line OpenGL settings
			+ Upload straight away, no storage
			+ Render: before or after depending on primary layer
			+ Line width
			+ @Vertex-make-and-upload: Offset vertex to center of {1,1} ShipSpace rect
		+ Mouse released outside of window - while mouse is captured - does not nuke tool
			+ Note: this is a problem with the other tools as well
			+ Fix @ MainFrame::OnWorkCanvasXXXUp
		+ No temp visualization when mouse outside of coords - or simply, when mouse coords are not applicable
		+ Test
		+ "Move endpoint" mode
			! Spec: when button down (engagement check) is over existing endpoint, then start point is other
			+ Impl:
				+ Overlay:
					- If outside ship rect: RED
					- Else if engaged: check if OK to release 
						- May release only if there's no other rope endpoint at that position
					- Else (!engaged): check if OK to engage
						- Always
				+ StartEngagement:
					- If outside ship rect: NO
					- Else: check if OK to engage
						- Always
				+ EndEngagement: do action:
					- If outside ship rect: NO
					- Else: check if OK to release
						- May release only if there's no other rope endpoint at that position
			+ Test		
		+ DeSerialization
			+ Unit tests
		+ Opacity
			+ Shader: add param
		+ Test pencil: L and R buttons
		+ Remove Clear material from Ropes palette
			+ Remove checks from pencil, as matrial can never be clear
		+ Eraser Tool:
			! R button does the same as the L button (same as in structural/electrical)
			! No engagement - at L down we do the same as with temp viz
				! And we don't even ask ModelController, always EraseRopeAt(ForEphViz)
			+ Rethink: possibilities:
				+ No eph viz (w/deleted rope)
				+ Overlay gives feedback (red when won't delete anything)
				+ If we go for it:
					+ Remove ...ForEphViz method from ModelController
					+ Remove mHasEphemeralVisualization - et al
	+ New materials:
		+ Chains			
			+ For noise: consider adding new StructuralMaterial property: strain_threshold_fraction, default = 0.5
				+ Material
				+ Springs::UpdateForStrains:
					+ Springs::mBreakingElongationBuffer: it's buffer of two-float struct, BreakingElongation and StrainThresholdFraction
				+ Set at Chains material
				+ Test Chains
				+ Test other materials for no changes to strain threshold
			+ Rustyness
			+ Verify properties look'n'feel (tension)
		+ "Rubber Band"
			+ Sounds:
				+ Stress
				+ Break
				+ Underwater (above X 2)
				+ Destroy (copy from break, above- and under-water)				
			+ Create material
				+ See water intake
		+ Aluminium Chain
		+ "Strong" variants for all rope sub-categories
			+ In same category, but different sub-category (e.g. "Iron Chains" and "Iron Chains Strong" - see where we've put "Hull"); only strength (and possibly stiffness) changes

+ Texturization rearc:
	! Auto-texturizer stays as it was one step ago: auto-texturization (with no triangulation) - and sample-texturization
	! ShipBuilder produces StructuralTexture doing its own triangulation on top of texture, and adding offset (baked into texture)
		! View does NOT add offset
	! New viz: "Game"
	+ Undo ShipTexturizer changes; revert to:
		+ Auto-texturization - with no triangulation
		- Sample-texturization
			- Comment-out triangulation
			! We will remove triangulation shortly
	+ Comment at ShipFactory::MakeTextureCoords
	+ Do test on autotexturization: confirm that bottom-left triangle is textured based on quad above *and* quad to the right
	+ New SB enum: VisualizationType
		+ Game, StructuralLayer, ...
	+ New viz mode enum: GameVizMode; values: auto-tex, texture, none
		+ StructuralVizMode instead becomes: "pixel", none
	+ VisualizationType is now the type of PrimaryLayer
		+ View
		+ Controller
		+ MainFrame
	+ UI:
		+ New "layer" row above Structural for Game viz
			+ Toolbar tools for this layer is same as structural
			+ No new/remove/import/export buttons
			+ Viz mode buttons
		+ StructuralLayer has just pixel and "none" viz modes
		+ All viz modes have "none"
	+ ShipBuilder::View has two new "texture" viz: Game
		! StructuralLayer viz texture goes back to being a small texture of size=ShipSize
	+ MainFrame: enablement of OtherVizOpacitySlider should be true also when structural + game
		+ So always enabled?
	+ ModelController visualizations:
		+ Controller & ModelController: viz mode is not anymore std::opt (as we have None)
		+ New Game viz:
			+ Updated each time we update either Structural or Texture vizs
			+ Viz members:
				+ Auto-tex texture
				+ own texture
			+ UpdateGameVisualization Algo:
				+ If auto => update auto-tex texture; source=auto-tex texture
				+ Else if tex => source=tex texture
				+ Else if none => return
				+ Sample source into own texture using triangulation and 0.5 offset 
					+ Double-check Y-order of 1,2,3,4 vertices
					+ Do 0.5
	+ When loading ship with texture, game viz's auto-texturization mode does not get switched to texture mode
	+ Perf of game viz texture: upload only sub-texture
		+ ModelController needs to remember also DirtyViewRegion
	+ View:
		+ Nail down Z-order of visualizations
			+ Between game and struct: primary goes first
			+ When texture layer is primary: texture layer should go first
			+ May be rule is: whichever of game, structure, texture is primary, goes first; elec and ropes are fine to always be super-imposed 
				+ Exception: ropes goes always *behind* when it's not primary
		+ Make Texture texture drawn with 0.5 offset
			+ Quad: from Ship=(0,0) @ tex=(0.5/w, 0.5/h) to Ship=(w-1, h-1)+1pixel @ tex=(1.0-0.5/w, 1.0-0.5/h)
	+ Structural layer viz: do Particle mode
		! Via shader
		+ MainFrame:
			+ Button
				+ Icon: square with circle
		+ Controller
		+ ModelController
		+ View:
			+ Methods
			+ Shader
			+ VAO setup
			+ OnViewModelUpdated
			+ RenderStructureParticles
			+ ModelController/View: not separate structurual layer, but View::StructuralLayerVizDrawMode (=={Particle, Pixel}) => mStructuralLayerVizDrawMode ShaderType
				+ Then: UploadXXXVisualization()/Has/RemoveXXXVisualization()
		+ See if we want it to be the default

+ Visualization modes:
	+ Each layer has a visualization mode
	+ Selectors are in new set of panels - with visibility dependent on primary layer - in LayersVisualization panel
		+ On top of grid view button
	+ Modes: (each an enum in ShipBuilderTypes)
		+ Game:
			+ Auto-Texturization (only if texture layer does not exist)
			+ Texture (only if texture layer exists)
		+ Structural layer:
			+ Pixel
			+ Particle
		+ Electrical:
			+ Particle
			- Circuit (long-term)
		+ Ropes:
			+ Lines
		+ Texture:
			+ Matte
	+ Dynamics:
		! Spec:
			- ModelController APIs take opt<viz mode> so that Controller can orchestrate turning whole layer viz on or off
				- e.g.: texture viz is only on if structure mode is particle
				- Controller is responsible for turning on/off entire layer viz - ModelController does nothing at New and Remove
		+ Controller::SetXXXVisualizationMode
			+ Set mXXXVisualizationMode
			+ Call UpdateVisualizationMode()
			+ Refresh view
			+ IUserInterface->OnXXXVizModeChanged()
		+ Hook buttons to Controller::SetXXXVisualizationMode
		+ private InternalUpdateVizModes:
			+ Called at each change of:
				+ Layer presence
					+ Including cctor
					+ Including undo restore's
				+ Viz mode change
			+ Orchestrate calls to ModelController::SetXXXVisualizationMode
		+ ModelController::SetXXXVisualizationMode(opt)
			+ if (new == old) => nop
			+ If !new && old:
				+ Free texture
				+ Clear DirtyXXXVizRegion
			+ Else if new != old:
				+ (Re)alloc texture // This moves here from UploadVisualization() and initializations (cctor and New() calls)
				+ UpdateXXXVisualization(whole region) => will update dirty region
			+ Store mXXXVisualizationMode
			+ Remove init/shutdown @ 
				+ UpdateXXXVisualization()
				+ RemoveLayer
			+ UpdateXXXLayerViz:
				+ No check for layer presence, but assert
		+ ModelController::cctor:
			+ No viz initialization, will be done by Controller
		+ ModelController::SetXXXLayer:
			+ ...set XXX layer...
			+ Note: only works like this if new size == old size, hence no realloc; see if it's also the assumption here
			+ UpdateXXXVisualization(whole region)
		+ ModelController::RemoveXXXLayer:
			+ No viz removal, will be done by Controller
		+ ModelController::UpdateVisualization
		+ ModelController::UploadViz
			+ Remove from view if has it and don't need to do
	+ Misc:
		+ MainFrame: enable/disable structural texture mode at OnLayerPresenceChanged
		+ Check out that ElectricalTexture vertex creation TODOHERE in View.cpp
		+ new texture mode for...no texture
			+ UI
				+ Icon for structure-matte
			+ Controller
			+ ModelController
			+ See UI: when texture layer is created, which one is selected
	+ Auto-texturization visualization
		+ ModelController::SetStructuralLayerVizMode: realloc texture for right sizes when changing between types that require different...sizes
		+ Verify settings
	+ Texture visualization
		+ ModelController::SetStructuralLayerVizMode: realloc texture for right sizes when changing between types that require different...sizes
		+ ShipTexturizer: new method with whole new implementation, which takes texture from outside (& no settings)
			+ But still based on same magnification
			+ Has "triangle" algorithm, based on count of points in four vertices of each square
		+ Does structural vix for region Foo impact region outside Foo? If so, take that into account at ModelController::UpdateStrucuturalViz, enlarging dirty region (possibly among other things)
		+ Make sure that when checking for vertices, we're not constrained by region size but rather by whole structure size
		+ Verify triangulation matches Game's
		+ See if can make lines for those cases that only have two vertices
			+ Fix eph viz restore - leaves triangle at x-1
			+ Ugly; rearc:
				+ Undo ShipTexturizer changes
				+ Change structural layer's "particle" mode into "mesh" mode
					+ Naming
					+ Icon
					+ Shader
						+ Sampling issue
						+ Diagonal lines: redo line equation (need x/y ratio)
						+ Border sampling
	+ Perf improvements:
		+ Auto-texturization
			+ Do benchmarks
			+ Do we need to store whole vec3f in texture? Can just R (and possibly A for future transparent material textures like Chain) suffice?
			+ Merge together multiply-blend with Mix
			+ Compute x int+fract once for each of the magnificationFactor rows
			+ Avoid worldX/Y re-multiplication by changing it into textureX/Y (and adjusting incr accordingly)
			X constexpr pointers
		+ RenderShipInto:
			+ Do benchmarks
			+ Replace round with truncate(. + 0.5)
	+ See perf of new auto-texturization wrt previous released version

+ Do not switch to primary-texture at Controller::SetTexture, for now

+ Resize workflow:
	+ Button - in Ship Settings panel, slightly separated from the File buttons
	+ Click -> Dialog for Canvas Centering/Clipping (i.e. "Anchor choice") -> Controller -> MC::ResizeShip()

+ Edit->Trim()

+ Send for testing

+ Rearc of libs:
	! libs (zlib, jpeg, png) no more statically linked into DevIL and wxWidgets
	+ Backup build folders (DevIL, wxWidgets)
	+ Test on 64-bit:
		+ Build DevIL 64 without linking-in
		+ Build wxWidgets 64 with external ZLib, JPEG, and PNG (not built-in)
		+ FS:
			+ First off, verify can't link because all three are missing
				+ With wxWidgets with built-ins:
					+ Benchmark: PNG and JPEG are missing
					+ ShipBuilder: PNG is missing
				+ With wxWidgets without built-ins:
					+ Benchmark: PNG and JPEG are missing
					+ ShipBuilder: PNG and JPEG are missing
			+ Update CMake to take also ZLIB, PNG, and JPEG from UserSettings.cmake
				+ Also change comment in main CMake for IL/static libs
			+ Build 64:
				+ benchmarks RelWithDebInfo
				+ FloatingSandbox RelWithDebInfo
				+ FloatingSandbox Debug
	+ On success:
		+ Update readme w/dependencies
		+ Start "building on Windows" doc
		+ See to fix FS linker warning about "Editandcontinue / Incremental"
		+ Build DevIL:
			+ Update my edits to DevIL's cmake: remove zlib, png, and jpeg *lib files*
			+ 64
			+ 32
		+ Build wxWidgets 32
			+ Unify output under single SDK folder
		+ Re-generate FS solution files
			+ 64
				+ Verify wxWidgets pickup
			+ 32
				+ Verify wxWidgets pickup
		+ (Re-)Verify all builds: ALL_BUILD and run FS:
			+ 32
				+ RelWithDebInfo
				+ Release
				+ Debug
			+ 64
				+ RelWithDebInfo
				+ Release
				+ Debug
	+ Finish Windows build instructions

+ Commit + Push

+ Ubuntu build
	+ Verify we need jpeg
	+ Install jpeg
		+ Update instructions
	+ Build DevIL
	+ Build wxWidgets
	+ Build FS (release)
		+ Fix C++ compilation issues

+ Install: copy also ShipBuilder.exe

+ Merge into master

+ Fixes:
	+ Fix assert after removing structural viz mode
		+ Change: allow dirty region setting, reset at UpdateViz() also when None
			+ And Nuke ClearDirty()
	+ ModelController::GetStructuralVizMode when "none" is set

+ Fix OpenGL issues
	+ Rearc:
		+ 1. Controller owns View which owns OpenGLContext
			+ View ownership
			+ Context creation by View
			+ Mouse is in LogicalDisplayCoords
			+ Finalize Controller reset at each creation
			+ Fix background image
				+ Need to re-upload vertices at each view model change
			+ Test at end:
				+ Other layers' opacity slider <-> view
				+ UI reconciliation at each of Controller creations
				+ Ubuntu: stand-alone ShipBuilder
		+ 2. FS integration
			+ a. Creating ShipBuilder frame changes current OpenGL context
			+ b. After opening ShipBuilder frame, timer still kicks-in
				+ b1. Need a "full pause", not the current one which still updates everything; here's algo:
					+ Freeze:
						+ Prevent OnIdle from running GameIteration
							+ Use mIsGameFrozen
								+ OnMainFrameClose() also calls Freeze() now
						+ Stop (eventual) game timer; Stop (eventual) low-frequency timer
							+ See MainFrame::OnError, which now changes to invoke Freeze()
						+ mGameController->Freeze()
							+ Simply pause clock
						+ mSoundController->Reset()
						+ mMusicController->Reset()
					+ Resuming:
						+ mGameController->Thaw()
							+ Simply resume clock
						+ Restart game timer; Restart low-frequency timer
							+ See MainFrame::OnError, which no changes to invoke Thaw()
						+ Re-allow OnIdle to run GameIteration
							+ Use mIsGameFrozen
					+ Move mSoundController/mMusicController->Reset() out of ResetShipState() (->"ResetShipUIState") and back into other callers of LoadShip()
					+ GameController::Freeze: needs to wait for (eventual) RenderContext render to complete
					+ Invoke both
					+ Test:
						+ Destroy path
						+ ShowError(!die)
						+ ShowError(die)
						+ Switch to builder
			+ c. Make FS context current after SB has been closed
				+ Test first (on Ubuntu) if we may do so simply *outside* of a Paint event, i.e. in FS::MainFrame::SwitchFromShipBuilder, *BEFORE LoadShip*
			+ Test at end:
				+ Windows:
					+ Editing password-protected ship from FS
				+ Ubuntu: 
					+ Entire shebang
					+ Editing password-protected ship from FS
		+ 3: Think if can re-use view (and thus context) across Controller re-create's for NewShip and LoadShip
			+ First test a Release build to see if it's really noticeable - it still is, a bit
			X See if can OpenGL-Display earlier
				+ a: Create view earlier
				X b: Display earlier
					X Background immediately
				X NO, it's ugly - you still see the whole white, and the whole shebang to reduce the time is not worth it
		+ Mark TODO item in this plan for mouse coords change as done
		+ Remove single-threaded boot setting
		+ Re-test w/multi-threading on Windows

+ Fix: after opening editor with mouse on canvas, tool is not initialized
	+ ATM, after Controller cctor, tool needs to exist or not depending on whether the mouse in in the work canvas or not, because at OnMouseEnter we expect to have no tool
		! It used to work because we would Show() *after* Controller, and wxWidgets/MSW would generate an OnEnterWindow()
		+ So add a IUserInterface::IsMouseInWorkCanvas()

+ Re-arc visualizations for alignment: shift game viz, Texture viz, and Mesh shader so that they are aligned
	+ Texture viz
	+ Game viz
		! Facts:
			- Structure pixel at (0, 0):
				- World: (0, 0) [short of half ship width]
				- Texture: (0.5/SW, 0.5/SH)
			- Structure pixel at (W-1, H-1):
				- World: (W-1, H-1) [short of half ship width]
				- Texture: (1.0 - 0.5/SW, 1.0 - 0.5/SH)
			- So, if we plan to just shift output of ShipTexturizer::RenderShipInto to be at center of grid, texture viz must be as follows:
				- Center of ship square at (0, 0) must be (0.5/SW, 0.5/SH)
				- Center of ship square at (W-1, H-1) must be (1.0 - 0.5/SW, 1.0 - 0.5/SH)
				- It seems to be the case
		! Problem: left and bottom texture borders do not appear in game viz
			! Also before
		+ Fix ShipTexturizer::RenderShipInto
			+ New conversions
			+ Deal with width/height = 1
			X Try with nearest
			+ No need to mod at Sample() (assert)
			+ Test:
				+ With texture
					+ Equal size texture
					+ Larger texture
					+ Smaller texture
				+ With auto-texturization
				+ Compare texture with Game's
				+ Compare auto-texturization with Game's
		+ Cleanup sampling functions
	+ Mesh shader
		X See whether just quad shift (at shader) is enough
		+ Rewrite centered
			+ Line thickness needs to be calcd from outside to guarantee at least one pixel
		+ Draw particle rounds 
	+ ShipTexturizer::RenderShipInto: 2-3-4 and 1-3-4 need to cover diagonal
	+ Nail down better defaults for viz modes
	+ Fix ropes alignment
	+ Merge into master & nuke branch
	+ View:.cpp 
		+ Unify/cleanup vertices creation/upload
		+ Call UpdateStructuralLayer only at ViewModel changes, not from Upload
	+ New defaults:
		+ LayerViz: Game
		+ StructuralVizMode: Particle
	+ Shader:
		+ H and V lines: make step band 1.0 wide (now it's 1.1)

+ Frame cctor: see if startup looks better if we setup primary layer already in cttor
	+ If so: shove the following in WorkbenchState:
			+ primary viz
			+ tool
			+ viz modes
			+ grid enabled, opacity
				+ Move both out of View
		+ Has own defaults
		+ Replace OnWorkbenchStateChanged with OnXXXChanged(XXX)
	+ MainFrame cctor: invoke ReconciliateUIWithXXX() for WorkbenchState things
	+ Controller:
		+ cctor: invoke all IUserInterface::OnXXXChanged() for all but WorkbenchState
			+ Also make sure we notify if we change game viz mode
	+ View:
		+ cctor:
			+ Take external settings (prim viz, enableGrid, opacity) in cctor 
			+ Initialize otherVisualizationsOpacity - like all 3
			+ Make sure grid param is taken and used (in effect immediately)
			+ Make sure primary visualization is taken and used (in effect immediately)
	+ MainFrame:
		+ OnStructuralMaterialSelected (from palette): invoke Controller, who invokes IUserInterface
		+ See if ReconciliateUI() is still needed; after all:
			+ MainFrame cctor reconciliates with WorkbenchState
			+ Controller cctor notifies own to IUserInterface
		+ Then: MainFrame::OnXXXChanged: see if they still need to check for Controller
	+ Notif's originating from controller's cctor
		+ OnViewModelChanged
		+ OnShipNameChanged
			+ Requires dirtyness, currently asked to Controller
		+ OnShipSizeChanged
		+ OnLayerPresenceChanged
		+ OnModelDirtyChanged
			+ Requires ship name, currently asked to Controller
		+ OnUndoStackStateChanged
			+ Make it take a stack
	+ Paths coming back: e.g. MainFrame.opacity_slider -> Controller -> IUserInterface -> Reconciliate; make efficient:
		+ Opacity slider
		+ Grid
	+ Test:
		+ Old ReconciliateUI() (called at New and Load) used to invoke mMainPanel->Layout()
		+ Permanence of 3 View settings across Controller re-create's
		+ Permanence of all other settings across Controller re-create's

+ Fix Ubuntu:
	+ Grid button size
	+ Not adding extension to ship name when saving it
	+ Default save directory
	+ Model validation crash
	+ Undo stack is at weird position and covers rest
		+ Note: it's the same as at the and of the SB cctor

+ After changing ShipMetadata's auto-texturization settings, should update Game Viz if it's Auto-Tex
	+ @ Controller::InternalSetShipProperties

+ Localization kickoff
	+ Extract strings
	+ Update all langs
	+ Change copyright year in all langs
	+ Do some Italian
+ Send for testing
+ Send for localization
+ Linux build
	+ Send for testing
+ Bump up version

+ Don't overwrite files from stock Ships directory
	+ Test first it happens
	+ Fix @ MainFrame::DoLoadShip
		+ Path is ResourceLocator::GetInstalledShipFolderPath
		+ Unit tests
	+ Test again
+ Test Titanic's alignments
+ Test on old Dell
+ UIRearc
	+ DO
		+ Move GameViz selector to StructuralLayer
			+ Fix
			+ Fix radio behavior of select button
		+ File "toolbar"
			+ Quit button
		+ Ship "toolbar"
		+ File icons: same size as layer
		+ Ship icons: same size as layer
		+ Do control for button with label in ribbon toolbar
			+ Disable also label
				+ Get colors from parent ribbon in cctor
			+ Cleanup old code
		+ Test ribbon on Ubuntu			
		+ Possible reorg:
			+ Main
				+ File
					+ Use toolbar button
				+ View
					+ Zoom In
					+ Zoom Out
					+ Reset View
			+ Layers
				+ "Edit"
			+ Edit
				+ Undo
					+ Undo
				+ Ship
					+ Auto-Trim
					+ Flip Ship H
					+ Flip Ship V
					+ Size
					+ Properties
				+ Analysis
					+ Use toolbar button
				+ Tool Settings
					+ Split checkboxes into label and checkbox
					+ Fix when tool has no settings
					+ Initial layout is broken
		+ Tool settings to toolbar
		+ All other menu items: move to toolbar
			+ Create accelerator table for most common ones, plus Log Window
				+ Ctrl+N
				+ Ctrl+O
				+ Ctrl+S (Save)
				+ Alt+F4
				+ Ctrl+Z
				+ +
				+ -
				+ Home
				+ Ctrl+L
			+ Fix save:
				- OLD:
					- Save Button, Key: 
						- OnSaveShip
							- PreSaveShipCheck
							- SaveShip
					- SaveAs Button, Key: 
						- OnSaveShipAs
							- PreSaveShipCheck
							- SaveShipAs
					- Close:
						- Dirty && User Wants:
							- SaveShip
					- New:
						- Dirty && UserWants:
							- SaveShip
					- Load:
						- Dirty && UserWants:
							- SaveShip
					- SaveAndSwitchBackToGame:
						- SaveShip()
					- QuitAndSwitchBackToGame:
						- Dirty && User Wants:
							- SaveShip					
					------------------------
					- SaveShip:
						- If no path: SaveShipAs
						- Else: DoSaveShip
					- SaveShipAs:
						- Dialog
						- If OK: DoSaveShip
				+ NEW:
					! Tenet:
						! PreSaveShipValidation is at very bottom, DoSaveShip(filename)
					+ Save Button, Key: SaveShip()
						- DoSaveShipOrSaveShipAsWithValidation()
					+ Save As Button: SaveShipAs()
						- DoSaveShipAsWithValidation()
					+ Close:
						- Dirty && User Wants:
							- DoSaveShipOrSaveShipAsWithValidation()
							- If false: veto
					+ New:
						- Dirty && UserWants:
							- DoSaveShipOrSaveShipAsWithValidation()
							- If false: return
					+ Load:
						- Dirty && UserWants:
							- DoSaveShipOrSaveShipAsWithValidation()
							- If false: return
					+ SaveAndSwitchBackToGame:
						- DoSaveShipOrSaveShipAsWithValidation()
						- If false: return
					+ QuitAndSwitchBackToGame:
						- Dirty && User Wants:
							- DoSaveShipOrSaveShipAsWithValidation()
							- If false: return
					------------------------
					+ DoSaveShipOrSaveShipAsWithValidation() -> bool
						- If has path: return DoSaveShipWithValidation(path)
						- Else: return DoSaveShipAsWithValidation()
					+ DoSaveShipAsWithValidation() -> bool
						- If Precheck OK:
							- Dialog
							- If OK:
								- DoSaveShipWithoutValidation(filename)
								- Return true
							- Else:
								- Return false
						- Else:
							- Return false
					+ DoSaveShipWithValidation(filename) -> bool
						- If Precheck OK:
							- DoSaveShipWithoutValidation(filename)
							- Return true
						- Else:
							- Return false
					+ DoSaveShipWithoutValidation(filename)
						- ...Save...			
			+ Display shortcuts at affected tooltips
				+ Populate accelerator over there, via private helper method
	+ Copy all useful PSDs to Authoring
		+ Nuke useless PSDs from Authoring
	+ Follow-ups
		+ Fixup col0
			+ H margins,col 
			+ Separator(s)
			+ Undo stack width
		+ Layer name @ left panel
		+ Color of labels @ tool settings
		+ Select Main page at Open
		+ Cleanup all TODOs
	+ Test in FloatingSandbox mode
	X See if should Realize() ribbon bar at each page change
	+ Re-test UI on old Dell
	+ Re-test UI on Ubuntu
		+ See if need to change style, see https://imron02.wordpress.com/2014/12/11/wxwidgets-simple-application-using-wxribbon-and-wxauinotebook/
		+ ShipBuilder Auto-Trim:
			+ Bug when also zoom changes afterwards
				+ First off: is the zoom really changing?
			+ Texture seems to be trimmed "wrong"
+ Release

+ Sampler tool (*)

+ SHIFT at pencil tool for H or V
	+ Test:
		+ Structural pencil
		+ Structural eraser
		+ Electrical pencil
		+ Electrical eraser
	+ changes.txt

+ Release

====== 1.17.2

+ Preferences
	+ Completely independent "Preferences" class, does 3 things:
		+ De-serialize
		+ Serve as storage
		+ Serialize
	+ Move UnitsSsytem from ShipBuilder MainFrame's cctor to OpenForXXX()
	+ If specified overrides own storage, else is loaded (and if not loaded, is default)
+ StatusBar (*)
+ Measuring Tape tool (*)
+ New/Set/Remove layers:
	+ New:
		+ Make internal helper templated on LayerType, with all code
			+ Add new templated helper to make undo entry with whole layer
		+ Additions:
			+ Undo
		+ Restore problem: could cause presence to change, hence impacting:
			! Problem descr: restore could cause presence to change, hence impacting:
				! Current tool
					! Changed because primary viz has changed, via InternalSelectPrimaryVisualization() called currently by ::RemoveXYZLayer()
				! Current viz 
					! Via InternalUpdateModelControllerVisualizationModes() called currently by ::RemoveXYZLayer()
			+ Fix:
				+ Wrap operations with private templated WrapLikelyPresenceChangingOperation
					+ Does the above - might only need InternalSelectPrimaryVisualization() though, as that one changes tool
				+ @ Electrical
				+ Test 
				+ If Ok:
					+ Use @ all other Controller::RestoreXYZLayerForUndo()
					+ See if should also do:
						+ InternalReconciliateTextureVisualizationMode()
						+ If so, go again through Controller and remove those calls
					+ Use @ all other layer-presence-changing operations
						+ Also @ NewLayer helper itself
						! And later, @ RemoveLayer, SetLayer helpers
		+ Test (basic; undo):
			+ S
			+ E
			+ R
		+ Cleanup old code
			+ Verify really ok
	+ Remove:
		+ Make internal helper templated on LayerType, with all code
			+ Use WrapLikelyPresenceChangingOperation
			+ Use PushUndoForWholeLayer
		+ Additions:
			+ Undo
				+ Note: texture layer removal should also remember metadata (art credits)
		+ Test (basic; undo):
			+ E
			+ R
			+ T
		+ Cleanup old code
	+ Set:
		+ Make internal helper templated on LayerType, with all code
			+ Use WrapLikelyPresenceChangingOperation
			+ Use PushUndoForWholeLayer
		+ Additions:
			+ Undo
				+ Note: texture layer change should also remember metadata (art credits)
		+ Test (basic; undo):
			+ S
			+ E
			+ R
			+ T
+ Import/Export:
	+ Structural:
		+ Import from:
			+ .png, .shp, .shp2 (load whole and throw away)
			+ Resize
				+ Can move MakeReframed() up to XYZLayerData()?
					+ Structural: just buffer
					+ Electrical: buffer + panel
						+ Do also staticShipRect calc's (intersection of old rect w/ (newOffset, newSize), then shifted to old coords)
						+ Fix panel
					+ Ropes: buffer
					+ Unit tests
				+ Rewrite ModelController::ResizeShip in terms of LayerData::Reframe()
				+ Do resize @ import
			+ Test:
				+ .shp2, password-protected
				+ .shp
				+ .png
				+ Resize larger
				+ Resize smaller
				+ One from Simulator
		+ Export to .png
			+ ShipDeSerializer:
				+ SaveStructuralLayerImage(StructuralLayerData const &, ...)
	+ Electrical:
		+ Import:
			+ .shp, .shp2 (load whole and throw away)
				+ Might as well allow user to select .png's (for simplicity in ShipLoadDialog), will be discared afterwards anyway
			+ Show error if no layer exists in definition
			+ Resize
			+ Test:
				+ .shp2, password-protected
				+ .shp
				+ .png (w/error and w/out error)
				+ Ship with no such layer
				+ Resize larger
				+ Resize smaller
				+ One from Simulator
		! No export (can save .shp2 and import from there)
	+ Ropes:
		+ Import:
			+ .shp, .shp2 (load whole and throw away)
				+ Might as well allow user to select .png's (for simplicity in ShipLoadDialog), will be discared afterwards anyway
			+ Show error if no layer exists in definition
			+ Resize
			+ Test:
				+ .shp2, password-protected
				+ .shp
				+ .png (w/error and w/out error)
				+ Ship with no such layer
				+ Resize larger
				+ Resize smaller
				+ One from Simulator
		+ No export (can save .shp2 and import from there)
	+ Texture:
		+ Import: two separate import buttons
			+ .png
				+ New ImageLoadDialog
				+ Load file and pass to Controller
					+ Resize workflow
						+ For texture
							+ Dialog
							+ Resize image								
								+ Buffer2D::Reframe								
									+ See broken Y
							+ Controller::SetTextureLayer
								+ Undo
									+ Rearc: ModelController:
										+ Dirty region to *update* and *upload*, one for each viz
											+ Array member
											+ Updated each time we currently invoke UpdateXXXViz
											+ Also updated at New/Set/Remove/Restore layer
										+ UpdateXXXViz(): they are all private, invoked *only* by single public UpdateVisualizations
										+ ModelController::UpdateVisualizations(View)
											+ Invokes all individual UpdateXXXViz()
											+ Then uploads/removes from view
										+ Controller: invoke UpdateVisualizations(View) at:
											+ New
											+ Set
											+ Restore
											+ Flip
											+ Edits (tools)
										+ Test:
											+ Flood tool
											+ Line tool
											+ Pencil tool
						+ For resize
							+ Dialog
								+ Dimensions lock button
								+ When changing target size, need to honor anchor
									+ Hence need to store anchor coords, rather than just offset, and calc offset at each OnChange
									+ And if we store anchor coords, what do we do with mouse move?
										+ Reset anchor coords
										+ Should also communicate to dialog to reset anchor controls
									+ Impl:
										+ OnCustomOffset: invoke when mouse move
											+ Dialog reactor: toggle all buttons off (via OnAnchor)
										+ AnchorCoords:
											+ Calc coords at OnChange iff mAnchorCoords.HasValue()
								+ Fix the problem with super zoom
								+ Capture mouse
							+ Controller::ResizeShip
								+ ModelController::ResizeShip
									+ Do all layers like Flip()
										+ Structural
										+ Electrical
										+ Ropes
										+ Texture
											+ Calc image size
											+ FIX: also sizes of visualizations have to change
												+ What if we alloc textures at MC::UpdateVisualizations() rather than at MC::SetXXXVizMode?
												+ And then at MC::ResizeShip() we simply nuke textures
										+ Test completely empty afterwards, all layers
										+ Test actual resize
									+ Electrical: remove panel elements that are gone
								+ Undo
									+ Instead of executing undo via 4 calls to Controller::RestoreXXXLayerForUndo, do one single call to
									  new Controller::RestoreAllLayersForUndo
			+ .shp, .shp2 (load whole and throw away)
					+ Might as well allow user to select also .png's (for simplicity in ShipLoadDialog), will be discarded (errored) afterwards anyway - see next line
				+ Show error if no layer exists in definition
				! No need to resize
				+ Test:
					+ .shp2, password-protected
					+ .shp
					+ .png (expect error)
					+ Ship with no such layer
					+ One from Simulator
				+ With import, also replace art credits
					+ Empty if from image, from imported ship otherwise (even if empty)
		+ Export to .png (though quite useless at this moment)
			+ Ad-hoc code using ImageFileTools
	+ Notes:
		+ Any import from .shp2 requires password
		+ All imports push an undo (via Controller::SetXYZLayer())
+ Preferences: load directories
+ Send for testing

+ Waterline analysis
	! https://www.britannica.com/science/fluid-mechanics/Hydrostatics#ref611691
	! https://www.engineeringtoolbox.com/centre-gravity-buoyancy-d_1286.html
	! Gist:
		- At equlibrium the hull is stable, hence the center of gravity and center of buoyancy are on the same vertical line
			- For most hulls the center of buoyancy is below the center of gravity and the hull is said to be meta-stable
		- Metacenter is the theoretical point at which the B-G vertical line intersects the vertical line through the new centre of buoyancy created when the body is tilted
		- When at rest on even keel, the vessels centre of buoyancy is directly below the centre of gravity as well as below the metacentre
	+ Impl:
		+ Button at ribbon, under Analysis
			+ Icon
			+ Shorter label
		+ View:
			+ UploadWaterlineMarker
			+ UploadWaterline
		+ ShipBuilder/UI/WaterlineAnalyzerDialog
			+ Icons x 3
			+ Buttons x 3
			+ DoStep: visualize analysis results
				+ Static analysis
					+ Have also label when no particles, need to differentiate between static-analysis-not-yet-run and run-but-no-particles
		+ class WaterlineAnalyzer
			X No float coords - simulator is integral for buoyancy after all
			+ Order of privates: move the old "published" ones to search state
				+ They are just state observables
			+ Do level check w/delta from previous
			+ Direction search
				+ Inline
				+ Do check with alignment of new dir with vertical
				+ Find next dir
					X Do half of the rotation
					+ Rather than having rotation's magnitude be based on CoM-CoB angle magnitude, do directional search with small, fixed-size rotations, depending simply
					  on orientation (left or right) of CoM-CoB wrt "vertical"
						+ If CoM-CoB is to the right of "vertical": rotate direction by negative step
						+ Else, rotate direction by positive step
						+ Cap by CoM-CoB ^ direction angle
					+ Problem: can dance back and forth - oscillates around minimum
						+ Make rotation dependent on torque
					+ Problem 2: direction search end condition: at the moment ignores distance between CoM and CoB; but when they're really 
					  on each other, direction change should be negligible. Find another metric for the end condition
						+ Torque (again)
					! Facts:
						! Ark: at equlibrium, right side is slightly lower
						! At: -3.52; step is -3.63, hence we go for other side, and get -3.41; but "other side" is wrong
							- Matches observation with torque-based direction method: in that case we go from -3.52 to -3.63, so it's not really about minimizing
					+ 1: binsearch: make it with fixed-size steps - only bin when changing direction
					+ 2: direction search: use the fact that a change in torque sign indicates passed a minimum
					+ Cleanup
					+ Larger direction search stride
					+ Test corner cases:
						+ Submarine
						+ ~180degrees ball
						+ Cardboard skyscraper
							+ Remove buoyancy center if buoyant force is zero
	+ Finalizations:
		+ See if can get rid of state machine in WaterlineAnalyzer and do all with state instead
		+ Fix Blimp break
			+ Due to levelSearchCurrent not being correct anymore after rotation of direction; need to update it as well
		+ Cap rotation due to torque
		+ Outcome in dialog (populated at completion)
			+ Trim (angle as absolute degrees)
			+ Floating/Sinking statement
			+ Test:
				+ Submarine, Triton, Ship
				+ Blimp, Cardboard
				+ Concrete ball
				+ No particles
				+ One particle
			+ Dialog: Gfx
				+ Outcome control
					+ Double-check heading by testing with a slightly tilting ship
					+ Top arrow in image
					+ Vertical dashed line as a guide
				+ Replace static analysis text with "Trim" and "Floats" labels, with colored backgrounds
		+ Faster animation
		+ Cleanup logging
		+ Analysis starts in continuous play
	+ Jumpstart waterline analyzer when sinking
		+ Dir = normal to M->B
		+ Test with Colored Kursks

+ UI: total mass and center of mass
	+ ModelController maintains structural analysis, like now
		+ Structural analysis: total mass, sum of CoM
	+ ModelController has "OnAnalysisUpdated" callback, goes straight to IUserInterface
	+ Display:
		+ Total mass (in StatusBar)
		+ Center of Mass (toggled via toolbar)
			+ Enabling/disabling CoM view
				+ MainFrame UI
				+ MacroProperties: center of mass must be optional (nullopt when no particles)
				+ Via Controller
					+ When enabled: asks ModelController and uploads to View
					+ When disabled: removes from View - assuming we're the only ones (Waterline dialog may not be open)
			+ Implement analysis via count of "mass" particles
				+ So to zero out total mass when zero
				+ Also can assert, nice
			+ Controller/Tool rearc
				+ Tool: take Controller and nothing of others
				+ PencilTool
					+ Implement LayerModificationEpilog in Controller
					+ Controller: expose remaining members for tools to use
				+ Other tools
				+ Nuke ModelController callback for macro-properties
					+ Move one-by-one to Controller (cctor, editing primitives, undo, etc.)
				+ Test:
					+ All tools
			+ Callback: 
				+ On top of calling IUserInterface, also inspect whether CoM viz is enabled and talk to view depending on that
			+ Interaction with WaterlineAnalyzer
				+ Needs to remember if it's the one that uploaded marker (which he does only if ! enabled) and undo @ destructor based on that memory
					+ See if still need View::RemoveAllMarkers afterwards
	+ See if can piggyback on MacroProperties in WaterlineAnalyzer, rather than calculating them again

+ Decide whether we still want Controller to both expose Model and wrappers for it
	+ Philosophy:
		+ Controller does not expose getters, but exposes ModelController const & for observers
			+ Ideally Controller does not expose Model directly, only ModelController wrappers - so it can enforce eph viz checks, like we do now in CloneExistingLayer()
		+ ModelController does not expose Model, and completely wraps Model

+ Fix auto zoom

+ Use epilog also at Controller itself

+ Merge Preferences into Workbench
	+ Nuke Preferences
	+ Use NewShipSize at Controller
	+ Test 
		+ Creates json
		+ Loads json

+ Make mipmap for markers
	+ Rename folders and groups
		+ Clean build/data folders
	+ Redo icons
		+ 64x128
		+ Fix anchor
	+ View: upload mipmapped

+ See why we weren't asked to rename 3 balls after chaning name in metadata
	+ Because it was .shp?

+ Perf:
	+ Do perf analysis of long diagonal line
		+ ShipBuilder::ModelController::UpdateVisualizations	6489 (95.24%)
			+ ShipBuilder::ModelController::UpdateGameVisualization	3841 (65.67%)
				+ RenderShipInto: 33
				+ AutoTextureInto: 32
			+ ShipBuilder::View::UploadGameVisualization	2600 (28.95%)
	X Try using glTexSubImage2D at View::UploadGameVisualization
	X Test with huge size: lag should only be proportional to edit region

+ Rotate 90 (CW and CCW) (full ship)
	+ Ribbon, "Edit"
		+ 2 icons
	+ Buffer2D
		+ Unit tests
		+ Redo, using Coords.Rotate(direction, size)
	+ RopeBuffer
		+ In-place
		+ Unit tests
	+ Controller->ModelController
		+ Also changes ship size, so do notifications
	+ Test:
		+ Structural
		+ Electrical
		+ Ropes
		+ Texture
		+ Undo
		+ Ship size notif at rotate
		+ Ship size notif at undo
		+ CoM

+ ShipNameNormalizer
	+ Use at:
		+ NewShipNameDialog
		+ ShipPropertiesEditDialog (only when name is dirty)
		+ Messages:
			+ "It seems that a better name for this ship might be:"
			+ "Yes, I want to use the suggested name"
			+ "No, I want to keep my name"

+ Ask user for new ship name
	+ @ FS->SB via New Ship
	+ @ SB open
	+ @ SB::NewShip

+ Send for testing

+ Electrical panel authoring
	+ ModelController: need to export <InstanceID, ElectricalMaterial *> pairs
		+ InstancedElectricalElementSet:
			+ Add/Remove (w/generation of instance ID)
			+ Getters
	+ Ribbon button
		+ Icon
		+ Only enabled iff (model has ElectricalLayer &&) ElectricalLayer has one instanced element
	+ Dialog
		+ Open() takes InstancedElectricalElementSet and ElectricalPanelMetadata
		+ List: cols are:
			+ Label: <instance ID> <material name>
			+ Checkbox (for visibility)
			+ Label
				+ Move code that makes labels given instance index and ElectricalMaterial at ElectricalMaterial
					+ Then would need electrical material at announcement events that SwitchboardPanel currently creates labels in
		+ LayoutHelper: deal with repeated layout coords
		+ ElectricalPanelLayoutControl
			+ Make wxScrolled, and resize internals to virtual size
				+ Min size still is own size though (GetSize() at time of need)
			+ Crystallize element DcRect calculations in RecalculateGeometry()
				+ Invoked by: OnResized, SetPanel
			+ List auto-scroll
				+ SetPanel should also take "master list" (element set)
			+ Fix H scrolling
			+ Actual element drawing
				+ Image
					+ Find new image
				+ Instance index
				+ Shadow
			+ Visibility changes
				+ Dialog: when making something visible: check if layout coords conflict with another visible one; if so, zero out
			+ Mouse workflow
				+ Mouse capture
				+ Movable element drawn last
				+ Drop candidate green
				+ Drop (set / swap)
			+ Vertical guide at x=0
			+ Rewrite:
				+ ClientToVirtual(wxPoint) -> wxPoint
				+ MakeSlotVirtualRect
				+ Replace mElements with ElectricalPanelMetadata&
				+ Add map: LayoutCoords -> LayoutElement:
					+ opt<InstanceIndex>
					+ wxRect SlotVirtualRect
			+ Can now assume that electrical panel always contains elements	
		+ List: reorder cols:
			+ Instance ID, label, "(material name)", visibility
		+ Replace visibility checkbox with wxBitmapToggleButton with eye/crossed eye icon
		+ Try shadow with bitmap
		+ Hook events between List and ElectricalPanelLayoutControl:
			+ Click on list element -> highlight in LayoutControl (and list element)
			+ Click on LayoutControl -> highlight in list element (and list element, and scroll to it)
		+ Max length for label
		+ Final population of ElectricalPanel and delivery to Controller
			+ ElectricalPanelLayoutControl: takes ElectricalPanel& from outside and populates directly
			+ Dialog: populate only if dirty
		+ ModelController: WriteParticle(electrical): take care of panel
	+ Tests:
		+ Saved and reloaded matches
		+ Matching and functional in game
		+ Restore
		+ Saved after restore and reloaded matches
		+ Deletion of instanced elements
		+ Addition of instanced elements
		+ Buffer restore when panel has more elements before restore

+ Eraser electrical: setting for size
+ Redo icon for CoM using new marker
+ Crash @ new/load ship when current tool in Workbenchstate is for layer not present in new one

+ Sampled material rearc:
	! Spec:
		! Motivation: these two once-separate work items:
			- Sampler tool: also provide instance index
			- Normal flood tool: also display underneath material to StatusBar
		! Sampling is of both material and instance index
			- Multiple tools do it
				- So StatusBar needs to have separate section for measuring tool, and sampled material is not anymore mutex with measurement
		! Tools need to update sampled material after each edit
	+ Impl:
		+ ShipBuilder: SampledInformation
			+ string, opt<instance ID>
		+ IUserInterface: OnToolCoords+OnSampled -> "OnSampledInformationUpdated"(SampledInformation)
		+ StatusBar: 
			+ Move material "area" next to coordinates "area", including its icon
				+ Detach sampled material from "tool output"
			+ Do ID
		+ Controller::BroadcastSampledInformationUpdated(mouse coords)
		+ Invoke at each tool that's worth doing it
			! Via new Controller::BroadcastSampledInformationUpdated(mouse coords)
				- At cctor
				- At destructor
				- At mouse move
					- Must include result of edit
			+ Sampler
			+ Pencil/Eraser S/E
			+ Flood S
				+ Do clone "futurework"
					+ Buffer2D::Trim, including unit tests
					+ Layers::Trim, including unit tests
						+ Structural layer
						+ Electrical layer
							+ Do trim panel at all places
								+ Verify at existing unit tests
						+ Ropes layer					
				+ Test ropebuffer trim (via ship resize)
			+ Line S/E
			+ Rope pencil
			+ Rope eraser
		+ Who's doing it at left up (edit end)?
			! Left up generates mouse move, seems @ Windows
			+ Do it yourself, after each edit - ideally @ DoEdit itself (and remove redundant's after DoEdit invocation)
				+ Pencil/Eraser S/E
				+ Flood S
				+ Line S/E
				+ Rope pencil
				+ Rope eraser	

+ Pencil: shift-lock with right-button material
	! Due to focus not being on canvas at shift down
	+ Remove logs

+ Merge into 1.17.1.next

====== 1.17.3

+ See if can make MaterialsPalette close only when mouse is *clicked* outside, not just when it's *moved* outside
	X Option 1: derive from wxPopupWindow - replace Dismiss with Hide()
	+ Option 2: OnWorkCanvasMouseEnteredWindow: do not catch focus if palette is open
	+ changelist

+ "Backup Ship" - like SaveAs, but does not change current
	+ Ribbon button
		+ Enabled only if the ship is "currently saved" (i.e. loaded or saved)
	+ Requires ShipLoadDialog to show filename (incl. extension)
	+ Action:
		+ Appends "_backup" to filename (also if it has it already)
		+ Saves
			+ Make a static version of DoSaveShipWithoutValidation ("DoSaveShip(...)")
		+ Does *not* ask when overrides
		+ Shows dialog afterwards saying "Ship file has been backed up as "....""
			+ Check out wxNotificationMessage
	+ changelist

+ Preferences dialog (to/from WorkbenchState):
	+ Impl:
		+ WorkbenchState gets CanvasBackgroundColor
			+ Move defaults here (255, 255, 255)
			+ Both CanvasBackgroundColor and NewShipSize are loaded and saved
		+ Dialog:
			+ ::Open() gets both Controller and WorkbenchState
				+ Stores current bg color in session
				+ Session only takes Controller, WorkbenchState given to ReconciliateUI
			+ UI:
				+ New ship size
				+ Canvas background color
					+ Swap custom with predefined, and remove "Custom" label
					+ Changes to bg color are reflected immediately, going to Controller
					+ Reconciliate: set into custom color
			+ OnOk: just store new ship size (taking it from UI)
			+ OnCancel: revert bg color to old saved in session
		+ Controller:
			+ Setter for color (which talks to WorkbenchState and View) and for ship size (which just talks to WorkbenchState)
		+ Shader parameter
			+ In shader
			+ Set in view at init'n (and taken as arg) and at change
	+ Tests:
		+ Cancel
		+ Close
		+ Save/load preferences
		+ All overlays: should show bg color

+ Texture flood tool ("Magic Wand Eraser")
	+ First off: mouse coordinates from MainFrame to Controller becomes LogicalDisplayCoords, and they're converted to ShipSpace coords where needed
	+ Conversion to texture coords: done by View & ViewModel, exactly like conversion to ShipSpaceCoords, and invoked by texture tool(s)
		+ ViewModel also stores texture layer size (as opt<ImageSize> mTextureLayerVisualizationTextureSize), next to ShipSize, via new Set/RemoveTextureLayerVisualizationTextureSize
		  invoked by View at UploadTexture
			+ ScreenToTextureSpace: assert we have mTextureLayerVisualizationTextureSize
		+ ScreenToTextureSpace
		+ Test:
			+ All four corners
	+ Icon: magic wand
	+ Cursor: magic wand
	+ Tool settings:
		+ TextureMagicWandTolerance: 0-100 unsigned int
		+ TextureMagicWandTolerance Anti-alias: bool
		+ TextureMagicWandTolerance Contiguous: bool
		+ At:
			+ WorkbenchState
			+ UI
	+ Tool:
		+ If mouse coords in range, do:
			+ Save undo
			+ Invoke ModelController::TextureMagicWandEraseBackground(...)
			+ If affected => push Undo
		+ Allow upload of only a region of texture
			+ Separate dirty region registrations
			+ View::Upload
			+ Tests:
				+ This tool: changes are uploaded
				+ Trim/Flip
				+ Resize
		+ ModelController::TextureMagicWandEraseBackground:
			! Flood notes:
				! Photoshop:
					! Magic background eraser on uniform red, tolerance 0%:
						! When alpha is not zero (but still very small), erasing from it erases all - even at tolerance zero
						! When alpha is zero, erasing from it erases nothing
						! Anti-aliasing:
							! Regardless of angle and number of neighboring pixels, alpha of neighbor goes from 1.0 to a fraction of what it was - even
							  for pixels touching only on corners
								- Twice-aliased (at different times) distant neighbor is more transparent than once-aliased one
							! Erasing from inside is different than erasing from outside (first alpha higher than second); it's because the 
							  more the number of pixels removed, the more the alpha is lowered
					! Unrelated info:
						! Magic BG eraser:
							! Once erased (with opacity 100%), re-clicking on original pixel (now empty) does not erase anything anymore, even after changing tolerance
								! With opacity < 100%, re-clicking on original pixel (now half-empty) makes erasing more pronounced, over and over
						! Eraser:
							! When erased with *block*, the original color has been forgotten - an erased red and an erased blue are considered identical
								! The sampler tool in fact doesn't pick up anything
							! When erased with *brush*, even when a lot, the original color still seems to apply
								! The sampler tool in fact picks up the original color
			+ For each new pixel, first check its alpha:
				+ If small (below threshold): follow
				+ Else: check color

+ Texture eraser tool
	+ MainFrame:
		+ Tool "toolbar"
		+ Tool settings - exactly like other eraser tool
	+ Make ViewModel::DisplayToTexture NOT return opt, as display space point is guaranteed to be in ship canvas (if caller checks)
		+ Caller needs to ensure display coords are in Work Canvas
		+ Test with magic eraser on single pixel/hack it to draw pixel
	+ Use new ModelController::GetTextureSize() whenever we need texture size
	+ ModelController::TextureRegionErase(ImageRect)
	+ ModelController::TextureRegionEraseForEphemeralViz
		+ And its own Restore, and ephemeral viz infrastructure for texture
			+ And re-instate old assert(s) that we have removed from other texture methods
	+ Tool itself
		+ Paradigm: we always get display mouse coords, and CalculateApplicableRect does the -> texture transformation, with in-texture intersection
		+ See then if GetMouseCoordinatesInTextureSpaceIfInTexture is still needed
	+ View::RectOverlay method in texture layer space
		! We store vertices in fractional ship space, reusing VBO and shader
		+ Duplicate all RectOverlay methods in two: ...ShipSpace and ...TextureLayerSpace
			+ They store in one of two new rect members: ...ShipSpace and ...TextureLayerSpace
		+ One UpdateRectOverlay()
			+ Assuming only one rect will be active at a time, it checks which one is active and does the corresponding tranx to fractional ship space
				+ assert only one at a time
			+ New one uses new ViewModel::TextureLayerSpaceToFractionalShipSpace
			+ They are both populated into same VBO obviously
		+ Fix 1-pixel width
	+ Test:
		+ Eraser quad intersection with texture
		+ Shift lock
		+ Dialog modal/close
		
+ changelist: both tools, "Added texture editing tools"
