=================================================
Current perf:
=================================================
1.14
- After forces rearc and iterations=30: FPS=30.16, Ums=22.5
- Call tree (45 sec game play, w/out PostInitialize):
	- MainFrame::OnGameTimerTrigger: 90.91%
		- World::UpdateAndRender: 87.23%
			- Ship::Update: 62.09%
				- Ship::UpdateMechanicalDynamics: 52.50%
					- ApplySpringForces: 39.15%
					- HandleCollisionsWithSeaFloor: 6.73%
					- IntegrateAndResetSpringForces: 5.57%
					- ApplyWorldForces: 0.40%
					- UpdateMasses: 0.33%
				- Ship::UpdateWaterDynamics: 6.91%
				- Ship::UpdateHeatDynamics: 1.68%
				- Ship::UpdateForStrains: 0.81%
				- Ship::DiffuseLight: 0.23%
				- Ship::TrimWorldBounds: 0.15%
			- Ship::Render: 20.16%
			- RenderContext::RenderOcean: 1.54%
			- RenderContext::RenderStars: 1.19%
			- OceanSurface::Update: 0.24%
			- Wind::Update: 0.07%
		- wxGLCanvas::SwapBuffers: 1.42%
=================================================
1.13
- After DiffuseLight rearc: FPS=29.5, U/R=19
=================================================
1.12
- fps: 29.1/29.5/30.1
- UR: 221/227
=================================================
- fps: 29.2/29.4 (Samsung w/Krafting: 17.0) 
- UR: 210/220 (Samsung w/Krafting: 690%)
- GameController::InternalUpdate: 62.0%
	- World::Update: 61.98%
		- Ship::Update: 60.92%
			- Ship::UpdateMechanicalDynamics: 49.92%
				- Ship::UpdateSpringForces: 36.50%
				- Ship::UpdatePointForces: 5.95%
				- Ship::HandleCollisionsWithSeaFloor: 3.63%
				- Ship::IntegrateAndResetPointForces: 3.59%
				- Ship::UpdateTotalMasses: 0.24%
			- Ship::UpdateWaterDynamics: 6.81%
			- Ship::DiffuseLight: 2.99%
			- Springs::UpdateStrains: 1.02%
		- OceanSurface::GenerateSamples: 0.74%
		- OceanSurface::Update: 0.24%
- GameController::InternalRender: 22.7%
	- Ship::Render: 19.30%
	- RenderSkyEnd: 2.16%
	- RenderOcean: 0.58%
=================================================
Before SWE:
- fps: 30.8
- UR: 224
=================================================
Before ocean/land rearc:
- fps: 30.5/30.5/30.7/30.85
=================================================
Before decay:
- fps: 30.7/30.7/30.8/30.9/32.0
- U/R: 193.x%
- RunGameIteration: TODO:86.62% (initialization time)
- World::Update: 60.25%
		- UpdateMechanicalDynamics: 49.32%
			- UpdateSpringForces: 37.99%
			- UpdatePointForces: 5.51%
			- HandleCollisionsWithSeafFloor: 3.38%
			- IntegrateAndResetPointForces: 2.30%
			- UpdateTotalMasses: 0.13%
		- UpdateWaterDynamics: 6.72%
			- UpdateWaterVelocities: 6.57%
			- UpdateWaterInflow: 0.08%
		- DiffuseLight: 2.94%
			- FastPow2: 1.44%
- World::Render: 22.54%
	- Ship::Render: 19.36%
	- RenderSkyEnd: 2.33%
	- RenderOcean: 0.70%
=================================================
Before Vertex Attribute Optimization:
- fps: 28.2/28.4 (miracle: 28.7/29.0/29.1)
- World::Update: 54.66%
		- UpdateMechanicalDynamics: 44.64%
			- UpdateSpringForces: 34.70%
			- UpdatePointForces: 4.88%
			- HandleCollisionsWithSeafFloor: 2.89%
			- IntegrateAndResetPointForces: 1.99%
			- UpdateTotalMasses: 0.15%
		- UpdateWaterDynamics: 6.29%
		- DiffuseLight: 2.62%
- World::Render: 28.24%
	- Ship::Render: 25.11%
	- RenderSkyEnd: 2.23%
	- RenderOcean: 0.77%
=================================================
Before VAO:
- fps: 28.1/28.3
=================================================
Before bound world and point light<->ambient light additiveness:
- fps: 29.0/29.2/29.4
=================================================
Before Z buffer:
- fps: 30.2/30.6/31.2
=================================================
Before wind:
- fps: 30.8/31.0/31.3
=================================================
Before exp optimization:
- fps: 30.8/31.0/31.3
- World::Update: 58.48%
		- UpdateMechanicalDynamics: 48.44%
			- UpdateSpringForces: 38.25%
			- UpdatePointForces: 4.47%
			- HandleCollisionsWithSeafFloor: 3.43%
			- IntegrateAndResetPointForces: 2.10%
			- UpdateTotalMasses: 0.19%
		- UpdateWaterDynamics: 7.79%
			- UpdateWaterVelocities: 7.64%
		- DiffuseLight: 1.31%
- World::Render: 28.15%
	- RenderContext::RenderCloudsEnd: 3.98%
=================================================
Before diffusion improvement:
- fps: 31.5/31.7
=================================================
Current perf (spring optimization + double spring iterations)
=================================================
- fps: 31.3 (Samsung: 20.3 (Krafting)) (Mattia's: 15.5 (Krafting))
- World::Update: 57.05%
	- Ship::Update: 56.89%
		- UpdateMechanicalDynamics: 47.56%
			- UpdateSpringForces: 37.08%
			- UpdatePointForces: 5.30%
			- HandleCollisionsWithSeafFloor: 2.92%
			- IntegrateAndResetPointForces: 2.26%
		- UpdateWaterDynamics: 7.83%
			- UpdateWaterVelocities: 7.72%
- World::Render: 28.15%
	- RenderContext::RenderCloudsEnd: 3.98%

=================================================
Past perf (ephemeral particles)
=================================================
- fps: 28.8/29.0
=================================================
1.7.0 perf from users
	- Titanic: 50
	- Titanic: 55
	- Titanic: 48.3

=================================================
1.6.0 perf
=================================================
- fps: 29.6 (Samsung: TBD:31.5 (Krafting)) (Mattia's: TBD:25.1 (Krafting))
- GameController::Update: 35.06%
	- Ship::Update: 34.33%
		- UpdateMechanicalDynamics: 25.70%
			- UpdateSpringForces: 18.80%
			- UpdatePointForces: 3.45%
			- HandleCollisionsWithSeafloor: 2.45%
			- IntegratePointForces: 1.00%
		- UpdateWaterDynamics: 7.83%
			- UpdateWaterVelocities: 7.73%
			- UpdateWaterInflow: 0.05%
		- UpdateStrains: 0.78%
	- DiffuseLight: 0.58%
	- WaterSurface::Update: 0.11%
- World::Render: 57.00%
	- ShipRenderContext::RenderEnd: 52.87%
	- RenderContext::RenderCloudsEnd: 1.49%
	- RenderContext::RenderStart: 0.50%
	- Ship::Render: 0.14%
		- UploadPoints: 0.12%
	- RenderContext::RenderWater: 0.05%
	- World::RenderClouds: 0.04%
		- fmodf: 0.02%
	- RenderContext::RenderLand: 0.01%
- RenderContext::RenderEnd: 0.35%
	- TextRenderContext::RenderEnd: 0.35%
- wxGLCanvas::SwapBuffers: 1.07%
=================================================
NoInline
- World::Render: 53.36%
	- ShipRenderContext::RenderEnd: 49.69%
		- ig4: 49.22%
		- RenderRopes: 0.43%
		- ...
	- RenderContext::RenderCloudsEnd: 1.37%
	- RenderContext::RenderStart: 0.46%
	- RenderContext::RenderWater: 0.04%
	- World::RenderClouds: 0.02%
		- fmodf: 0.01%
	- Ship::Render (with uploads): 0.15%
	- RenderContext::RenderLand: 0.01%
	- RenderContext::UploadLandAndWaterEnd: 0.04%
	- RenderContext::UploadLandAndWater: 0.03%
- RenderContext::RenderEnd: 0.30%
=================================================
Render:
	- No Ship::RenderEnd: 64fps
	- Only springs: 30fps
	- Only triangles: 42fps
=================================================
1.3.0 perf
=================================================
- fps: 27.3
- GameController::DoStep: 33.06%
	- Ship::Update: 32.07%
		- UpdateDynamics: 25.53%
			- UpdateSpringForces: 18.72%
			- UpdatePointForces: 3.55%
			- HandleCollisionsWithSeafloor: 2.27%
			- Integrate: 0.98%
		- GravitateWater: 4.60%
		- BalancePressure: 1.06%
		- UpdateStrains: 0.83%
		- LeakWater: 0.03%
	- DiffuseLight: 0.89%
	- WaterSurface::Update: 0.09%
		- sinf: 0.07%
- MainFrame::RenderGame: 60.47%
	- ShipRenderContext::Render: 53.52% (Incl) 0.00% (Excl)
		- ShipRenderContext::RenderSprings: 30.72%
		- ShipRenderContext::RenderTriangles: 22.29%
		- ShipRenderContext::RenderRopes: 0.45%
		- Points::Upload: 0.14%
	- RenderContext::RenderCloudsEnd: 2.87%

====================================================
====================================================
====================== Plan ========================
====================================================
====================================================

- Testers:
	- Maximord - "Maximord" (Parallels)
	- Pac0master - "<Same as now>" (Intel core i5-8600K 6 cores, NVIDIA GeForce RTX 2070)
	- The_SamminAter - "The_SamminAter" (Parallels)
	- Costin88boss: Windows 10, AMD, ATI OpenGL 4.6 w/Radeon RX 560 Series w/2GB RAM

- Marketing:
	- www.floatingsandbox.com:
		- Try to change white BG to another color
	- After 1.14 is out: 
		- Add new screenshots to:
			- www.floatingsandbox.com 
			- GameJolt

- Roadmap:

	= 1.14.0
		+ Branch
		+ Bump up version
		+ Ships:
			+ Cyclops from Bluefox
			+ Alex02
				+ About box: "Alex di Roma", No URL
		+ RenderContext: nuke current texture before loading new Ocean/Land texture, so to save memory
		+ Randomize flames' wind bend with personality seed
		+ New explosions:
			+ Shader:
				+ Take frames out of 4K video
				+ Make 16 textures
					+ Resize frames (512x512)
						+ See if should discard a lot of useless external padding
					+ Make frames transparent: https://graphicdesign.stackexchange.com/questions/4056/replace-black-background-with-a-transparent-background					
				+ Cross-linear alpha between two textures
				+ Shader
			+ Atlas:
				+ RegularAtlas builder method (no optim's, all same size (but not necessarily square))
				+ Unit tests
			+ RenderContext:
				+ Make atlas and pass to ShipRenderContext
			+ ShipRenderContext:
				+ New VBO, VAO, etc.
					+ Copy from generic textures
					+ Same plane as fire, but will have deterministic deep sort: fire drawn first, explosion next
				+ Revert to no start/end
					+ Clear at RenderStart()
					+ Upload at RenderExplosions()
				+ New Explosion upload
					+ Args:
						+ vec2 centerPosition
						+ float halfQuadSize // of quad side
						+ float progress
						+ float personalitySeed
							+ Used for rotation, calc'd at ShipRenderContext::UploadXYZ(.)
				+ New render step
			+ Do initial testing by temporarily replacing Bomb's Upload() with new explosion upload
			+ Commit
			+ Make infrastructure for multiple explosions:
				+ Single shader, single atlas
					+ Atlas name: "explosions"
					+ Texture group name: "explosions"
			+ Ship: needs own state machine for explosions
				+ Does: rendering; creation of each frame's force field;
					+ i.e. has Update() and Upload()
					+ State is simulation-time based, as it's inherently physical
						! And after all, the current bomb explosions do a fixed number of steps at 20ms intervals,
						  hence they are basically frame-based
				+ Replaces normal bombs' blast callback: DoBombExplosion -> StartBombExplosion
					+ Start IShipStructureHandler while you're at it
					+ Fixed blast position (verify with the various bombs that it's fixed - should not move in fact)
				+ Mechanics update:
					+ 1) go through state machines, insert force fields
					+ 2) ...apply force fields...
					! 3) update bombs& combustion -> trigger explosions
						! Will come at next frame, like now
				+ Expires when progress reaches max lifetime parameter (float seconds)
				+ StateMachine update:
					+ Nail down blast
						+ See if need to force last blast (capped @ blastradius)
					+ Make gfx explosion size match blast radius
						+ Adjust gfx size at ShipRenderContext, if needed
					+ Nail down duration
			+ Cleanup bombs: (verify all call the same Ship::DoBombExplosion(.))
				+ No bomb does anymore Explosion state machine - they all expire at detonation,
				  after sending Explosion to ship
				+ Only explosions are in simulationTime, rest is still wallClockTime
				+ Do at:
					+ Impact Bomb
					+ Timer
				+ Remove DoBombExplosion from IShipStructureHandler
			+ Explosion physics: smoother, points entering radius at last get too much force
			+ Gfx improvements:
				+ Test temporarily w/very slow progress and make sure all frames are shown
				+ See if scaling should go or remain
				+ Need mipmapped atlas? Test w/zoom
				+ Fix two issues:
					+ Frame -1 is visible:
						+ Try with clamping to dead center
					+ Dark rectangles
				+ Frames
					+ Test without curves at frames (i.e. making them darker)
					+ Do other explosions
						+ Make sure may call new texture files "explosion2_..." and have them still matched by TextureDatabase
						+ RegularAtlas: need to live with incomplete power of two
							+ Fill-in with first frame
						+ Explosion 2
							+ [49, 60] (12), 62, 64, 66, 68
						+ Explosion 3
							+ Make psd
						+ Explosion 4
							+ [121, 130] (10), 133, 137, 140, 144, 147, 151
							+ Try without any mask boosting
							+ Then, try with center alpha brushed towards 1.0
							+ Reboost center
							+ Double-check final fade out
						+ Shader texture coords dead center: 
							+ Make dead center at upload
						+ Speedup alpha pre-multiply
						+ Shader: take explosion index as input
							+ ShipRenderContext::UploadExplosion:
								+ For test, set index to one
								+ Then, takes ExplosionType as arg
									+ Deflagration: randomly choose between 0 and 2
									+ Swap explosions 3 and 4
							+ Struct, VAO
							+ Shader
			+ Cleanup:
				+ Complete IShipPhysicsHandler
					+ Move "structure handlers" into it
					+ Register IShipPhysicsHandler with each container
						+ Test all
					+ See if may move "Ship repaired" from repair interaction into both spring/triangle
					  restore handler
				+ Nuke old explosion textures
				+ Nuke GameTypes' texture groups for RC and Timer bomb explosions
				+ Bake atlas:
					+ Rearc textures:
						! There's a json for each TextureDatabase
						+ The json is 1:1 with an enum (and its traits for str<->enum):
							+ Enums are in GameTypes
							+ Traits are in Game/RenderCore
							+ CloudTextureGroups
								+ Cloud
							+ Land,OceanTextureGroups
								+ Land,Ocean,Border
							+ GenericTextureGroups
								+ RCBomb
								+ RCBombPing
								+ ...
							+ ExplosionTextureGroups
								+ Explosion
						+ Split jsons
						+ Refactor TextureDatabase
							+ Split Textures folder per-DB
							+ See if there's any "element-like" struct for which only the container
							  should reference TextureGroups, element might not have to know about its coords
						+ Refactor TextureAtlas
							+ Templated on groups
							+ TextureAtlasBuilder<Traits> has now also static builder method that takes an entire database - TextureDatabase<Traits>
							+ See if there's any "element-like" struct for which only the container
							  should reference TextureGroups, element might not have to know about its coords
						+ UploadedTextureManager: also per-groups
						+ RenderContext instantiates different TextureDatabase<Traits>'s
						+ Unit tests
						+ Commit
						+ Move non-generic texture groups from GameTypes into RenderCore.h
					+ AtlasBuilder: all methods take Options flags = None, AlphaPremultiply
						+ Also store flags in AtlasMetadata
					+ Test all texture groups					
					+ Baker tool:
						+ bake_regular_atlas <DB name> <input_folder_path> <output_folder_path>
							+ Takes database name ("Explosion") as input
						+ 2 Files, using TextureAtlas::De/Serialize(folder)
							+ AtlasMetadata, json format
							+ Atlas image, png
							+ Deserialize
							+ See if need to do binary serialization
					+ RenderCore -> TextureTypes.h, ShaderTypes.h, RenderTypes.h (for Quad and Stats)
					+ See if we want to do explicit instantiation of TextureDatabase and TextureAtlas templates at 
					  TextureDatabase/TextureAtlas.cpp
						+ ...which include TextureTypes.h
						+ Move back as many methods from .h to .cpp
				+ Move all ultra-violent mode (x3) to bombs' invocations of StartExplosion
					+ Move ultra-violent from blast strength to radius
				+ BombExplosionBlastForceAdjustment: new parameter
					+ Each bomb then adjusts on it (75%, 100%, 125%), sending 500_adjusted * adjustment to Ship
				+ Do explosion notification at Impact bomb
				+ Merge back into 1.14
		+ Rain wetting exposed parts
			+ Every leaking point, that is overwater, gets water in from rain density
				+ Just change externalWaterHeight so that it's max of ocean column height at that point, and rain density * constant
			+ Rearc rain density:
				+ Leave Storm::Parameters::RainDensity as-is
				+ Add new Storm::Parameters::RainQuantity: m/h
					+ Calculated as RainDensity * 50mm/h, not adjustable
					+ Only used by Ship::UpdateWaterIntake
						+ Uses GameParameters::RainFloodAdjustment: 0->1000->3,500,000
							+ Parameter is specific to water intake
						+ Ensure that at Xmax adjustment and 1.0 density, equivalent water height is 1m
				+ SettingsDialog
					+ Also conditionally enable new slider based off DoRainWithStorm
					+ Fix modulate wind's checkbox+slider expansion
			+ Test water bubbles
		+ Menu's: try look'n'feel of "foo/bar"
		+ Try to overlap bombs' disappearance with explosion
			+ And try to draw explosions *over* generic textures
		+ Explosive combustion
		+ changes.txt		
		+ Interleaving Update's with Render's
		+ Smoke (*)
		+ Ropes are too strong - they prevent ship parts from sinking
		+ Send for testing
		+ Bump up version
		+ Switches (*)
		+ Slicer sound is not controller by Tools Volume
			+ Move SawedMetal and SawedWood sounds from MasterEffects to MasterTools
		+ Try transmogrifying all textures
		+ See keyboard shortcut for push switch
		+ Repair: better algo to restore points
		+ Re-try world border, using right total texture space width and height (i.e. - 1/S)
		+ Try flames with texture
			+ Add a new "Flame" texture to GenericTextures atlas
				+ Try to flange its bottom
			+ Test shader, using hardcoded atlas coords for flame texture
			+ Make it new flame mode, 1
				+ Rename others as 2 and 3
			+ Restrict two-stage rendering only to modes 2 and 3
			+ Test putting back vertical time-changing offset
				+ Texture has colors for all values of alpha mask
				+ Shader samples twice
				+ Do MipMapped and Linear Generic Textures
					+ Code
					+ Rename ship gen tex shader
					+ Shaders' parameter names: GenericTexture -> GenericMipMappedTexture
					+ Flame 1 shader parameter name: GenericTexture -> GenericLinearTexture
					+ WorldBorder/End parameter name: -> GenericLinearTexture
					+ WorldBorder: provide atlas coords for border texture into shader via param - once and for all at RenderContext initialization time
						+ Cleanup:
							+ RenderContext::RenderWorldEnd
							+ RenderContext::cctor: 
				+ Change comment of flameSpacePosition (range) in shaders 2 and 3 as well
				+ See if alpha sampling is really necessary
				+ Color texture: do better wrapping 				
				+ Alpha texture: avoid vertically-separated parts 
					+ Straighten up flames
				+ Cleanup last shader items
			+ Try to bend flame quad based on velocity
				+ Limit max length of Q (but not its direction!), being proportional to scale at the same time
				  (i.e. max length is more with a bigger scale and smaller with a smaller scale)
					+ Use simple edge function
				+ See how to impart inertia:
					+ Points::CombustionState has (current) FlameVector, which converges to
					  target vector
					+ Convergence speed should depend on velocity magnitude
						+ Try with linear step
			+ Provide atlas coords for flame texture into shader via param - once and for all at ShipRenderContext initialization time
			+ Test with flame size slider
			+ merge
			+ changes.txt
		+ Send for testing
		+ Spring and NonSpring force separation optimization (*)		
		+ Sea floor collision revisit (*)
		+ Attempt to get rid of boundary checks at OceanFloor and OceanSurface sampling
		+ Bump up spring iterations		
			+ 24 -> 30: 22.5ms/30.0fps
		+ changes.txt
		+ Multi-threading, phase I:
			+ ThreadPool
			+ Create at controller and pass as shared_ptr down the hierarchy
			+ Pre-perf: 
				+ Dell: 21.8 ms/30.5 fps
				+ Samsung: 96 ms/9.15 fps; Szerszen: 312 ms/3.0 fps
				+ HP: 47.32 ms/15.7 fps
			+ BufferAllocator::Allocate() needs to become multi-thread friendly
			+ Get timings of Ship::Update
			+ Fork
			+ Ship::Update: Run concurrently:
				X 1) UpdateMechanicalDynamics: 
					+ Nuke the old _ByPoints
					X Do n+1 iterations:
						+ First of all, call Points::AllocateWorkBufferVec2f to alloc Position2 and Velocity2
						+ First iteration does not need to integrate+collisions
						+ (n-1) iterations in parallel; at each step i, do in parallel:
							+ ApplySpringForces(pi, vi) -> (fsi+1)
							+ Integrate+Collision(pi, vi, fsi) -> (pi+1, vi+1)
						+ Last iteration does not need to apply spring forces
						+ Finally, call points:: SetPositionBuffer(std::shared_ptr<Buffer>) & Velocity(...), which swap
						  mBuffer and argument buffer
						X Doesn't work
				+ 2) TODOHERE: identify other parallelizable tasks; candidates:
					+ WaterDynamics, HeatDynamics, DiffuseLight
			+ Samsung post-perf: 94.5 ms/9.1 fps | 49.5 ms/16.9 fps; Szerszen: 298 ms/3.2 fps
			+ HP post-perf: 46.4 ms/16.0 fps
			+ Verify multi-threading
			+ Undo
			+ Try DiffuseLight + Whole thermal
				+ Pre-perf Titanic with Lights:
					+ Samsung: 165 ms/5.6 fps
				+ Post-perf Titanic with Lights:
					+ Samsung: 162 ms/5.7 fps
			+ Commit
			+ Merge
		+ Cursors at night
			+ RenderContext fires OnEffectiveAmbientLightIntensity whenever this changes
			+ ToolController is notified about effective ambient light changes
				+ Registers
				+ Changes mCurrentEffectiveAmbientLightIntensity
				+ Calls InternalSetCurrentToolCursor()
			+ Tools don't have mParentWindow anymore, but cctor gets IToolCursorManager &
				+ virtual void IToolCursorManager::SetCursor(std::shared_ptr<wxImage const *>, float strength = 0.0f)
			+ IToolCursorManager stored at base
			+ Tools invoke mToolCursorManager.SetCursor(.)
			+ ToolController::IToolCursorManager::SetCursor(std::shared_ptr<wxImage const *>, float strength = 0.0f) override
				+ struct ToolController::ToolCursor{sh_ptr<Image>, float strength}
				+ Store sh_ptr<Image> & strength at mCurrentToolCursor
				+ Calls InternalSetCurrentToolCursor()
			+ ToolController::InternalSetCurrentToolCursor():
				+ Make tmp image from mCurrentCursorImage and lighted based off mCurrentEffectiveAmbientLightIntensity
				+ Make power bar based off mCurrentCursorStrength
				+ Make wxCursor (local) and set on mParentWindow			 
			+ Power bar cursors: at power bar change, call mCursorManager.SetCursor(cur img, new strength)
			+ Do same formula at TextRenderContext
				+ New param: TextLighteningStrength
				+ Redo math in shader
		+ TrimForWorldBounds: clamp coords to zero after bounce
		+ Change light colors to match Mike's
			+ And add new render param for shaders
		+ Reduce sea's little waves from gusts

		+ Materials changes:
			+ Lower gunpowder strength
			+ Cardboard floats in air
				+ Also set thermal expansion so that it flies when hot
			+ Check Mike's changes		
			+ Redo templates
		+ Hull should decay less
		+ Also GoodYear should be full of hydrogen		
		+ Selector for panel background
			+ Right-click on panel -> new SwitchboardPanelBackgroundSelectorDialog:
				+ ...or a floating context window?
					- https://docs.wxwidgets.org/trunk/classwx_popup_window.html
					- https://forums.wxwidgets.org/viewtopic.php?t=15025
				+ Dialog uses ResourceLoader::GetIconFilePaths(pattern) -> vector
					+ Now that you're at it, rename ResourceLoader::"Icon" to "Image" where appropriate
				+ Then resizes imgs and populates combo box with thumbs + filenames (for internal use)
			+ New Preferences property: electrical panel background filename
		+ Do highlight also for water detector
		+ Broken water-sensing switch should not trip anymore
		+ Power probes (*)
		+ See if should take Mike's Titanic electricals
			+ Add instanced generator(s)
		+ Propulsion (*)
		+ Double-check strength (Titanic break test)
		+ Send for testing
		+ Bump up version

		+ Improve flame velocity vector: higher VelocityScale
			+ Check overall feeling w/new number
				+ Simplify number
			+ Try with non-linear growth
		+ Fix trapped bubbles
			+ Test if some debris also made it to the other side before the fix
			+ Test perf impact

		= Discord intake:
			+ SetDoubleBuffered on MAC
			+ Wood background for panel (mahogany)
			+ Sam's errors
			+ Lever dragging
				+ "When they click directly on a speed, it goes to that speed and it would only be one bell sound"
				+ PointToValue(.) -> value
				+ MoveToValue(.)
				+ Issue with LeftUp happening outside of control:
					+ Either:
						+ Register for leave doing exactly like up
						+ Or: capture mouse
			+ Paper material
			+ GameJolt post for those two videos
			+ Add motors: 230hp outboard motor and 550hp steam powered motor
			+ Legos:
				+ Make hull Lego as heavy as non-hull Lego (re-check literature)
					+ Test w/new ship from Mike
					! Density should be 401kg/m3 or 0.55g/cm3 == 550kg/m3
						! https://www.eurobricks.com/forum/index.php?/forums/topic/72114-lego-weight/
						! https://bricks.stackexchange.com/questions/9012/how-can-i-distinguish-floating-versus-sinking-lego-pieces
				+ Lego sounds
					+ Break
					+ Destroy
					+ Stress
					+ RepairSpring
					+ RepairTriangle
				+ Do one or two variations on plastic stress
					
			= New Concrete material, hull and non-hull
				+ Make ball of concrete
				+ Adjust thermal expansion coefficient
				- Mike's gonna test
			+ Bug: "if the heat dissipation is at 18.8 or higher it causes fabric to glitch out the whole ship"
				+ Could repro with Sailboat
				+ Check release perf impact
			+ Fix Hindenburg: doesn't float anymore
			- captain noobinson
			+ Take mike's fireship 
			+ Redo structural material template
			= changes.txt, including ships
			= Bug of that guy
				- Tell him it's wood stiff

		= Repair:
			X Same velocity
			X If good, remove old code
			= Try smaller distance tolerance
				x 0.055
				= 0.06
				- Try dividing by spring stiffness
					- Test with ropes

		- Retrofit ships

		- Musica Bazzico
			- Think about playlist

		+ Horns and bells
			+ ElectricalMaterial
			+ GameEvents
			+ Dynamics
				+ Add
				+ Announce
				+ Destroy
				+ Repair
				+ SetSwitch
				+ Update: 
					+ Transition conditions: power/isSelfPowered, conductivity, destroyness, mIsPlaying
					+ Fire ShipSound event w/material and underwater
				+ Highlight: tie it to operation (i.e. powered + switch state), not to switch state alone
					+ Avoid at SetSwitch
					+ Do at UpdateSinks()
			+ SwitchboardPanel
				+ Create switch on announcement
				+ New gfx, to be used w/push switch control
				+ Test Disable/Enable on destroy/repair
			+ Sound
				+ Horn
				+ Fix MultiInstanceLoopedSounds::Start: new SoundFileInfo might be different than current
				+ Other sounds:
					+ Rename existing sound file
					+ Nuke horn2
					+ Do new sounds
					+ Elec material: new "ship_sound_type" types
					+ json
					+ test ship
					+ SoundController:
						+ New sound types
						+ New naming convention for filenames						
			+ SoundController
				+ Start: Hijack instance ID
				+ Hookup:
					+ Reset
					+ Mute
					+ MasterEffectsVolume
					+ Pause
			+ Materials json
			+ Add to circuit test
			+ Add bell 2 to Titanic
			+ Materials guide and template
			+ See if can merge engine sounds into MultiInstanceLoopedSounds

		- Test: points of Water are filled with water, and mass is set to that of air
			- First off, water material: buoyancy_volume_fill?
			- At ShipBuilder::TransformMaterials(matrix, materialsDb) // in-place, w/PointInfo::Water
			+ Test with "Ball of Water and Air"
			- Water cannot be hull
			- Redo "Ball of Water and Air"

		- Test: re-try cache layout optimizations
			- See impact first with NOP optimization

		- Wine crash: Wine stable version 5.0
			Backtrace:
			=>0 0x0000000000237742 EntryPoint+0xf96a() in sfml-system-2 (0x000000000f0bffd0)
			  1 0x000000000022e526 EntryPoint+0x674d() in sfml-system-2 (0x000000000f0bffd0)
			  2 0x000000007bc91c13 call_thread_func+0xd2() in ntdll (0x000000000f0bffd0)			

		- "I noticed that in the game, if given enough time, the clouds in the background will gradually cover and fill the whole sky, 
		  leaving it completely white"

		- Website: add FAQ for electrical panel -> Gabe's blog

		- Release
			

		- Publish roadmap:
			- Flood doors, pumps
			- Frontier -> Hydrodynamics (gliding)
			- In-game Ship Builder
			- Spring loop optimizations -> Rigidity
			- NPCs
			- Collision detection -> Multiple Ships

		- Repair improvement:
			- A)
				- Make triangle's vertices CW
					! Have to do it anyway for frontier
					- Add to invariant checks
						- Debug.h => Triangles::RunInvariantChecks(.)
				- If, after attaching a point, that point is a vertex of a flipped (i.e. CCW) triangle:
					- Move the point to the other side (rendering the triangle CW)
			- OR: B)
				- An attractor with only one spring attached cannot attract and attracted that has >= 2 springs attached

		- Pinch tool (*):

		- Pumps (*)

		- Batisphere with pumps
			- Batisphere ship
			- Electrical layer view (*)

		- Flood doors (*)		

		- Particle-zation
			- Just destroy all springs, with no other side-effects

		- Investigate perf hit of rendering to buffer and directly drawing the buffer afterwards
			- If it works: do "reshader" type of work (*)

		= See if fire may emit Heavy smoke
			- Smoke should be drawn behind flames, hence GenericTexture's should be in an earlier layer than flames.
			  However, generic textures (smoke) have internal transparency, while flames have none; the Z test makes it so then
			  that smoke at plane ID P shows the ship behind it, even though there are flames at plane IDs < P
			- Do cleanup tasks
		
		- Attempt to use total point masses for springs (*)

		- Cached quantities (*)

		- Run w/OpenGL tracing to see if there's any errors

		- Multi-threading, phase II:
			- Springs: each iteration done in parallel with NThreads partitions
				- Pre-perf: 
					- Dell: x ms/x fps
					- Samsung: x ms/x fps
				- Do
					- Pool: if run 1, run straight away on main thread
					- Spring indices need to be partitioned beforehand into multiple Buffer<ElementIndex>'s
						- @ShipBuilder:
							- Is given # of partitions
								- ...caller uses mThreadPool->GetNumberOfThreads();
							- N-1 partitions plus one "stitching" partition
								- Partition points and all springs between those points
								- Put cross-partition springs into last partition
					- Prepare parallel tasks
					- Run parallel tasks
				- Post-perf: 
					- Dell: x ms/x fps
					- Samsung: x ms/x fps

		- Lights/materials breaking under pressure (*)		
		- Break lights when structure gets "broken"
			- Whenever a triangle or spring is destroyed, break also *lights* attached to any of the endpoints
				- @ Ship::DestroyHandler's

		- Do shader at Anti-Matter bomb pre-implosion
			- Shader already started: https://www.shadertoy.com/view/3sVSRc
			- See if should add some noise

		- Underwater currents (*)		
		
		- Continuous Auto-focus (*)

	- 1.15.0		

		- Spring relaxation with intrinsics

		- Frontier (*)

- Ship making:
	# Credit names:
		# ShippyMcJerry: ShipBuilder1912 
		# Coolman115: CorbinPasta93
		# Ilovedumbphones: Dumbphones
		# SweetStrawberryBoy: TopHatLemons
		# sum wulf gurl: Artica
		# An SR71 Habu: NotTelling
		# JackMellon: JackTheBrickfilmMaker (Discord, https://drive.google.com/drive/folders/1isy3QiRzMfyu69v5M0gwD5tvBnYZMWXx)
	- Ship Packs:
		- Kiko's pack
			- Screenshots and description in PM
			+ I keep donations

		- HummeL: asked for deliverables
		- Mr. Woldemar: waiting for deliverables
			+ I keep donations
		+ Waallrus: have all
		+ MasterGarfield: have all
			+ Have also his PayPal email
		= Alex02:
			+ Have Part 1 and Part 2
			+ Titles: "Le navi dalla storia" (vol. 1 e vol. 2)
			- Description: I make it
			+ Author: "Alex di Roma"
			- Add "Andrew Hensley" to credits of: Blue Regalness, 2xQueen Anne 
		- Space ship pack: [free]
			- JohnSmith: gave permission for his
			- Ships in PM
		- nomadavid's pack
	- New ships:
		- To test:
			- mrpasta444_ship_pack
			- TheodoreRoosevelt
			- Graza's from awesomeyorkie
				+ Asked if ropes of abandoned are cut on purpose: yes
				- Fix Antonia vs Antonio
				- Require .shp to limit initial sink
			- Pac0master's Structures
			- Hummel: 
				- Mini Bismarck rar is empty
			- SCS and Space Titanic - permission from John Smith to include in ship pack
				You can find both versions on #architect-creations in the FS server
			- Fuhrer from Kiko
			- HMS_Mark_Hamil.png from TopHatLemons
		- To take:
			- All the ones under "Ready"		
				
	- Descriptions:
		+ Tell maximord about new ships - give him names
		= Copy all descriptions into their respective .shp files
			# From https://docs.google.com/document/d/1niiB9AaqMAzThTY-pGjU3-qxIywKR8-nw_JDiOWcj1o/edit?usp=sharing_eil&ts=5c929c19
			+ Done:
				+ RMS Queen Mary
				+ Black Titan
				+ SS Germanic
				+ Circuit Test
				+ Flood Test
				+ Hindenburg
				+ HMHS Britannic (X3)
			- Ask ship owners
				= mrpasta: wants to see them first
				+ kikotheshipbuilder: all except HMS Thunderchild
				+ Nomadavid: fine
				+ Pac0: will do own
			- Shippymcjerry does:
				- HMS Thunderchild
				+ Karaboudjan
			+ Add Maximord to About box

	- Michael Bozarth
		+ https://drive.google.com/drive/u/0/folders/1VUNnoO81GBejcdXgvQAt9siL4MnhkBBf (latest)
		+ https://drive.google.com/drive/u/0/folders/1k-A4SE8mMp2j_A3nH3gnl6SvYF9bnWoU (older)
		+ Add "Michael Bozarth" to About box (link: https://www.youtube.com/channel/UCaJkgYP6yNw64U3WUZ3t1sw)
		- Test his "Splitable Titanic"


- Suggestions to spec:
	- Temperature tool - to get temperature of points
	- Make lights not propagate through hull
	- Sun rays
	- Moving furniture
		- Need way to prevent springs made to other materials
	- Slow motion
		- When bombs explode
	- Wreno's suggestions: https://docs.google.com/document/d/1kOYAgvh2rFYJJBnSp4DCiFm3FdJlfVEiCXQWNzJzO-I/edit
	- Be able to place nuke and AM bomb anywhere
	- Fishes
		- Textures: https://oceana.org/marine-life
		- Ideas (Wreno): https://docs.google.com/document/d/1RHF9BC2L19Dcx9YzkBSQ1hdz8Pnxz0vC8R6tj03txr8/edit
		- AABB around ships' connected components, so that fish AI's avoid them
	- Plants on the bottom - don't have to interact with the ship, just on layer in front of it
	- Different colored lights
	- Different maps: maps that might even have islands and grass 
	- Black hole
	- Tool to increase or lower mass under the cursor
	- Can the bubble tool be used to remove water from the ship? that could be pretty cool
	- I wonder if that's possible to make the UI dark once the brightness of the game gets lower than a specific level just like your make the FPS counter white
		+ Tools turning white at night
	- I wonder if you can add the "Ground" material, which is a material that cannot move.
	  No physics calculation. Plus, you're using texture, so it would be neat if the same texture as the ground can be applied to it
	- Tornado
		- Mixes swirl and grab
	- Meteorites
	- Earthquake
	- Add circular zones around bombs when placing showing what the expected blast radius should be. The circle should change in size when settings are tweaked. Much better than crunching numbers to figure out what's gonna happen.

======================================================================================================================
======================================================================================================================
======================================================================================================================
- Technical Debt:
	+ Global damp as game parameter
	+ Ships start from 1
	+ Do #include "foo.glsl" at ShaderManager
		+ After including redo
		+ Detect loops with unordered_set<std::string>
		+ Use for ship color and texture
	+ Sound controller: complain if find extraneous files (had issue with ".flc"
	+ Ship: replace handler registrations with points, springs, etc. with IShipPhysicsHandler, declared in own .h
	- GameEventDispatcher: set mIsXYZHandlerDirty at event publishing and consume at Flush()
	- Try 32-bit build
	- Translations:
		- Make localizable
		- Russian: steven6886@yandex.ru, rbugaev2@gmail.com
	+ SSL cert: https://www.sslforfree.com/
	= Sign with certificate
		+ https://blogs.msdn.microsoft.com/ieinternals/2011/03/22/everything-you-need-to-know-about-authenticode-code-signing/
		+ https://www.thegeekstuff.com/2010/03/microsoft-digital-signatures/
		- Reasons:
			- Anti-virus complains of saving
		- Buy certificate
			- https://comodosslstore.com/code-signing/microsoft-authenticode
			- https://comodosslstore.com/codesigning.aspx
			- Print receipt and store in Taxes 2019
		- Sign exe
		- Sign MSI
			- https://stackoverflow.com/questions/17589754/wix-installer-msi-publisher-unknown/17591603		
	= Wine:
		+ Test checking for the APPLE extension for VAO's: https://developer.apple.com/opengl/OpenGL-Capabilities-Tables.pdf
			+ "APPLE_vertex_array_object"
		+ Give SamminAter another RelWithDebInfo + pdb
		- Other issues:
			- No fullscreen mode
	- See if may upgrade to wx 3.1.3
		- wxEVT_KEY_DOWN and/or wxEVT_CHAR: do evt.Skip()
	- Looped sounds (engines, bells, horns, etc.): make them OGG with built-in loop points (see https://rpgmaker.net/tutorials/1341/)

- Mac:
	- See replacement for "intrin.h" @ SysSpecifics.h

- Simulation Optimizations:

	- See if additional springs (e.g. between i and i+2) help

	- Cached quantities (*)
		! Ship::Update: cache quantities that are currently re-calculated multiple times 
		! Identify streak of calculations that need a quantity more than once, and during which the quantity never changes
			- e.g. spring lengths between water update and heat update
		- Cache quantities in Update loop that comes first or last
			- Make it clear that the Update function calculates them: TBD in name
			- Alternatively, use lambda
				- Verify with assembly that there's no overhead with empty lambda
			- Alternatively use Algorithms::CalculateSpringDirAndReciprocalLengths
		- Candidates:
			- Spring length, spring dir
				- Valid as long as points don't move
					- In DEBUG, mark mPoints.mArePositionsDirty, and expose mPoints.Diagnostic_ClearDirtyPositions() which is
					  invoked when Springs' cached lengths are re-calculated
				- Used by: water update, heat update, Springs::UpdateStrains
					- Also use instead of factory rest lengths at:
						- Water
						- Heat
			- Underwater depth 
				- Valid as long as points don't move
					- Do DEBUG work above
				- Used by: 
					- UpdateWaterIntake (for leaking points only)
					- Heat dissipation
					- Breaking materials for pressure
					- Points::UpdateCombustionHighFrequency
					- Points::UpdateEphemeralParticles (AirBubbles)
						- Need to do vortex with forces, though
	
	- 2** Try with SpringRelaxation updating only positions **2 (*)
		- RelaxSprings() updates position directly, no forces involved
			- So no need to integrate afterwards
		- However, need to update velocity, and it's faster if we do it for each point rather than for each spring:
			- Save positions first
			- Do iteration
			- Add resulting velocity: (newPos-oldPos)/(DT/NumMechanicalIterations)
		- Finalization:
			- Initial positions snapshot and UpdateVelocitiesFromPositionDeltas: we only need them for the particles
			  that might have springs - we definitely don't need ephemerals

	= GPUCalc:
		+ 1: Simple OpenGLContext
		+ 2: Multiple OpenGLContextes
		+ 3: Integrate ShaderManager
		+ 4: Run fragment shader to fill-in with frag coords
		+ 5: RenderBuffer
		+ 6: Read pixels back 
			+ Nail down clamping
			+ Nail down viewport dimensions/renderbuffer dimensions
				+ Fragment shader runs according to window sizes
				+ Try glViewport to set dimensions (40x40)
		+ 7: Make OpenGL initialization once per thread, after first context creation
			+ Test first at FloatingSandbox: do init at MainFrame after context creation
				+ Export required OpenGL version from GameOpenGL
				+ If ok, move ctx creation et al at postinitialize trigger
					+ Test openGL failure
				+ Cleanup comments (3.3.) and TODOTEST's
			+ Do also at GPUCalcText, also at MainFrame after a first dummy context creation
			+ Commit
			+ MainFrame:
				+ Move OpenGL initialization at cctor, rethrow, and catch at MainApp
					+ Test failure
				+ Same identical at GPUCalcTest
				+ Commit
		+ Fix shaders: 120			
			+ Test with FloatingSandbox
			+ Send to guy
			+ Commit after confirmation
		+ 8: Redo Glad with 2.0 profile, and manual ARB's and EXT's for:
			+ Framebuffer
			+ Instanced Drawing
			+ VAOs
			+ Texture Float
			+ Restructure: 
				+ Each feature is a "min"
				+ Merge GladLib into GameOpenGLLib
					+ g_glad.h stays
				+ GameOpenGL_Ext stays
					+ h:
						+ global vars with API and enumerants
							+ validate all enumerants the same across core/arb/ext
					+ .cpp:
						+ Various Init():
							+ Load only one set based off version/ext, with LoadAndVerify
					+ LoadAndVerify
			+ Build all and commit and push
		+ 9: Restructure GPUCalcTest
			+ Log window, clear button
				+ RichText: green/red for TEST_PASS: .../TEST_FAIL: ...
			+ Testcase class:
				+ .h:
					+ Macros that call "this"->OnFail(__LINE__....)
				+ void Run() final;
					+ Inits state
					+ Logs start/end
					+ global pass/fail state
				+ virtual void InternalRun() = 0;
			+ Button for "Init OpenGL"
				+ Clears log first
				+ Own test
			+ Buttons for tests, button for "All tests"
				+ Each button clears log first
			+ Tests:
				+ (all tests create own calculator)
				+ PixelCoords
				+ Commit
		+ 9b: GPUCalcTest: independent from DevIL
			+ Verify GameCore and GameOpenGL are independent from DevIL
			+ ResourceLoader back to GameLib
				+ ShaderMgr takes absolute folder path
			+ CMake adjustments to not need DevIL
			+ Commit
		= 10: Sum test:
			+ RenderBuffer and textures all have same dimensions
				+ FrameSize this time is calc'd based off min of the three limits
			+ Fragment shader gets texture coords from vertex shader
				+ Interpolation is fine
			+ Cleanup:
				+ See if need to replace ShaderMgr::SetTextureParams with new one
			+ Commit & push
			- Compare perf with normal sum
		
		- Other tests:
			- Sum w/calculator reused twice
			- Sum size1 and Sum size2 (2 calculators), one after the other
				- Verify viewport is per-context

		+ x: Verify works with hidden wxFrame, and verify frame is not visible, neither on the taskbar
		- x: Test on two other laptops

		- Cleanup:
			- Set endianness same as platform (x86)
			- See how to force texture sizes to be POT

		- Follow-up's:
			- Optimize ReadPixels
				- Use correct format: query for GL_READ_PIXELS_FORMAT, GL_READ_PIXELS_TYPE
					- See https://www.khronos.org/opengl/wiki/Image_Format
				- Consider using pixel buffer objects to asynchronously read from render buffer
					- See https://stackoverflow.com/questions/12157646/how-to-render-offscreen-on-opengl

	- Array merging:
		+ Springs: RestLength with Coefficients
			+ Pre:  31.7  32.03  31.5  31.6
			+ Post: 31.5  31.7   31.4  31.6
			* With pad:
			+ Pre:  31.1  31.5   31.6  31.7  32.0
			+ Post: 31.3  31.38  31.3  31.3  31.9
		- Points: Position with Velocity and Force
			- Affects Integrate and Rendering

	- UpdateWaterDynamics:
		- Test turning it around into (multiple) spring visits, rather than point visits
			- Multiple because of need to normalize outgoing for each point

	- UpdatePointForces:
		- Substitute "if(y<waterHeight)" branches with "float isUnderwater (1.f/0.f)"
			- Force compiler into not branching - "?" operator won't work
		- Precalculate things that do not depend on position nor velocity
			- Stored in buffers
				- When possible, via template/lambda tricks
			- Technically, would have to store separately effectiveMassMultiplier (*Mass) and effectiveBuoyancy (*Mass)
				- Test: but could cheat and use water height based on initial positions only, in which case
				  we store directly the result as FieldForce == Gravity + Buoyancy + Water Drag
				  - FieldForce used directly in Integrate(), added to Force (-> "SpringForce")
				  - This allows us to call UpdatePointForces only once
				  - Also need to reset StaticForce buffer before UpdatePointForces, so:
					- UpdatePointForces becomes CalculateFieldForces and take care of *filling* the buffer, overwriting it


- Gfx optimizations:

	- See impact of drawing onto texture and then quad'ing the texture onto the screen (w/no filtering)
		- If fine:
			- Do stars once and for all
			- Spec gfx niceties such as reflections and after-effect
					
	- Lights on the GPU with instanced drawing
		- We begin with doing light at vertex (Gouraud)
		- Lamp coords, spread, and luminiscence in uniform array
		- Loop as many times as necessary to avoid going beyond uniform limit of the GPU
			- Figure out max (for right shader: v or f) at OpenGLInit
		- Test 1: simply instance TrianglesTexture
		- Test 2: also instance others
		- At end:
			- Try with light at fragment (Phong)

	- Air bubbles with instanced drawing (even though we can only do ~100 at a time, but then might do nBubbles/100 vertices)

	- Try using GL_SHORT for Ship texture coordinates
		- Passing NORMALIZE and 3 components to glVertexAttribPointer


- Gfx:
	- Intro screen: the game's title falling into the sea and floating back up - interactive to a smaller extent, e.g.
	  by just punching holes

	- Background ships: just any of the other ships, that would sail in the background	

	- Heat overlay more integrated in game play:
		- Make switch: "Heat map mode" (now) and "Incandescence mode" (no black), in which shader replaced black with alpha=0

	- Fog
		- And fog horn

	- Continuous auto-focus (*)
		- Vision: once we have ships, make "Lock Ship in View" flag and move camera with ship's center of mass (representative point or real CoM)
		- Spec:
			- Orchestrated by GameController by taking "optimal" AABB from World (which takes union of "optimal" AABB's from each ship)
			  and giving it to RenderContext, which adjusts ViewModel based on it
				- At each simulation step
			- Preferences setting for auto-focus (default is on)
				- Also toggable at "Controls" menu
			- Also works as "auto-focus at load"
		- Algo:
			- Option 1:
				- Connected component i has AABBi
				- Ship "optimal" AABB == Union(AABBi) for i belonging to B
					- B is set of connected components such that sum(their #points) > 3/4 TotPoints, in optimal order (from larger to smaller)
				- Maintaining AABBi:
					- Option 1:
						- Updated at each simulation step leveraging geometrical and temporal coherency:
							- For each connected component we remember the 4 extreme points
							- At each simulation step: UpdateConnectedComponentAABBs()
								- For each connected component i:
									- For each extreme point p:
										- Visit p.neighbors as long as they're more extreme than p (i.e. follow gradient)
										- Replace p with this new most extreme point
						- Technically we don't even need to maintain AABB, we just need to maintain 4 ElementIndex for each connected component
						  (the 4 extreme points)
							- struct AABBPoints, w/Left,Right,etc. members
					- Option 2:
						- Recalculated at low-freq step
				- Maintaining B:
					- Option 1:
						- Simply recalculated from scratch at each connectivity visit
							- Use insertion sort to end up with list sorted by #points, desc
					- Option 2:
						- Recalculated at low-freq step (same as above)
			- Option 2:
				- Low-freq step calculates AABB

	- Different backgrounds: use keys to switch between a dock, cliffs, open ocean, ice field, etc.

	- Sky:
		- Add SkyRenderMode (Flat, Gradient)
			- The two endpoints of gradient dependent on ambient light
				- Interpolated between two pairs of endpoints
			- RenderContext:
				- If Flat:
					- When clearing buffers, clear also color buffer with flat color
				- If Gradient:
					- When clearing buffers, do not clear color buffer
					- Run program with quad immediately afterwards
						- Shader
							- No orthomatrix, all NDC
							- No ambient light param, no new params

			- SettingsDialog:
				- Gradient RadioButton: on the right has two rows with a gradient each
		- Night sky should use a round darkening - center of screen is slightly lighter
			- Or even better, Milky Way

	- Make water texture scroll with wind speed

	- Electrical view:
		- Spec:
			- New flag (not in ShipRenderMode, standalone ~like StressedSprings)
				- Settable at SettingsDialog
					- Ideally, enabled only if there are electrical elements, but how to figure it out?
			- When enabled, draws "Connections" (lines - using ship endpoints) and "Devices" (points - using ship endpoints) 
			  on top of ship
				- One new layer after tri's, springs, and ropes
				- Connection, w/bool isPowered
					- Powered: 1D texture, animated (w/clock->offset), red
					- !Powered: 1D texture, still, grey matte
						- Both textures are segments in same texture
				- Device: shader with concentric expanding and/or contracting circles and different colors
		- Impl:
			- (Ship)RenderContext::UploadElectricalConnection/Device/Start/End:
				- Conn: 
					- vec2 startPos, endPos
					- planeId
					- isPowered => texture coord
				- Device:
					- vec2 pos
					- planeId
					- vec4 color => color
			- Ship::Render: if flag set: invokes Ship::RenderElectricalElements()				
				- Do a sort of connectivity visit and upload as you go

	- AmbientLightIntensity:
		+ Use also in RenderContext::RenderStart() for clear (sky) color
		+ Phase 1: pgup/down
		- Phase 2: with clock / time-of-day
			- Sky should also have crepuscolar gradient
	- Magnifying glass
		- https://www.opengl.org/discussion_boards/showthread.php/154811-magnifying-glass-effect
		- https://www.shadertoy.com/view/4tdXDl

	- Add a flashlight to see the ships deep underwater. Its hard to see the ships at some depths. Plus the idea of seeing a rusty hulk of metal appear out of the dark abyss is really cool.

- Dynamics:	

	= Ocean floor deforming upon impact (*)
		! Better done after frontier work, so that may calculate pointness
		+ ParentWorld exposes DisplaceOceanFloor(x, offsetY)
		- @ Ocean floor collision: upon (non-orphaned) point entering floor:
			- Ocean floor's H goes back (opposite) by displacement * FloorFriability * f(pointness, massiveness)
				- displacement is whatever displacement we moved (bounced) the point by
				- FloorFriability = new param [0.0, ..., 1.0]
				- pointness = TBD, based off frontier
				- massiveness = point's connected component size
		- WATCH OUT: might be ugly with peaks (very vertical slope)
			- Increase resolution of ocean floor - shouldn't impact perf other than for cache misses

	- Gases: 
		- Spec:
			- Drawn on separate layer and act as water, but with upside down gravity
			- It will leak through holes
			- Gets destroyed by water
			- Causes air buoyancy
		- Can be implemented as a parallel Point::Water system
			- It will only slow down marginally, and only when the user specifies a gas layer

	- Newton's 3rd law:
		- Emitter materials, like smoke (and a new "jet engine" one), should impart an opposite force on the emitter
		- Jet engine: need a way to render flames/particles coming out 

	- Air drag
		- Thinner moving up, MaxWorldHeight is open space

	- Aerodynamic heating https://en.wikipedia.org/wiki/Atmospheric_entry, something like friction from the air

	- Pinch tool (*):
		- TODO: redo with spring force: Picks a point and keeps setting a force on it with a growing strength
			- State machine (strength growth, simple recursive function) done by tool
		- If needed applies also a fraction of the force to direct neighbors, or to all points in a radius
		- Tool:
			- Copy from Move tool
			- Tool engaged only if a point has been picked (like Move tool)
		- Cursor: pliers or tweezers, up and down
		
	- Lightning tool that summons lightning wherever it has been clicked
		- Lightning pointer: basically instead of lightning at random, you click and lightning strikes where you click

	- When lightning hits (a metal part of) the ship, then lights should go off temporarily

	- "Lightning rod" material
		- Has precedence when looking for candidates

	- Consider making world 1.5 times wider

	- Fires break out where electrical layer breaks (e.g. where *powered* line is cut)

	- "Physics" versions of move-and-rotate tool: act with forces on a (circle around a) point
		- Smoothing towards the periphery
		
	- EMP tool
		- Better after electrical "expansion"

	- Lights/materials breaking under pressure (*)
		- Idea:
			- All structural materials have max pressure delta after which they break, with some randomness
			- ...but only glass, lights, and may be a few others have reasonable values - others are basically indestructible, and they
			  will destroy with the "other" external pressure work which is tied with frontier			 
		- Impl:
			- Better done after cached quantities - underwater depth (*)
			- All points visited and checked at some step in UpdateMechanicalDynamics(), before UpdateWaterIntake()
				- Only non-leaking points (broken edge of glass ball should not break again)
				- Pressure delta between current water at point and external Y
					- With added randomness based off random personality seed

	- Tool to break enough to let water enter, but not to make a hole all the way to the other side
		- Just sets points as leaking

	- Move tool:
		- Allow for moving orhpaned points
			- At this moment we avoid that in PickPointToMove, but could allow for orhpaned point if no non-orphaned
			  points are in radius

	- Rot tool: rots without having to flood it
		- Then merge scrub tool into this one, with SHIFT 
		- Icon: ?

	- Randomize decay
		- Perlin noise on ship, created at ShipBuilder, stored as Points::WeakNoise
		- Used as rotting increase
			- From PM: also, idk if you do it already, but it would be fun if the speed of decay was pseudorandomized not by much but just enough so it would cause uneven patterns of decay along the ships 
		                   it would simulate defects in the hull or something
				   the only way I have to help visualising what I mean is by adding some noise on top of an image of the ships and the darkness of the colour would represent the rate of decay

	- Different materials have different rotting speed
		- For instance, Cardboard would soften and break apart in water within a minute or so

	- Underwater currents
		- Implicit function of x defines trajectory 
			- To try:
				- Constant
				- Lorenz, from http://sprott.physics.wisc.edu/chaos/eulermap.htm
				- Lorenz II, from https://en.wikipedia.org/wiki/Lorenz_96_model
				- WaterSurface, may be x-shifted
		- For each point: y-distance between point.y and trajectory(point.x) gives strength of x and y components of a force on the point
		- Dynamics:
			- Ship gets UnderwaterCurrents object from parent world
				- May be also give OceanSurface and nuke IsUnderwater/GetWaterDepth from World
		- Rendered (via option):
			- Texture is distorted depending on force field
			- TBD: see moleskine
	
	- Try to re-instate square velocity drag
		- Goal: falling ship should break upon impact with water
		- Better done after frontier and thus directional drag
		- Need to clamp drag force 
			- So better done after spring/nonspring forces rearc
		- Then, increase the amount of drag adjustment users may do
			- Goal: water should become lava with high drag

	- See if we still need the high global damp - it affects the parabole traveled by slinged ships, they fall vertically
	  at the end

	- Attempt to use total point masses for springs (*)
		- Do first a pass to recalc coefficients, once per simulation step

	- Shooting stars
		- Star "parks" always an extra star at (-1, -1)

	- Dynamite that may be thrown to the ship

	- Dive bomb:
		- The player drops it the sky and into the sea; the bomb goes below the waves for a bit and then refloats and 
		  hits the bottom of the ship
		- Needs frontier

	- New electrical material: clamp
		- When powered, destroys point (and of course its springs)
		- Make ship with lifeboats, using multiple clamps to keep it

	- Breaking waves (Muller's paper)

	- Fireworks
		- New emitter material, much like smoke emitter
			- Really?
		- Fires when wet for the first time
			- Really?
		- "Whatever color block it's on it explodes that color" (AwesomeYorkie)

	- Pumps (*)
		- Spec:
			- New electrical element type
			- Two types: "in" or "out"
			- Pumps' intake is superimposed to leaking point's intake
				- Point that pump is attached to may or may not be hull, and may or may not be leaking; regardless, when powered,
				  water is sucked in our out
			- Water is taken @ Ship::UpdateWaterIntake()
				- In: as long as external water pressure > internal water pressure
				- Out: as long as internal water pressure > 0
			- Continuous sound when pumping
		- Impl:
			- Materials: new electrical element type
				- Property: float pumpForce (< or > 0 for in/out), only de-serialized for pumps
				- Add property to guide
			- struct Points::LeakingComposite: float StructuralLeak (0.0 or 1.0), float PumpForce (-1.0,...,+1.0)
				- union: int64_t, used for fast "if(is leaking)" check
			- ElectricalElements::UpdateSinks():
				- For each pump:
					- smoothing state machine, w/operating temperatures
					- eventually sets Points::LeakingComposite::PumpForce
					- @ power state changes: emit event, for continuous sound - exactly like ShipSound
						- Need object ID
			- Ship::UpdateWaterIntake()
				- NewWater = <normal is_leaking water, i.e. of StructuralLeak> // before capping
				             + (TODO:REVISIT...) max(
							max(PumpForce * (ext.w - p.w), 0)
							max(-PumpForce * p.w, 0)
					     )
			- Update materials template

	- Flood doors (*)
		- Spec:		
			- New electrical element
			- Point that flood door is attached to may or may not be leaking
			- When powered, inverts water permeability of all attached springs
				- TODO: always on/always off - needed or may just flip structural's?
			- Plays one-shot sound @ when open or closed - much like TimerBomb's defuse
				+ No ObjectID needed thus
				- Open sound, Close sound
		- Impl:
			- TODOHERE
			- ElectricalElements::Update():
				- For each flood door element (own separate list, for perf):
					- Run state machine (including eventual lead-in/lead-out's)
					- @ state changes:
						- For all connected springs: Set(Current)WaterPermeability(idx, val)
							- val depends on connectivity state and MaterialWaterPermeability
						- Anything else? See water momenta algo
			+ No real need to also change Point::Buoyancy
			+ No real need to also change Point::IsHull
				+ Points' hullness is only used to decide whether or not to make a point Leak when an attached spring breaks; we
				  leave this determined by underlying structural material
			+ Springs::IsHull should be gone by now

	- Logic Gates
		- New ElectricalMaterial type
		- ...to be worked on...

	- Test:
		- Self-adjustment of kSpring and kDamp based off paper's formula (H and L bounds)
		- Debug to see if bounds ever exceeded

	- Frontier:
		- Only for non-rope points - rope points never take part in frontier
		- Preliminaries:
			- Make sure endpoints in triangle are always in CW order
			- Problem with rendering frontier in "Render Frontier" mode:
				- In order to correctly draw dangling (i.e. same connected component) parts on top of all of the connected component's 
				  frontiers, we'd need to have the dangling parts disconnected from the connected component, which means that we should
				  not follow ropes _at_all_ (no matter the transition type) during connected component detection, and allow those 
				  ropes to belong to the next connected component
					- Still vulnerable to dangling parts not connected via ropes (e.g. masts) though: 
					  frontier would still be drawn on top of it
				- Might get away with drawing frontiers - *enlarged* - before all of the rest? What is left of the enlarged part 
				  would be the rendered frontier, as it would be visible only around external frontiers (and through holes)
				- TODO: isn't this taken care of by Z work?
		- Plan:
			- Data structures
			- Initial frontiers at ShipBuilder
			- Render frontiers: 
				- New render setting
				- New ship upload 
				- New shader (red/green/etc. with 0.5 alpha, thick line width)
			- Maintain at destroy
			- Maintain at repair
		- Impl:
			- Data structures
			- Jumpstart algo:
				-	5	6	7
					4	*	0
					3	2	1
				- For each scan line:
					- For each flip point (0->1 or 1->0) from left p0 such that p0 does not belong to any frontiers:
						- fId = new frontier ID
						- p = p0; k = 4|0 (depending on flip type)
						- do:
							- Find p' from k+1 to k-1 (CW, %8)
								- If not found: it's an isolated point, go to next flip
							- Lookup <p, p'> in edge map
								- edge map is a purpose-built map, with <p, p'> being a lexicographically ordered key
								- assert is found, unless this is a "pure spring"
							- Make edge belong to frontier fId
							- if p' == p0: break
						- continue to next flip point on same scan line
			- Maintenance at destroy:
				- TODO
			- Maintenance at repair:
				- TODO
		- Cleanups:
			- Revisit need to have SuperTriangles and SubSprings (which are only used for old 'edge' spring detection?), as we might 
			  now use edges - as long as springs remember their edges
				- If so, we could now only upload springs that have 0 or 1 edges
		- Enabled features:
			- Waves: 
				- Generate wave (change height) when frontier (points) touch water for the first time
			- Water drag 
				- The one already there assumes velocity always normal to surface, but we should consider surface normal instead
				- Should also consider normal to surface of ocean, so if two surfaces intersect, we get
				  momentum from waves to ship
				- The new directional drag should make parts of the ship break off
			- External water pressure should inflict stress on springs
				- Have to visit frontier points and, if underwater, do force perpendicular towards interior


		- TODOOLD
		- Realize that a node can belong to up to 4 frontiers (center of 4 holes)
			- And a point deletion might cause a merge of the four
		- Frontier is set of points, marked as frontier, and connected to each other via 
		  nextInFrontier * and prevInFrontier * (in CW order) 
		- Algo:
			- There are multiple frontiers, 0 is external, N is internal, isolated
			- Calculate frontier at ship create, based off structural matrix, using geometry
			- At each point deletion:
				- 2 cases: OR: only later check if one of the connected points is already a frontier 
				  (a deleted frontier point is bound to be connected to two other points of the same frontier, for each frontier)
					- Point deleted is a frontier point:
						- TODO
					- Point deleted is NOT a frontier point:
						- All its connected points become a frontier
						- If one of the connected points is already a frontier, then the new frontier points
						  take that frontierId
						- TODO
	
	- Punch tool: interacts with frontier, just like a punch
		- Requires frontier work first

	- Stars with database
		- python script to generate binary maps for N and S emispheres

	- Random noise that lowers strength to inject "cracks" when the ship is under stress
		- Random walk across pairs of points on opposide sides of ships

	- Torpedoes and missiles
		- "You place one down and click where it speeds off to and explodes at. Basically a moving bomb that explodes 
		   when it reaches a destination, be that under water, or on the water."
		- "Missiles: like before, but above water"
		- Requires collision detection
		- Might either have own propulsion or follow a vector specified with click-and-drag
		- Also other objects might be launched with click-and-drag

	- Ripple: "basically you click and hold somewhere on the ship, and when you let go, it sends a ripple into the ship, weak points might tear,
	  or start getting damaged, etc."

	- Ocean waves:
		- Add somehow waves to SWE height field, rather than "fake" superimposition of sins over SWE's height field

- Game Interactions and Controls:

	- .shp file allows for overriding/addition of materials

	- Interior layer (multiple textures):
		- NOTE: not really useful as normally different textures require different structures
		- JSON: texture is optionally an array
		- ShipDefinition: texture is vector
			- Always non-empty
		- GameEventHandler::OnShipLoaded tells how many textures
		- MainFrame menu item: "Toggle Ship Layer"
			- Initially disabled
		- MainFrame @ OnShipLoaded enables/disables menu item based on whether at least 1 ship has > 1 textures
			- Stores count of textures as well
		- ShipRenderContext has array of textures
		- RenderContext->ShipRenderContext::ToggleShipTexture(int advance)
			- ShipRenderContext swaps textures
		- Merge multi-layered ships
		- Test
		- How to Guide

- UI:

	- Customizable key bindings for settings

	- Ship descriptions: use Mike's drawings

	- ShipLoadDialog:
		- Ship preview database/cache
		- Move most used ships at top
			- Need "view selector": Alphabetically (like now), Most Recent (the new one)

- Sounds:

	- Sounds playable by user via key
		- Bell, horn, etc.
		- Office TimCan provides the sounds
	- Ship may come with custom sound(s) for horns
		- Figure out how to play them, may be like switchboard or *via* switchboard, or with just one horn sound
		- Ships could also come with their own sounds; if not, default seounds are provided


	- Sounds that play before ship starts sinking
		- SOS, bell, sailor screaming, etc.
		- Office TimCan provides the sounds

	- Morse code sound when it's about to sink (early sink detection)
		- Or at first drop of water
		- Morse code: text-to-morse encoder would be cool
			- Default "S.O.S.", also customizable via ship property

	- Do air bubbles sounds, very low volume
		- At creation and at expiry
		- New events at IGameEventHandler
			- Dispatcher aggregates with counter
			- Ship takes shared_ptr<Dispatcher> now, for perf

	- New sounds:
		- Ship sinking: https://www.youtube.com/watch?v=-f2B_bzcgV8
		- ShipSoundsForFS (in Scratch)

	- Volume of effects should depend on distance/zoom

	- Global mute setting

-Probing:
	- IProbe:
		- World and Ship take shared_ptr<IProbe> and store it, exactly like IGameEventHandler
		- Single instance of IProbe is ProbePanel, which is given to GameController::cctor by Frame at initialization
		- Example IProbe methods:
			- void ProbeWaterSplashed(float waterSplashed)
				- One scalar, pass through to ScalarTimeSeriesProbeControl (iff IsActive)
			- void ProbePointForces(vec2f const *)
				- For other things at different steps in the simulation algorithm
				- IProbe knows whether it cares about a specific point and, if so, takes that and draw is
				- IProbe might also create stats
	= ProbePanel
		+ Pre-created member of MainFrame
		+ Then exposes Update() invoked by MainFrame, always, after simulation step
		+ Update(): 
			+ if not visible, return;
			+ Draw current Statistics from current StatisticsProbe
		- TBD: mechanism to select point, etc. from ship, which will be used for probing afterwards
	- Histograms:
		- class Histogram
			- map<float, float in [0,1]>
		- class Statistics (various Histograms, etc.)
			- Histogram pointWaterHistogram
			- ...

- Resource Packs

	- Resource pack contains:
		- Subset of textures
		- Subset of shaders
		- Subset of settings
		- Subset of materials, and new materials
	- Impl:
		- Data\Resources\{Default, <Pack name>}\
			- Textures\
			- Shaders\
			- settings.json
			- materials_structural.json
			- materials_electrical.json
			- metadata.json
				- author, description, name
			- Misc\
				- For ocean bumps
		- ResourceLoader:
			- Static methods only for default paths
				- e.g.: GetDefaultTextureDatabaseFilepath()
			- 1 static method to get list of non-default ResourcePackMetadata's 
			- cctor takes optional pack name
			- Instance methods for *optional* pack-override paths
				- e.g.: GetOverrideTextureDatabaseFilepath()
			- Each "DB"'s Create(...) takes a ResourceLoader const &
				- Own responsibility to check if override exists and, if so, to load override and reconciliate
			- No more methods that load DB's
		- Switching:
			- Ad-hoc MainFrame dialog showing ResourcePackMetadata's 
				- Chosen one goes to UIPreferencesManager
				- Checkbox for "Set as default" => UIPreferencesManager::Save()
				- At Save, before saving - notify that a reload is necessary

- Multiple ships:
	- Better done after collision detection
	- When ship loaded (added):
		- World adds it not to mShips, but as opt<Ship> mPendingShip
			- Not considered in Update(), but considered in Render()
		- MainFrame begins new PendingShipPlace tool
			- OnMouseMove: tell GameController (->World) mouse position as GameController::MovePendingShipTo(screen coords)
				- Ship::MoveTo(world x, y): 
					- Moves all Points by (x,y)-mCurrentRepresentativePosition
						- Ship::mCurrentRepresentativePosition (init'd as {0,0}) tracks current "center"
					- mCurrentRepresentativePosition = (x,y)
			- OnLDown:
				- Tell GameController (DropPendingShip(x, y)) which:
					- Tells World via World::DropPendingShip(x, y):
						- Final Ship::MoveTo()
						- Move ship from mPendingShip into mShips
					- Fires IGameEventHandler::OnPendingShipPlaced(shipId)
						- EventTicker: say this and other Reset/Load
						- SoundController: play sound
				- Stop PendingShipPlace tool

- Passengers:
	- Ship has number of passengers
		- "like how many people would be aboard & as the ship sinks it like shows how many people are alive, escaped via life boat or died"
		- Maybe a life count? like you have sorta a life count on the top right of the screen that says Alive: number. Dead: Number. 
		  And as the ship is sinking you press a button like say A (abandon) for example and people will start heading to the life boats 
		  to survive. The counter will stop once the ship is fully under the surface of the ocean or the entire boat deck is under water. 
		  The boat deck would be highlighted sorta like how the light system works.

	- Moving passengers
		- Separate layer provides floors, ladders, and obstacles
		- Can get away at beginning with pacman-like figures
		- For more realistic version:
			- Skeleton with 10 parts (8 limbs, body, head)
			- Need to make these actions:
				- Walk
				- Fall
				- Climb
				- Swim

- Collision detection - for multiple ships
	- Nearest neighbor: http://www.cs.umd.edu/~mount/ANN/

==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==== DONE
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================

+ Build glfw yourself
	+ clone from git
	+ build
	+ fix Ship's CMake
		+ C:\Users\Neurodancer\source\build\glfw\src\Release
+ move to source/build:
	+ ShipSandbox

IF WX:
+ build WX (Debug, Release)
+ add WX to CMakeFiles.txt
	C:\Users\Neurodancer\source\repos\wxWidgets\include
	C:\Users\Neurodancer\source\repos\wxWidgets\lib\vc_x64_lib
		names: wxmsw31u[d]_core.lib wxbase31u[d].lib
+ remove titanicapp.*, titanicmain.* from CMakeFiles.txt
+ do a simple main with wx
+ rebuild WX with C++ Runtime being statically linked
+ test
+ see getting rid of whole wx.h and only include wxwindow
+ get rid of GLFW in all source files
+ setup CMakeFiles.txt: Remove GLFW
+ resuscitate old code, merging it with new existing structure:
	+ mainApp - mainApp class, main #define
	+ mainFrame - entire frame
+ test	
+ remove titanicapp.*, titanicmain.*, main_old.cpp
+ one-shot timer
+ nuke GLFW from hard disk (repo, build)
+ add logger and fix missing ship

+ Get perf baseline and start Readme.md and Changes.tx
===========
+ cherry-pick that typo fix
+ logging window: try http://docs.wxwidgets.org/3.0/classwx_text_ctrl.html
+ rename members of Frame, cleanup code

+ Render/Game"Settings" -> "Parameters"
+ LoggingWindow -> "Dialog"

+ SettingsDialog:
	+ Add spacing
	+ Taller sliders
	+ Min and Max
	+ add textboxes 4 vals
	+ ApplySettings()
		+ GameController takes (& gives) absolute vals, & provides GetXMax/MinValue() (from YYYParameters)
		+ Helper funcs in SettingsDialog do conversions
	+ ReadSettings()
	+ Other controls for other settings
	+ rename members, cleanup code

+ MainFrame:
	+ LogWindow bug when minimizing and maximizing main frame
	+ Do we need mMainGLCanvas and context to be unique_ptr's?
	+ Render once @ beginning
		+ Check if OnPaint is the right one
	+ Maximize
	+ ReloadLastSelected
	+ See if canvas.setcontext is necessary
		+ Watch out for resize
	+ +/- for zoom *IN MENU*
		+ remove wxEVT_CHAR_HOOK at panel and use menu hotkey and event instead

+ Investigate dirty lines

+ Use own exception

+ Fix DestroyAt
	+ Add DestroyRadius to GameParameters (not in SettingsDialog yet)

+ Fix final destroyer

+ Setup UnitTests
	+ Build GTest Debug and Release
	+ Create UnitTests project in CMake
	+ First unit test: vectors

+ GameException: cctor with string
	+ Utils::Convert(string)->wstring

+ Rebuild Devil but make it a dll with static runtime
+ Move DevIL init to GameController
	+ No DevIL dep's in ShipSandbox
	+ DevIL_INCLUDEs from GameLib are not public

+ Move to picojson
	+ Nuke SDK
	+ Remove public-ness of JSonCPP

+ Settings: 
	+ Destroy Radius
	+ "World"XYZ if really it is world

+ Frustum? For 2D? Try Ortho?

+ Change MainFrame's build info
	+ separate Version.h

+ Mask with copyright at all source files (copy from XXmain)
	+ Already capitalized
	+ Those to be capitalized
		+ material
			+ Rename
			+ cctors:
				+ from picojson obj
			+ Create()->UQ_PTR
				+ private cctor
				+ all members const
			+ optional Material::ElectricalProperties
		+ Also Renderer becomes a namespace, not a class
		+ render
			+ Renderer
			+ move ScreenToWorld here
			+ All static methods, inline
		+ util
		+ phys: 
			+ Rename as Ship, World, Point, etc.
			+ TODO: see first if can split into separate files
				+ commit & push first
				+ cpp's in namespace
				+ Physics.h: includes all and each .h and .cpp includes Physics.h 
			+ Private vs Public attributes:
				+ No friends
				+ All members mPrivate
				+ All getters and setters (when needed)
		+ vec

+ Simulation Optimizations:
	+ Move back to baseline
	+ Take profile X 2
	+ set these flags and see impact (on Release)
		+ Ox
		+ fp:fast
	+ Flags for non-MSVC:
				<Compiler>
					<Add option="-O3" />
					<Add option="-ffast-math" />
					<Add option="-fno-math-errno" />
					<Add option="-funsafe-math-optimizations" />
					<Add option="-ffinite-math-only" />
					<Add option="-fno-trapping-math" />
				</Compiler>
	+ Make all render() const
	+ Make all render() inline
	+ Make all vector funcs inline in .h
	+ Take full baseline first
	+ FPS: 17.3/17.7
	+ We don't need redundant triangles
		+ Row visit: for each point *after* the very first of a streak, only do triangles up to 90 degrees
			+ But keep doing all springs
			+ use boolean isInShip, init=false, set to true at end of single-point processing if point exists and set to false otherwise
		+ Before: 5231 points, 19932 springs, 19569 triangles
		+ After: 5231 points, 19932 springs, 9819 triangles
	+ FPS: 19.2/19.3
	+ Fix division by zero
		+ Do fix
	+ FPS: 19.1
	+ SSE2:
		+ Test first: Integrate: 
			+ 1a: pack Pos, Vel, Force from 2 points into local vec4f
				+ For loop with two points at a time
			+ 1b: create buffers with all Pos, Vel, Forces, and call function with restricted pointers: IT USES PACKED SSE's!
		+ Undo
	+ Vertex cache optimizations with Forsyth's algo:
		+ Break out ShipBuilder, friend
		+ Use own LRU cache and calculate current ACMR for triangles and springs
			+ Spring ACMR: 0.516807
			+ Triangle ACMR: 1.01986
		+ Do triangle vertex cache optimization
			+ New ACMR: 0.68174
			+ FPS improvement: 19.1 -> 19.0
			+ Check if self-covering within same connected component now looks weird
			+ Test on samsung: 18.5/18.8 -> 18.5/18.6/18.8/19.0
			+ REVERT, IT'S (MARGINALLY) WORSE!
		+ Do spring vertex cache optimization
			+ New ACMR: 0.325156
			+ New FPS: 19.4/19.7
	+ FPS: 19.3/19.5
	+ ShipRendering: upload triangles, ropes, springs only when they change
		+ Have VBOs per connected component
	+ FPS: 19.0/19.4/19.7/19.9
	+ Point & Spring Destructuring:
		+ Starting FPS: 19.0/19.4/19.7/19.9
		+ Main goal: improve cache locality
		+ Secondary goal: make vectorization-friendly
		+ Replace Point, Spring, Triangle with Points, Springs, Triangles
			+ Base is ElementContainer
				+ Defines aliases (ElementCount, ElementIndex) - uint32
				+ ElementCount GetCount() const
					- Number of elements
					- passed at cctor
			+ They contain N buffers:
				+ Points: Position, Velocity, Force, MassFactor, Color, Water, IsDeleted ...
					+ All scalars of a point that are only used for both x and y (e.g. MassFactor) are stored 
					 (and updated, if any) twice, as vec2f (only MassFactor?)
					+ All scalars of a point that are used as scalars (e.g. Buoyancy) are stored once
					+ Test first to see if N buffers make a difference vs 1 larger buffer: 
						+ 1: Do Position, Velocity, Force, and MassFactors first in single Newtonz buffer
							+ Get baseline 1:
								- DoStep: 39.99%
									- Ship::Update: 39.05%
										- UpdateDynamics: 27.42%
											- SpringForces: 20.18%
											- PointForces: 3.77%
											- CollisionsWithSeaFloor: 2.19%
											- Integrate: 1.27%
										- GravitateWater: 5.70%
										- BalancePressure: 4.58%
										- UpdateStrain: 1.03%
								- Render: 51.69%
							+ FPS=24.0/24.2/24.4
						+ 2: Do separate Position, Velocity, Force, and MassFactors 
							+ Get baseline 2:
								- DoStep: 39.01%
									- Ship::Update: 38.01%
										- UpdateDynamics: 27.44%
											- SpringForces: 19.97%
											- PointForces: 3.65%
											- CollisionsWithSeaFloor: 2.24%
											- Integrate: 1.57%
										- GravitateWater: 4.87%
										- BalancePressure: 4.51%
										- UpdateStrain: 0.90%
								- Render: 52.69%
							+ FPS=24.1/24.3/24.7/25.0
							+ Make buffer __restrict
							+ FPS=24.8/24.9/25.1
					+ If makes sense to explode:
						+ Also explode ConnectedComponent
				+ Phase 2: Springs: Points, dynamics coefficients, water coefficients, ...					
				+ Phase 2: Triangles: Points, Network
				+ Phase 2: Change all ElementContainer::ElementIndex into ElementIndex
				+ Structure of buffers:
					+ For SSE2, need to be simple floats
					+ For handling, need to be structured
				+ Buffers are class Buffer
					+ Need to be mem-aligned
					+ cctor(size)
					+ data()/size()/emplace_back()
					+ uq_ptr
			+ They expose buffer getters for each buffer (as the structured type, e.g. vec2f *, or PointNetwork *, or float * for lonely scalars)
				+ e.g. vec2f* GetPositionBuffer()
				+ When needed also exposed as floats as well (e.g. Position, for Integrate())
					+ e.g. float* GetPositionBufferAsFloat()
					+ size math left to caller
			+ When needed, they expose getters and generally operations on single elements, via 32-bit index argument (aliased as ElementIndex)
				+ e.g. void Destroy(ElementIndex)
				+ e.g. float GetMass(ElementIndex)
			+ Destroy(ElementIndex) takes care of telling ship that element count is dirty
				+ Phase 3: set directly in Ship at initiation of Destroy chain, whenever we know we destroy something
					+ Do at Spring::UpdateStrain: returns bool, true if destroyed
					+ Do at tool's Destroy
					+ Then get rid of two-phase ship cctor - plain cctor with moved ElementRepo's
						+ So can also remove move assignment at Points
			+ Pointers to points are replaced by 32-bit indices
				+ Funcs that need to follow pointers (e.g. Destroy() and SpringDynamics()) also must take whole containers 
				+ Phase 2: also pointers to Springs & Triangles
			+ ShipBuilder creates Points & moves into ship
				+ Points' ConnectedXYZ are updated at ShipBuilder time
					+ Remove code from Spring and Triangle and ElectricalElement-Cable-etc. cctors
			+ Do Ship
				+ Loop over indices, invoking Points::GetWhatever(index)
			+ End of Phase 1: FPS=22.0/22.3/22.6
			+ Phase 1.5: check assembly for:
				+ 1: loop over indices, invoking Points::GetWhatever(index)
				+ 2: loop over indices, taking buffers first and then dereferencing buffer with index
				+ RESULT: IDENTICAL
				+ Decide whether to keep bunch of GetWhatever(index) (both R and W) vs buffers
				+ Check also disassembly of index iterator
			+ End of Phase 1.5: FPS=23.2/23.3/23.4
			+ To check:
				+ UpdateDrawForces: see assembly difference for displacement.length() optimization
					+ NO, actually compiler autonomously saves length for later, and explicit
					  code looks a bit different
				+ UpdateSpringForces(): see assembly to check whether point.Force's are updated twice
					+ YES
					+ Update force once with sum of forces
				+ HandleCollisionsWithSeaFloor(): see assembly to check for twice GetPosition()
					+ YES, read once into xmm4 and re-used later
			+ End of checks after Phase 1.5: FPS=24.0/24.2/24.4
			+ Containers expose own Upload(RenderContext &)
				+ Phase 3: direct upload of buffers into GPU via RenderContext
					+ Nuke ShipRenderContext::mPointBuffer & friends
				+ Phase 3: move texture coordinates and colors into Points, which uploads
				  at Upload() via own mAreImmutablePropertiesUploaded state
					+ Nuke Ship::mIsPointCountDirty
					+ Nuke ElementRepository, as at this moment no one should be using it anymore
			+ Phase 3: Nuke PointerContainer
			+ Phase 3: Nuke ShipElement, if it's now only implemented by ElectricalElement
				+ See if managed to not need to tell Ship as well, see above
			+ Phase 3:
				+ Fix power-of-2 calculation at Buffer::cctor()
				+ Fix World::GetNearestPointIndexAt, by making use of Ship::GetPointPosition(idx)
					+ See square root optimization, here and @ Destroy()
				+ Also fix its use at MainFrame, by making use of Ship::GetStuff()
				+ Fix all warnings
		+ Phase 2: Integrate():
			+ After NewtonzBuffer exploded
			+ Test 1: use Points.GetWhatever(idx)
			+ FPS=24.7/24.8/25.0
			+ Test 2: use __restrict pointers
				+ Just simple 1-Point-Component loop, compiler makes times four
				+ Pointers are locally declared as __restrict, and adjusts count (i.e. times 2) and uses
				  indices in pointers
				+ Verify assembly
			+ FPS=24.9/25.1/25.2
		+ Phase 1:
			+ Beginning FPS=19.0/19.4/19.7/19.9
			+ Ending FPS=22.0/22.3/22.6
		+ Phase 1.5:
			+ Beginning FPS=22.0/22.3/22.6
			+ Ending FPS=24.0/24.2/24.4
		+ Phase 2:
			+ Beginning FPS=24.0/24.2/24.4
			+ After exploded Newtonz FPS=24.8/24.9/25.1
			+ Ending FPS=26.3/26.5
		+ Phase 3:
			+ Beginning FPS=26.3/26.5
			+ Ending FPS=26.6/26.8/26.9/27.0
	+ BufferAllocator<Type:vec2f or float>
		+ cctor takes ElementCount
		+ Allocate() returns std::unique_ptr<Buffer<Type>>, with deleter invoking mAllocator->Release(Buffer<type>*)
		+ Points::CheckoutWaterBufferTmp (as "AllocateWaterBufferCopy()") borrows one, copies it in, and returns it as std::unique_ptr<Buffer<float>>
		+ Opposite for Commit() (as "UpdateWaterBuffer")
	+ Points::ConnectedSprings is of struct { SpringIndex, OtherEndpointIndex }
		+ No two separate buffers, as we seldom (if not neveer) need them separate
		+ Init's @ShipBuilder or at whoever populates it now
		+ Maintained at SpringDestroyHandler
		+ Used at:
			+ ConnectedComponentDetection
			+ UpdateWaterVelocities
	+ Water and Land interpolations:
		+ Prepare first test bench (noinline)
			+ GetWaterHeight: 2.23%
			+ GetFloorHeight: 1.66%
			+ Save assembly
		+ 1: see if it's better to store delta's and/or other pre-calculated things
		+ 2: see if can do semi-integer x-axis interpolation
			+ GetWaterHeight: 1.25%
			+ GetFloorHeight: 0.77%
		+ Cleanup test bench
		+ Final functional test
		+ Final FPS test
	+ See if can avoid other IsDeleted checks, via zero'ing of coefficients
		+ UpdateSpringForces()
	+ Retry cache layout optimization, new strategy:
		+ Starting point:
			! ReorderSpringsOptimally_Tiling<2>
			! ReorderPointsOptimally_FollowingSprings
			! No Triangles reordering
			+ ACMR: 0.516807 ->  0.389524
			+ FPS: 28.5/28.8
		+ 1:
			+ Points in 2x2 blocks (with any point optional), advancing one column - and then row - at a time
			+ Springs in those 2x2 blocks, advancing one column - and then row - at a time
			+ ACMR: 0.516807 ->  0.508228
		+ 2:
			+ Do w/vertical streak of 2,3,4,5,6,7,8
			+ ACMR: 
				+ Tiling<2>: FPS: 28.5 U/R: 213
				+ 2: 0.516807 -> 0.515553 FPS: 28.6  U/R: 210
				+ 3: 0.516807 -> 0.388722 FPS: 28.6  U/R: 213
				+ 4: 0.516807 -> 0.345725 FPS: 28.6  U/R: 213
				+ 5: 0.516807 -> 0.325507 FPS: 28.6  U/R: 213
				+ 6: 0.516807 -> 0.313153 FPS: TODO  U/R: 213
				- 7: 0.516807 -> 0.307245 FPS: TODO  U/R: TODO
				+ 8: 0.516807 -> 0.300773 FPS: 28.6  U/R: 210/215
		+ 3: Do final check w/Forsyth's triangles optimization
			+ FPS: 28.1 U/R: 206
		+ Triangles: optimize reuse of 2 vertices
			+ Starting ACMR: 1.01986 VMR: 0.49888
			+ Ending ACMR: 1.00672 VMR: 0.101436
			+ Test to decide whether to keep or not: NO KEEP
	+ Lights perf improvement
		+ Start: FPS=9.9 U/R=508/510 (Dorik 2)
		+ 1: Add IsLegacyElectrical to structural materials
		+ 2: Make spread linear, == max distance
			+ Update materials' DB
			+ Remove mapping and take spread as-is
		+ 3: Adjust spread adjustment:
			+ Min/Max = 0.0/20.0, linear
		+ 4: Adjust luminiscence adjustment:
			+ Min/Max = 0.0/4.0, exp
		+ Now: FPS=13.4 U/R=335/342
		+ 6: Invert loop and optimize
		+ Now: FPS=15.8 U/R=272
		+ 7: Vectorize
			+ Make unit tests
			+ Make benchmark
			+ Test if pointLight can be clipped to 1.0 (NO)
			+ Vectorize
				+ See why unaligned instructions (e.g. movups) are generated
				+ Check whole assembly

				DiffuseLight_Naive/1           1308910 ns    1195730 ns        561

				DiffuseLight_Naive/4           2055317 ns    2043863 ns        374
				DiffuseLight_Naive/8           3586917 ns    3441199 ns        204
				DiffuseLight_Naive/16          7220152 ns    6964330 ns        112
				DiffuseLight_Naive/32         16417383 ns   15912102 ns         50
				DiffuseLight_Naive/128        98089663 ns   91372014 ns          7

				DiffuseLight_Vectorized/4      1710142 ns    1605893 ns        408
				DiffuseLight_Vectorized/8      2995209 ns    2944597 ns        249
				DiffuseLight_Vectorized/16     5288064 ns    5304034 ns        100
				DiffuseLight_Vectorized/32    10752535 ns    9984064 ns         75
				DiffuseLight_Vectorized/128   39420602 ns   37623771 ns         17

		+ Ship: pad lamps to multiples of element count, and make all buffers aligned			
			+ For now just dynamically
		+ Now: FPS=17.7 U/R=230
		+ Commit
		+ ElectricalElements: precalc lamp buffers and maintain w/GameParameters' changes
			+ Store initial GameParameters at cctor
			+ Calc values at Add()
			+ Recalc values at UpdateForGameParameters
		+ Now: FPS=18 U/R=222
		+ Try with exploding lamp's positions into x & y
			+ Algorithm
			+ @ UnitTests
			+ @ Benchmarks
			+ Run new benchmarks

				DiffuseLight_Naive/1          21471036 ns   12792082 ns

				DiffuseLight_Naive/4          20730892 ns   19165837 ns
				DiffuseLight_Naive/8          36127342 ns   34171648 ns
				DiffuseLight_Naive/16         70868391 ns   67600433 ns
				DiffuseLight_Naive/32        158081461 ns  156001000 ns
				DiffuseLight_Naive/128      1009125502 ns  936006000 ns

				DiffuseLight_Vectorized/4     16869165 ns   16361080 ns
				DiffuseLight_Vectorized/8     29228165 ns   28363818 ns
				DiffuseLight_Vectorized/16    54706011 ns   49636682 ns
				DiffuseLight_Vectorized/32   107635537 ns  101400650 ns          
				DiffuseLight_Vectorized/128  413520040 ns  382202450 ns

			+ @ Ship
			+ Decide whether to keep or not
		+ Decide whether Ship should use a threshold to switch between vectorized and naive algo
			+ 1 naive is better than 4 vectorized, 2 naives are already worse
			+ Just one lamp is not worth optimizing for
		+ Disable whole diffusion when luminiscence adjust is zero
			+ Requires "current" member at Ship
		+ Run in Debug
		+ Now: FPS=18.1 U/R=235
		+ Update changes.txt
	+ Forces rearc:
		! Rationale: multiple spring iterations are really artificial; in reality, changes due to spring position changes in-between 
		  iterations shouldn't impact physical world (e.g. buoyancy/drag) yet
			! So we may calculate point forces once and for all, assuming points' dynamics stay constant during spring relaxation
		+ Verify that the reason two separate integrations explode is because of velocity
		+ Split spring forces and point forces, achieving equivalence
		+ 1) Change integration scheme:
			! So that position-based spring relaxation does not require extra semi/integration steps
			+ P(t+1) = P(t) + SpringForcesDeltaPos + WorldForcesDeltaPos + V(t)*dt
			+ V(t+1) = (P(t+1) - P(t))/dt = V(t) + (SpringForcesDeltaPos + WorldForcesDeltaPos)/dt
			+ Verify equivalent
		+ 2) All non-spring forces calculated once, outside of loop
			! Assumption: no deletions take place during mech loop
			+ Points has two Force buffers: SpringForces and NonSpringForces
				! Only temporarily, until position-based springs are done
			+ Verify equivalence
			+ Move forces' application out
			+ Do not reset forces at integrate
			+ Zero forces after loop
				+ Check assembly
			+ See issue @ y=518.0, force = 1*e-06
			+ Test L'n'F'
		X 3) Spring relaxation based on position rather than forces
			X 1) Integrate inline (multipy sum of forces by point's integration coeff) and update positions
				+ Get rid of spring integration in iterations loop
				X !!! Test !!! SUCKS!
				+ See if need to also update velocities because they're needed (updated) for damping
			X Get rid of two force buffers and go back to one single "Force" buffer
			X 2) Incorporate particles' integration coefficients into springs' stiffness and damping coefficients, using 
			     temporary IntegrationFactors buffer
				- Need pre-step before loop
				- Buffer alloc'd via Springs::AllocWorkBufferEtc.()
				- Populate inline				
				- Test				
		+ Finalize dual force buffer
			+ Methods and names
			+ Integration
		+ Test
		+ Finalization:
			+ Verify integration assembly
			+ Verify Points::UpdateMasses assembly
			X See if multiple relax iterations (nested) improve cheaply rigidity
				X Maintain all params the same (e.g. dt)			
			X Experiment with different spring coeffs
				+ First, do all calculations in RelaxSprings, ignore coeffs for now
				+ Experiment with SpringReductionFraction set to 0.8 or 1.0			
			+ Optimize spring relaxation assembly
				! Assembly inspection-driven
				! Not sse yet
				+ Start: 20.6-21.6ms, 31.80-32.10fps
				+ a) Add Hooke's and damping scalars and multiply only once with springDir
				+ Perf: 18.9, 33.7 | 18.5, 34.2 | 18.3, 34.5					
				+ Do vector normalization in SSE
					+ Benchmark: copy vector from vector
					+ Unit Tests					
					+ Integrate in Algorithms->Vectors
						+ Algorithms becomes templated on TVector
						+ Unit Tests
						+ Benchmark
				X Perf: 19.2, 33.6 % 
				X Rollout spring loop
				+ restrict spring buffers 
				+ Perf: 18.2, 34.5
				+ restrict point buffers
				+ Perf: 17.7, 35.21 (| 18.0, 34.8 | 18.1, 34.7)
			X See if it's faster to not reset forces at Integrate, but in a separate fill call
				+ Perf: 18.4
			+ Get rid of force fields and apply forces directly instead of queing force fields
				+ Ship_ForceFields: ApplyXYZ(.....)
				+ Test all manners of injecting force fields:
					+ Draw & Swirl
					+ Bomb blast
						+ Radius: 1.5
						+ Heat: 100K
					+ AM: pre-implosion, implosion, explosion
				+ Test perf improvement with many AM bombs
			+ See if HandleCollisionsWithSeaFloor may be also done once
				+ Perf before: 17.8/34.9, 17.5/35.4
				+ When sampling sea floor, clamp x
					+ OceanFloor: make sure we can ask for the derivative at x=MaxWorldWidth				
				+ Take position snapshot before loop, and use it to calc 'before' position and effective velocity 
				  when dealing with collision
					+ Do successive divisions of before->after segment to get closer to surface
					+ Add OceanFloor elasticity and friction
						+ New GameParameters
						+ Also at SettingsDialog
						+ Normal response: Vn' = -eVn (e = elasticity, [0.0 - 1.0])
						+ Tangential response: Vt' = aVt (a = friction, [0.0 - 1.0])
				X Does not work, dt is too large
				+ Just test friction and elasticity
				+ See if it's x-clamping that made 17.5ms go to 18.5
				+ Add friction and elasticity to changes
			+ Remove clamp at ocean floor and ocean surface
				+ Perf before: 18.5/34.3
				+ Test SEE clamp
					+ Test, including assembly
					+ See perf
				+ Optimize calculation of anti-normal
					+ Test
				+ Re-check world trimming and confirm it does what's expected
				+ Clamp at Repair when changing positions
				+ Do
				+ Perf after: 18.3/34.5 - 17.9/34.9
			+ World bounds: find right point to move back to
			X Spring relaxation: see if perf improves with loop by points, rather than by springs
				X First iteration: sucks
				+ Finalize isAtOwner (see below), change temporarily spring relaxation call, and commit
					+ Revert spring relaxation call
				+ Change spring loop to be unilateral, but still with forces
					+ Just to verify loop structure
				X Try with Gauss-Seidel and (yes/no) spring force integration in loop as well					
					+ Fix world forces - reistate integration but only for world
						+ Loop:
							+ Make copy of positions
							+ Make copy of vels
							+ Do spring loop:
								+ For each point:
									+ For each spring: sum all forces
									+ Integrate force into deltaPos
									+ positionA += deltaPos
									+ velocityA += deltaPos/dt * damp
							+ Integrate(startingPos, startingVels):
								+ Ignore vels and only use startingVels
				+ Try with full integration for each visited point
					+ Requires springs owned by point Pi to only be connected to Pj with j > i
					+ Integrate point at end of spring loop
					+ Nuke integration call
				X Finalization:
					X If we go for it:
						X See if SpringForces needed and if not, Nuke Points::SpringForces buffer and go back to single force buffer
						X Pre-integrate world force buffer before loop
					X See double-buffers to avoid integration step
					X Cleanup point integration factor buffer - make it float itself, if we really go ahead
					X Re-think connected springs structure: 
						X Incorporate coefficients 
			X Spring relaxation: see if perf improves with position and velocity and spring force in the same buffer
				+ Perf before: 18.08/34.6 18.5/34.3
				+ position vec2f, velocity vec2f, spring force vec2f
					+ Struct at points, with methods for interleaving and de-interleaving
				+ Interleave before loop
				+ RelaxSprings
				+ Integrate
				- Collisions
				+ De-interleave after loop
				+ Perf: 18.7/34.0
			+ See if may replace spring dampers with higher global damp
				+ Add new GameParameters::GlobalDampAdjust
				+ SettingsDialog
				X Test replacement
				! Keep setting anyway
				+ Find better formula to map adjustment
			+ Adjust:
				+ Bomb blast strength
			X Try with spring-only additional iterations
				X Test
	X Try with SpringRelaxation updating only positions
		! This was done in NewSpringRelaxation branch, but was too unstable
		+ Still runs N times, but only updates positions (does a local "integration" based on "forces")
		+ After last step, update velocity adding last step's position minus initial position
			+ Need to save position buffer first
			+ Then add the saved velocity buffer with the resultant of the velocities generated by spring relaxation, which are the 
			  resultant position delta's resulting from relaxation
		+ Test:
			+ See bounces from ocean floor
				+ The back-sending should be fine as it's based off real initial velocity TODO: double-check

+ Fix 4 BPP images
	+ Need ilCopyPixels to convert to standard format (BPP:3, Format: RGB, Type: U_BYTE)

+ Material::"Electrical" (and "Sound")
+ See if destroy's lack of point allows for water to flow in
+ FileDialog: filters based off image formats that are supported
+ Jelly ball: see orig code for doubles
+ Less ocean depth max	
+ Data/
	+ InitialShip.png [also change @ code]
	+ Materials
+ see if it makes sense that ship::points is set<x, set<y, points>>
+ nuke wxSmith
	+ Verify all is fine afterwards
+ set icon
+ Debug builds: 
	+ Enable /Fp:strict and set fpcontrol via /DFLOATING_POINT_CHECKS	
	+ See if SEH needed (/EHa)

+ Mouse pointer based off current tool
	+ Only on Canvas, normal outside
+ Move IsPaused member out of game controller & parameters; handled by MainFrame via status of mPauseMenuItem
+ DrawAt: the longer it's pressed, the stronger it gets
	+ Requires TimerTick to also update force and invoke DrawTo when l is down and current tool is Draw
	+ Also radius of Smash, same thing
+ Tool strength modulation:
	+ Also modulate cursor (red bar rising)
		+ Build 10 images (and then cursors) off the base image
		+ @ tool application, also call SetCursorStrength(strength, minStrength, maxStrength)
			+ Calculated which one of the (xyzCursors.size()-1) to set, of current tool's cursor

+ Phys rearc:
	+ Confirmed: destroy breaks due to iterator invalidation
	+ In order to allow for ship building unit tests:
		+ static unique_ptr<Ship> Ship::Create(unsigned char const * structureImageData, un_map<vec3f, Material*>)
		+ void World::AddShip(unique_ptr<Ship> && newShip)
		+ Game::LoadShip(filename) still loads the image, and then Ship::Create and World::AddShip
	+ Ship_BuildsFromStructureImage_XXX unit test:
		+ Make structureImageData and verify points, springs, triangles, etc., also indexes & relationships
			+ Might actually want Material::cctor to be public
	+ Destroy unit tests:
		+ Make structureImageData
		+ DestroyAt
		+ Verify points, springs, triangles, etc., also indexes & relationships
		+ Verify crashes in Debug!
	+ Do phys renames and file split above
	+ Verify unit tests (1) & runs normally & no fps regression
	+ Commit & push
	+ Take new perf baseline (FPS and percentages): 8/9
	+ Repository rearc:
		+ PointerContainer:
			+ Flag is via getter (IsDeleted())
				+ Also rename other GetIsXYZ() -> IsXYD() and SetXYD()
			+ RegisterDeletion(): increments counter
			+ ShrinkToFit: 
				+ Only if deletion counter != 0
				+ Allocate new and copy pointer by pointer that's not deleted
					+ assert counts at the end
				+ Fix unit tests (need to register deletion, and add case with no registration but deletion)		
		+ Replace parentWorld with parentShip at all elements
			+ See also if can get rid of accessing World altogether, in lieu of GameParameters or specific parameter(s) of it (e.g. gravity)
			+ Spring
			+ Triangle
			+ Point
		+ Physics::ShipElement<TElement>
			+ Provides IsDeleted()
			+ Has mParentShip * const (set via cctor) and getter
			+ public Destroy()
				+ mIsDeleted = true
				+ mParentShip->RegisterDestruction<TElement>((TElement *)this)
			+ Everything derives from it, publicly
		+ Ship maintains lifetime of points, springs, and triangles in backbones 
			+ Springs: PointerContainer
			+ Others: depends, if fast iterator access in arbitrary order is needed => PointerContainer,
				  else use set (even if never iterated, makes faster deletion)
			+ RegisterDestruction<TElement>(TElement *element): 
				+ For things in PointerContainer: invokes PointerContainer::RegisterDeletion()
				+ For things in sets, maps: invokes set/map.erase(element) // it's a shortcut!
					+ In these cases, mIsDeleted setting is redundant, but heh...
		+ Fix crash at Destroy
			+ Remove all TODOs
		+ Rethink pointer container: it should iterate Element* rather than Element&
		+ New FPS: 11/11/12
		+ Fix disappearing ship
			+ Make PointerContainer Log a Debug afterwards, instead of Info
			+ Nuke all the other TODO's
			+ Run with strict floating point
				+ Disable exc with overflow & verify that's how we get to NaN
		+ Commit & push
		+ See if chunk splitting reprocesses same point twice
		+ See if connected triangles (at point) should also be vector instead of set	
			+ Requires Triangle.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
		+ Test mAllTriangles in PointerContainer
			+ Should make faster render:
				+ Before: FPS with pause=18/19
				+ After: FPS with pause=19
			+ If not good, undo - KEPT!

		+ Try Adjancency rearc:
			+ Commit and push first
    			+ Each adjacency arc exists for each non-hull spring, and lives as long as the spring lives;
			  we might then get rid of these and just visit the non-hull springs,
			  provided that we adjust GravitateWater and BalancePressure for the fact that each arc 
			  would now be visited only once
			+ However, for electrical elements we still want to visit the spring-connected graph,
			  regardless of hull-ness this time;
			  we then want each point to know its N attached springs (arcs), which
			  we maintain as a vector<Spring *> (there's max 8)
				+ Actually: FixedSizeVector<TElement, Size>, w/erase that shifts and returns bool
				+ Remove: use vector::erase(std::remove(val)), or self-done for just one
				+ Adjust GravitateWater and BalancePressure for the fact that each arc 
			  		is now visited only once
					+ GravitateWater: change to visit springs, and do realize that one of the points 
					  always has cos > and the other cos <
					+ BalancePressure: for each pair in which one has water > 1.0, do delta
					+ Don't take shortcuts, and add comments about this
				+ Point: expose same API as triangles
				+ Spring:
					+ cctor adds itself to its endpoints
					+ dctor removes itself from its endpoints
					+ Make sure it's the same code as triangles
					+ Then remove code from Ship construction
				+ Replace adjacencymap visit with spring visit (of non-hull only)
				+ Remove ship.adjacencymap
				+ Requires Spring.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
			+ Then see if Point->Destroy() can avoid enumerating all springs to find the ones affected
				- Check speedup
		+ x::Destroy()  // Removes all references to self that are found in counterparties
				// Invokes Destroy() on counterparties it "owns" (e.g. Point->Spring)
				// Basically: replaces dctors (which now have to go away)
				// Then, calls base ShipElement::Destroy()
		+ At the end of each Update(), Ship calls shrink_to_fit on owned pointer container(s)
			+ Also removes points et al that were deleted on previous DestroyAt()
		+ Remember to exclude IsDeleted() things during enumerations!
			+ And assert(!IsDeleted()) when it's impossible the're deleted (e.g. if accessed via relationship that should
			  have been cut if that element was deleted)

	+ Remove TODO's from unit test and verify (2) & runs normally & no fps regression
	+ Complete unit tests with all new relationships
	+ Commit & push
	+ Take new perf baseline (FPS)
	+ Final refactor physics:
		+ No friends
		+ Clear all warnings
		+ Args by ref - no vector copies!
		+ phys getters (e.g. point.GetColour()) inline
		+ Make other inlines
		+ Fix include files	
		+ Formulas optimizations
			+ Point forces: gravity may be applied twice with different magnitude but same vector
		+ gameparams/world::(waterpressure, strength, ): are these "factors" or "global" really?
		+ See if FP:fast really makes a difference (Release only)
		+ All TODO's
	+ Commit & push
	+ Verify unit tests & runs normally & no fps regression
+ Menu entry to reset pan and zoom
+ Get rid of unicode
	+ Can, really?
+ Add splash screen

+ OpenGL Rearc:

	+ Test with no repopulating buffer
		+ Is: 54/55
		+ Vs: 54
		+ DISCARDED


	+ Finish render primitives:
		+ Water
			+ Check for blend!!!
		+ ShipPoints
		+ Springs * 2
			+ Convert to indices
			X Check control of interpolation/end vertex?
		+ DrawPoints

	+ Remove Z depth for transparent water (shader param)
		+ Menu with lambdas

	+ AmbientLight also for water and land (calcd @ color param setting)
		+ Use own AmbientLight render parameter (getter & setter) & shader parameter for water and land only
			+ MainFrame sets it based off phase, and takes it for own Point::GetColour(.)
		+ Also getters for others (separate X and Y)

	+ Code cleanup:
		+ RAII (generic)
		+ Point description routine

	+ Zoom rearc:
		+ 0 - 1000
			+ 1 is normal
			+ ---> 0: smaller
			+ ---> 1000: lerger
			+ WorldHeight == 2*70/(zoom + 0.001)

	+ Take new baseline
		+ 22/23fps for 28,000 triangles

	==================================
	Integration:
	==================================

	+ GameController owns RenderContext (as uq_ptr)
		+ GameController created by MainFrame after glContext created

	+ GameController::Get/Set<RenderParameter>(.): // Zoom, Camx-Camy, CanvasWidth-CanvasHeight, AmbientLight, booleans
		+ Set: forward to RenderContext::Set<RenderParameter>(.)
			+ ...which does changes on the fly
			+ ...and also stores those that Physics::XYZ::Render() needs for procedural and color changes
				+ e.g. booleans, exposed as GetXYZ()
			+ ...and also stores world bounding coordinates (R,L,T,B) to give to Physics::RenderWater/RenderLand()
		+ Get: forward to RenderContext::Get<RenderParameter>()
		+ Defaults: in RenderContext cctor
		+ Nuke RenderParameters

	+ GameParameters stays unchanged

	+ Physics::XYZ::Render():
		+ Takes RenderContext &
		+ When and if needed, polls RenderContext::Get<e.g. boolean or world bounding coordinates>()

	+ Screen2World and World2Screen:
		+ Calcd by RenderContext using OrthoMatrix and its inverse (or formulas if can't do with inverse)
		+ Exposed by GameController who asks RenderContext

	+ Ship::Render:
		+ First, all points, assigning RenderElementID - TEMPORARY
		+ Then, springs and/or triangles, using elements

	+ Nuke RenderUtils

	===================================
	Baseline perf of openGLTest:
	- 82,524 triangles:
		- 13/14fps
		- OnGameTimerTrigger: 86.76%
			- RenderShipTrianglesEnd: 73.67%
			- fminf: 8.18%
	- 27,324 triangles:
		- 43/44/45fps (42fps when doing full color interpolation)
		- OnGameTimerTrigger: 86.27%
			- RenderShipTrianglesEnd: 71.05%
			- fminf: 7.79%
	-----
	Vertex shader doing light and water:
	- 27,324 triangles:
		- 38/39fps
		- OnGameTimerTrigger: 85.18%
			- RenderShipTrianglesEnd: 75.24%
			- fminf: 0.0%

	Fragment shader doing light and water:
	- 27,324 triangles:
		- 35/36fps

	Elements:
	- 27,324 triangles:
		- 39/40/41fps

	Elements and light and water shading in software (still with water and light):
	- 27,324 triangles:
		- 49/50/51fps

	Elements and light and water shading in software (no more water and light):
	- 27,324 triangles:
		- 49/50/51fps

	Without ambient light re-calculations for each vertex (shader parameter):
	- 27,324 triangles:
		- 51/53fps
		- OnGameTimerTrigger: 85.84%
			- RenderShipTrianglesEnd: 76.26% [all external]
			- fminf: 1.56%
	+ See if reordering springs according to small tiles helps, instead of according to cache heuristics
		+ Visit point matrix as 2X2 blocks
		+ Add all springs connected to any of the included points (0..4 points), except for already-added ones
			+ Use vector<bool> to remember indices of springs already added
			+ Need un_map<point index->[spring index]>
				+ See if [spring index] could be member of PointInfo
			+ Done like this, it favors springs extending to the right and down
	+ Sea and Ocean Floor: take advantage of bounded-width world (*)
		+ Main concept:
			+ OceanSurface and OceanFloor contain samples for the entire width
				+ Have to find <#Samples==BufferWidth, MaxWorldWidth> pair that we are comfortable
				  with *and* which gives a good resolution
					+ Water: 
						+ Current dx = 20*pi/512 ~= 0.122m
						+ Next dx = W/S @ W=10K => ~80k samples
							+ But we ended up with 8k samples!
			+ Not anymore periodic, hence no mod anymore to get water height and ocean floor
			+ Only the number of samples dictates final definition of surface and floor
			+ Uploading is by sample (when not minifying a lot)
				+ Loop uploads S(i0+ni), with i0=left start, n depending on zoom
					+ Magnifying: n = 1, dx > 1; GPU fills-in
					+ Minifying: n > 1, dx = n * resolution
						+ n chosen so that number of slices kinda like now, i.e. ~= 500
		+ Initial FPS: 29.5/29.8
		+ Impl step 1: Ocean floor
			+ # of samples: try 2K first
			+ dx = MaxWorldWidth/NumberOfSamples
			+ Initialization:
				+ OceanBottom bitmap gets implicitly upsampled to 5000m if w < 5000
					+ If it looks bad, made it larger until definition is enough
				+ Then it gets cut/repeated to # of samples
					+ ImgX = (s * dx) % 5000
					+ Do interpolation
			+ Update:
				+ Sine/cosine is superimposed for each sample, like now
			+ AdjustTo:
				+ Fix
			+ Sampling:
				+ Just find sample index and interpolate in-between
				+ See issue with x==MaxWorldWidth
					+ Do extra sample with same val as previous
						+ Delta is zero though
					+ Remove change at Ship
				+ Test last ocean floor sample, again
			+ Since you're here, change AdjustTerrain tool to do trajectory
			+ Test:
				+ OceanFloor bitmap larger, not multiple (say, 700) - w/recongizable pattern			
		+ Impl step 2: Render upload: use same spatial frequency as samples, so to avoid interpolating altogether
			+ Need first to always render ocean up to visibleWorldBottom, in which case the two are fully independent
				+ Test afterwards
			+ Break World::UploadLandAndWater into OceanFloor::Upload(.) and WaterSurface::Upload(.)
			+ Fix perf issue w/tall quads
				+ Test waves below visible bottom
			+ Test ocean gradient				
			+ OceanFloor::Upload(.)
				+ Find first sample == sample immediately to the left of visibleWorld.Left
				+ Magnifying: n = 1, dx > 1; GPU fills-in
				+ Minifying: n > 1, dx = n * resolution
					+ n chosen so that number of slices kinda like now, i.e. ~= 500
				+ No, minifying is old sampling way
			+ WaterSurface::Upload(.)
				+ For now, like it was at World
			+ Go back to 500 slices
				+ Test seams
		+ Perf:
			+ FPS was (during step 2): 30.2/30.4
			+ Now: 30.5
			+ UR was (during step 2): 214
			+ Now: 217
		+ Impl step 3: WaterSurface
			+ # of samples: try 4K first
			+ dx = MaxWorldWidth/NumberOfSamples
			+ GetWaterHeightAt()
			+ Init
			+ Update
			+ WaterSurface::Upload(.)
				+ Do same as OceanFloor
			+ Test if # of samples good wrt waves' resolution
				+ Not really, but we can live with it
		+ Perf:
			+ FPS Now: 30.8
			+ UR Now: 224
+ UI:
	+ Smooth pan and zoom
		+ Takes 1 sec to get to final value (which is stored immediately as real value)
	+ Zoom: inverse
		+ 0 - 1000
		+ Renderer::ZoomToWorldY(zoom) == 70/(zoom + 0.001)
		+ Also called by GameController's Screen2World 
			+ also move GameController's Screen2World implementation to Renderer
		+ See if needs to be exponentially-slider'ed as well
	+ Settings:
		+ Strength Adjustment must be settable exponentially (slider=>exp)
			+ Formula done by gamecontroller at AdjustStrengthAdjustment(), or by SettingsDialog directly
	+ Page up and page down in menu
	+ Ship name in title
		+ MainFrame implements OnShipLoaded() and OnGameReset(), populates mShipNames vector with ship names, and calls SetTitle()
		+ SetTitle appends Utils::Join(vec<str>, ' + ') to current title
	+ Radio: draw points, springs, structure, texture
		+ (Bit) Flag @ GameController->RenderContext->Ship
			+ Inspected as bit glag by Ship as well @ Render() to avoid useless uploads
		+ Larger points
		+ SettingsDialog
			+ Better grouping, see RadioBox?
	+ Space bar for pause
		+ When pause, also pause sounds and music
	+ MainFrame: AboutDialog is member & shown on demand
	+ Make stiffness adjustment
		+ Points::SetStiffnessAdjustment(stiffnessAdjustment):
			+ Called by Ship at each Update()
			+ If != last, recalc coefficient/s
	+ Set max and min zoom (or monsters awaken when you zoom out too much)
	+ Reset view (ESC) should also reset camera pan
	+ SettingsDialog: bomb blast radius
	+ SettingsDialog: 
		+ Break into N Liner/ExponentialSliderControl
			+ Init'd with:
				+ CurrentValue
				+ Max and Min
				+ std::function for OnValueChanged(float newValue)
		+ Find solution to ugly slider value rounding
			+ Calc tick_size == (Max-Min)/100, floored to round float increment ... see doc'n on floats
			+ Then calc # ticks == floor((Max-Min)/tick_size)
		+ Re-set default values to round values
	+ Tool cursors: cursor should change when mouse down
		+ Remove up and down from hierarchy - no cursors in hierarchy (other than mCurrent), and ModulateCursor()
		  takes vector
		+ Do own up and down at:
			+ Smash
			+ Grab (times 2: positive and negative)
		+ Pin, instead, does not change
			+ Undo its dual cursors
		+ ToolController class, called directly by MainFrame
			+ Has GameController shared_ptr
			+ SetTool(tool enum from ToolController)
			+ OnMouseDown/Up/etc.()
			+ RC Bomb detection via events is still left to MainFrame
			+ Tool class:
				+ ToolController has pointer to the current tool; might be null
				+ ShowCurrentCursor(): shows the current cursor; invoked by ToolController at end of initialization
				  to show the first cursor, and might be invoked via ToolController by MainFrame in the future
				  to re-show cursor after having stolen it
			+ Test:
				+ Shift up and down detection
	+ View control smoothing: test with restart from last target for faster convergence
	+ Up MaxStrength
	+ See why waves change when settings dialog is opened and closed
		+ Problem with ocean depth: value on exit looks like current - min == 180
		+ First of all, need to set slider ticks based on current values upon opening of dialog
		+ Then, see if floor at linear control should be round
	+ Fix ambient light increments
	+ When wind is zero waves don't move - need to change wave height and phase separately	
	+ Changing the height of the bumps of the ground
		+ Allow the minimum seabed height to be 0
	+ Being able to drop the sea floor much further down than 500m or so too, like 10km
	+ World settings: number of clouds, wind
	+ SettingsDialog: also sound options
		+ Turn on/off sinking music
		+ Stress sounds on/off
		+ Break sounds on/off
		+ Two volume controls for music and sounds (all but music)
	+ ShipLoadDialog: revised FileDialog for loading ships showing previews of ships (*)
		+ ShipPreview
			+ <scaled ImageData, ShipMetadata>
			+ Loaded like ShipDefinition, taking width (from dialog)
		+ ShipPreviewPanel
			+ Now empty
			+ SetDirectory(std::filesystem::path)
				+ Just log for now			
		+ ShipLoadDialog
			+ Directory tree on the left
				+ https://docs.wxwidgets.org/3.0/classwx_generic_dir_ctrl.html
			+ PreviewPanel in main area
				+ Figure out size math and number of cols
			+ void Open()
				+ Load vals from UIPreferences
				+ Call ShipPreviewPanel::Open()
					+ Start thread
				+ Then, call ShipPreviewPanel::Close()
					+ Stop thread
			+ Resize:
				+ Set min size for dir tree and for preview panel
			+ Combo:
				+ Last N from UIPreferences
				+ OnSelection:
					+ Tell DirCtrl
						+ See if it generates DirSelected event
						+ If not, tell also PreviewPanel
				+ Nothing to do with current dir
			+ When dir tree chooses, call ShipPreviewPanel::SetDirectory
			+ When ship is loaded, call UIPreferences::AddShipLoadDirectory
			+ No use as modal, do with Open() which returns opt<path>
			+ Hitting OK with preview just selected
		+ UIPreferences
			+ Created by main frame and passed around as shared_ptr
			+ Loads and Saves to uncustomizable file path
			+ Also has defaults, as initialization values set at cctor
			+ cctor:
				+ Set defaults
				+ Load
					+ No exceptions, if anything broken => keep defaults
					+ Filter and keep only existing paths
			+ dctor:
				+ Save
					+ No exceptions, if anything broken => silent
			+ AddShipLoadDirectory:
				+ Check if already there
					+ If yes: move first
					+ If not: add first
		+ ShipPreviewPanel
			+ Thread
				+ Figure out how to hook Show()
			+ Redo with custom events for thread-to-panel
			+ Other thread messages
		+ ShipPreviewControl
			+ Catch double-click event and fire ShipFileSelectedEvent
				+ ShipFileSelectedEvent registered to by ShipFileDialog, which uses it as "Ok"
			+ Trim at load
			+ Show:
				+ Name
				+ Dimensions: 
					+ Metres: "160 m"
				+ Year
					+ Fill-in years @ ships
				+ Author
			+ Border when selected
				+ See wxPanel border
				+ If doesn't work, try DC
				+ If doesn't work, try Matrioska
		+ Cleanup source/Ships directory (make .dat's)
		+ Test:
			+ Super-minimize
			+ Image preview hits selection border? No
			+ ShipLoadDialog does not catch ShipFileChosen event
			+ Closing dialog when still loading images does not resume loading upon open
				+ ...and now test changing dir back to orig one while thread is loading
			+ Ugly flickering at re-open
				+ See if can avoid refreshing when not visible
				+ Due to Yield? No
			+ Run under debugger to see if there are assert's
		+ Test on two other Windows'
	+ SettingsDialog: tooltips at Simulation Quality (tradeoff) and Stiffness (instability)
		+ Use "Attention" icon
		+ wxToolTip
		+ SQ: Higher values improve the rigidity of simulated structures, at the expense of longer computation times
		+ S:  Higher values cause physical instability but provide for a nice effect!
		+ See if global settings are really needed
	+ Menu entries for "Home Page (GameJolt)/Code Page (GitHub)"
		+ wxLaunchDefaultBrowser
	+ SettingsDialog: add tooltips at each setting (*)
		+ Explanations and units
		+ Do on panel, slider, label, and textbox
			+ Or remove tooltip from icon altogether, do just standalone panel tooltip & standalone icon w/no tooltip
		+ Do also on various checkboxes in SettingsDialog
	+ PreferencesDialog:
		+ Nuke UISettings and move its setting in UIPreferences
			+ Also remove it from SettingsDialog altogether
		+ Plug into MainFrame
		+ Tooltip at ScreenshotsDir
		+ Tooltip at StartupDialog
	+ Ship Descriptions (*)
		+ ShipMetadata: description
			+ opt<string> member
			+ json load
		+ ShipDescriptionDialog
			+ Modal usage
			+ HTML control
			+ MakeHtml
			+ cctor takes bool ShipMetadata const &, isAutomatic, sh_ptr<UIPreferences>
				- If automatic, checkbox with "Don't show description when ships are loaded"
					- With tooltip about UIPreferences
		+ MainFrame: at LoadShip
			+ If gameController reports successful load, check UIPreferences and eventually create
			  ShipDescriptionDialog (automatic=true) and DoModal()
		+ Integrate in ShipLoadDialog
			+ 'i' button enabled when a ship with description is selected
			+ ShipLoadDialog needs to get ShipMetadata
		+ Checkbox at PreferencesDialog for auto-show
		+ Test:
			+ Select and later load .shp w/no description
			+ Select and later load .png w/no description
			+ Checkbox 
				+ @ ShipDescription window
				+ @ PreferencesDialog
	+ floatingsandbox.com: 
		+ Links menu
	+ SettingsDialog: make slider textboxes editable (*)
		+ Test MaxBurningParticles, Clouds, and Stars
	+ Adjustable zoom increments
		+ Under UIPreferences
		+ See if can use Smoothstep for...smoothing
			+ @ Controls
				+ Fix mouse wheel zoom
			+ @ Smoothed params
		+ Finalize ParameterSmoothing
		+ Fix unit tests
	+ StatusText/TextLayer replacement (*)
		! Slot-ification of text in text layer, with exhausted slots scrolling up
		+ Replace GameLib::StatusText with new TextLayer class
			+ Owned by GameController
			+ Talks directly to TextRenderContext (see below)
			+ Two sets of methods:
				+ 1: State-modifying:
					+ TextLayer::SetStatusTextes()/Enable
					+ TextLayer::AddEphemeralText(lines[], float lifetimeSeconds)
						+ Standard fade-in/stay/fade-out
						+ Handles slots and their rotation
				+ 2: void Update()
					+ Does things againts TextRenderContext, which will be rendered autonomously later by TextRenderContext
		+ TextLayer takes shared_ptr<TextRenderContext> in cctor
			+ Given by GameController, who takes it from RenderContext
			! RenderContext will forfait wrapping of text API's
		+ TextRenderContext cares about single-line texts only
			+ Make sure multiple-line support is not for perf
			+ API exposed:
				+ AddText:
					- text (1 line)
					- Justification
						- TopLeft, TopRight, BottomLeft, BottomRight
						- Implicit: l/r/t/b (screen-)margins
					- offsetScreenX
						- Meant to be distance from horizontal component of justification
						- Margin is added implicitly
						- For effects
					- offsetScreenY 
						- Meant to be distance from vertical component of justification
						- Margin is added implicitly
						- Also provides getter for (screen-)height of line for font, and getter for fixed (screen-)v inset between lines
					- alpha
					- font
				+ UpdateText: different versions for:
					+ text only
					+ alpha only
					+ offsets only
				+ RemoveText
			+ Cleanup:
				+ Nuke old API
				+ Remove RenderContext's forwarding of API's
			+ Optimize alpha+offset update
		+ GameController:
			+ Use mTextLayer::ephemeral text for tsunami
			+ Nuke StatusText
				+ Also source files
			+ Expose DisplayLoadedLastPlayedSettingsNotification()
	+ SettingsManager: save settings, defaults, and real-time changes (*)
		+ Spec: 
			+ Game starts always with default settings; user has the ability though to load named settings and to load
			  the last-played settings
			+ Changing settings in the GUI puts them in effect immediately
				+ ...and GameController will smooth them
			+ Loaded settings go to GameController
				+ ...and GameController will smooth them
			+ Dialog:
				+ Control values are meant to always be in sync with real game params
					+ Handlers enforce values immediately
		+ Plan:
			+ Standard paths: http://docs.wxwidgets.org/3.1/classwx_standard_paths.html#a4752213ef4d7bdc71170b9e5c3691f0f
				+ Via StandardSystemPaths class
			+ ResourceLoader::GetThemeSettingsRootFilepath()
			+ Settings framework
			+ OceanFloor:
				+ OceanFloorTerrain
					+ Has unique_buffer<float>
					+ other notebook methods
				+ OceanFloor contains and owns OceanFloorTerrain
					+ Needs it as a member as it exposes reference to it
				+ OceanFloor cctor needs to take default OceanFloorTerrain as && from outside, i.e.
				  from World who takes it from GameController as &&
					+ GameController provides the initial one loaded via 
					  OceanFloorTerrain::LoadFromImage(ResourceManager::path of default system one)
				+ GameController::Reset():
					+ First takes current terrain, via World
					+ Then, passes it back to World's cctor, as &&
				+ Crash when reloading after having written last sample
				+ IGameController (and OceanFloor):
					+ Get[OceanFloor]Terrain() const -> OceanFloorTerrain const &
					+ Set[OceanFloor]Terrain(OceanFloorTerrain const &)
				+ Test:
					+ Default terrain at beginning
						+ Double-check interpolation we do at image->terrain algo					
					+ Precision of adjusted terrain
					+ Reset: maintains manually-adjusted terrain				
			+ FloatingSandbox/SettingsManager.h
				+ BaseSetting specialization for OceanFloorTerrain
					+ Does it need OceanFloorTerrain to expose Load(...istream...) ?
				+ Static factory maker
				+ Massage name to make it lower-case and underscore-separated
			+ Run unit tests in Debug
			+ MainFrame:
				+ Creates shared_ptr<SettingsManager> after it has all storages (GC, SoundController, etc.)
				+ Menu: "Reload last played settings"
					+ Only enabled if "last played settings" exists
				+ Save last-played settings on exit
					+ If UI Preferences say so
					+ Verify ocean floor
				+ Fix crash
				+ Fix Preferences Dialog
			+ SettingsDialog:
				+ Frame:
					+ See if appears in Taskbar
					+ Minimize
					+ Background
					+ Icon
					+ Cancel in OnClose
				+ Hookup settings
					+ Make ReadSettings(Settings const & settings)
				+ Get rid of mSoundController
				+ Take IGameControllerSettingsOptions					
				+ Change standard bottom buttons
					+ Add "Restore Defaults", see paper
				+ New "Settings Management" tab:
					+ Keep entries sorted
						+ @ Insert
						+ @ Remove
					+ Catch FS exceptions, & OnPersistenceError(msg)
					+ Fix overwrite
					+ Test:
						+ Replace (overwrite)
							+ Via replace button
							+ Via save
						+ Delete
							+ First
							+ Mid
							+ Last
						+ Insert
							+ First
							+ Mid
							+ Last (need to nuke LastPlayed for test)
				+ "Restore Default Terrain" button
					+ "Adjusts the jaggedness of the ocean floor irregularities."
					  -> "Adjusts the contrast of the user-drawn ocean floor profile"
				+ Tooltips on buttons
				+ Float on Parent issue: clicking back moves it back
					+ See if may use wxSTAY_ON_TOP, & if that is also broken with colour picker
			+ Visual notification when last settings loaded
				+ 1) Need boolean returned from SettingsManager
				+ 2) Do StatusText replacement (*)
				+ 3) Do notification (@GameController)
			+ Data\Themes:
				+ Ocean of Lava
					+ See PM's suggestion on Discord
				+ Marianas Trench
					+ https://clasticdetritus.files.wordpress.com/2008/11/profile-mariana.jpg
					+ Fix sudden ocean floor:
						+ ParameterSmoother has SetImmediate(.)
							+ Stops smoothing, updates mTargetValue with clamped value, and sets
							- Unit tests, w/subsequent Update() call which should be nop
						+ I/GameController has also SetOceanDepthImmediate(.)
						+ BaseSettingsManager has two enforcers, second one is "Immediate"
							+ Exposes new EnforceDirtySettings"Immediate"(.)
							+ EnforceDefaultsAndLastModifiedSettings(.) calls "Immediate"
							+ Unit tests, verify each is called only when expected and not when not expected
						+ All callers of (Base)SettingsManager::EnforceDirtySettings(.) should check whether they need
						  to call EnforceDirtySettings"Immediate"(.) instead
							+ SettingsDialog: all but OnLiveSettingsChanged(.)
						+ SettingsManager populates second "Immediate" set of enforcers
				+ See if need bold for system settings
					+ Need wxListCtrl
		+ Small rearc:
			+ SettingsManager:
				+ From:
					! void LoadPersistedSettings(key, settings &)
					! void LoadAndEnforceLastPlayedSettings()
				+ To:
					! void LoadPersistedSettings(key, settings &) // only loaded dirty on output
					+ void EnforceDefaultsAndPersistedSettings(key) -> Settings (all clean)
					+ void EnforceDefaultsAndLastModifiedSettings() -> void
						+ Just calls above w/standard key
			+ See why ocean floor settings appear to be superimposed
				+ It's just OceanDepth for one, and custom for other
			+ Have two different "load" buttons:
				+ 1) "Apply Settings": "Loads the settings and applies them on top of the current settings." (i.e. current behavior)
				+ 2) "Revert to Settings": "Reverts all settings to the saved settings." (i.e. enforce {Defaults+Loaded} rather than just Loaded)
			+ Make "last-played" really "Last-Modified"; i.e.:
				+ Settings.h/cpp: 
					+ Rename
					+ Rename in key
				+ Rename in menu
				+ Rename in *find*
		+ Run unit tests in debug
	+ Save ocean floor terrain and load it at startup

+ Gfx:
	+ Do ropes with two endpoints (000xxx)
		+ Throw exception if doesn't find two endpoints
		+ Algo: 
			+ Step 1: build vector<PointInfo> & Matrix<opt<pointIndex>> & vector<RopeInfo>
			+ Step 2: visit RopeInfos and add to PointInfo's and SpringInfo's
			+ Step 3: visit PointMatrix & ...
		+ Starting perf:
			+ Default ship: 14.1/14.3
			+ Ropes test: 12.2/12.3
		+ Need to always use color when rendering springs:
			+ Spring::Type (Hull, Rope)
				+ No exposed, just IsHull() & IsRope()
				+ Make it a bit flag
			+ Separate RenderContext method for Ropes, stored in separate Element (RopeElement, structurally == SpringElement)
				+ Upper bound for # of spring ropes given # of points in connected component:
					+ N
					+ Upper bound of 'normal' springs doesn't change
			+ Render: draw ropes after springs and triangles (we want them on top of triangles!), still by connected component
				+ Use own program
		+ Ending perf:
			+ Default ship: 14.2
			+ Ropes test: 12.3
		+ Don't make triangles of 3 rope points if at least one is connected to ropes only
			+ Fix Base III?
		+ Flip order of rendering when structure: triangles first, then ropes
			+ Need private subparts of Render()
		+ Ending perf:
			+ Default ship: 14.5
			+ Ropes test: 12.3
		+ Add ropes to Titanic
			+ Make wood non-hull
		+ Fix unit tests
		+ Make max(fixedSizeVector) == 9
			+ Not for triangles - generated rope points will never participate in triangles
		+ Material/Rope rearc:
			+ MaterialDatabase
				+ Loads itself from json
					+ From ResourceLoader invoked by GameController at init'n
				+ Guarantees:
					+ Exactly one material with isRope=true
					+ Color is #000000
					+ No colors clash, and no colors fall within rope range
				+ Replace in GameController, ResourceLoader
				+ Remove ropeMaterial kung-fu @ Ship::Create and use material->IsRope
				+ GameController also gives rope renderColour to RenderContext at cctor
					+ Which sets shader's hardcoded parameter
	+ Try light diffusion rearc:
		+ No more at C++, but rather in OpenGL as in the following example (written for ShipTriangles only but valid also for springs 
		  and points):
			+ Prerequisite: draw ship triangles by connected component (see above)
			+ Turn off diffusion
			+ For each component: pass array of all lamps in that component; each lamp has {x, y, intensity};
			+ Draw each connected component N times (use additive blending), once for each lamp, 
			  each time passing the single lamp properties as uniform to shaders, 
			  which calculate distance and do final light blending
				+ Check right way of doing blending
		+ REJECTED: perf was awful; this multiple-pass way of doing it hurts too much

	+ Texture mapping:
		+ UploadLandAndWaterStart()/./End()
			+ Just specify land y and water y
			+ Impl:
				+ y:
					+ To LandBuffer
					+ To WaterBuffer
			+ RenderLand()
			+ RenderWater()
		+ Land (sand)
			+ bottom is not anymore a param but it's filled by RenderLadn(.) with +/- mWorldHeight/2
				+ only param is x and y (world y)
			+ texture coordinates are world coordinates
			+ Magic number is based on desired tile world size
		+ Water
			+ Use "water transparency" uniform in shader that sets alpha value in result of texture
			+ Make texture stretch wrt vertical height of water strip
			+ Change map, this one's ugly
		+ Clouds
			+ Use N textures, each has own rectangular size
			+ RenderContext loads all available textures and uses them for the clouds, modulo
				+ ResourceLoader::LoadTexturesRgba(prefix)
					+ initProgressSink lambda 
			+ GameParameters.NumberOfClouds (constants)
			+ World takes numberOfClouds and allocates clouds buffer with random values
			+ Then, RenderContext::RenderCloudsStart()/./End()
				+ Buffer contains virtualX and virtualY, and scale
				+ RenderContext::RenderCloud() makes rectangles (in world coords) based off formula
			+ Clouds stencil: 
				+ Draw waterbuffer without texture, but reverse stencil op
		+ Ship, using second image
			+ Load ship == image or .shp (JSON)
			+ First, try naively with just point colors
				+ Doesn't work, as structural image has too little resolution
			+ RenderContext is given optional texture image (by GameController) via
			  RenderContext::AddShip(iShip, opt<ImageData>)
			  + Requires RenderContext::ResetWorld()
				+ Simply clears vector of ShipRenderContext()
					+ ShipRenderContext contains everything ship-related
						+ Rename springs and triangles to "Elements"
						+ Touch points with outside world:
							+ Parameters (booleans, render factors)
							+ OrthoMatrix
							+ Helpers
				+ No need to reset others (land, water, clouds) as their numbers, positions, and data will be given
				  at the next Render() from scratch
					+ But it could easily by re-creating uq_ptr<XYZRenderContext()>
				+ Call from GameController
			  + Adds ship with opt<ImageData> in arg
				+ If specd, cctor creates <OpenGLTexture mElementTexture> and uploads immediately
				+ mShipTextureCoordinatesVBO and other texture machinery is created at startup anyway (if any)
				+ No need for std::optional<ImageData> TextureImageData
			  + Remembers if ship has texture via mElementTexture
			  + Catch exceptions at all interactions of MainFrame with GameController, and display DialogBox
			  + ResourceLoader::LoadShipDefinition: need to make paths abs wrt .shp path
			  + Refactor to World::CreateShip() -> ID -> Ship::Create()
			  + Land and Water texture names: do own, not from array
			  + Always unbind texture2d after a render
			+ Also, later, RenderContext is also given textureCoords,
			  i.e. a buffer of texture X's and Y's (i.e. initial points' coords) for
			  each of the ship points (i.e. aligned with the point buffer which will be continuosly uploaded)
			  + TextureCoords created by Ship::Create (always), stored into Ship, and given to RenderContext
			    (which uploads it, always) once and for all at the same time as colors (i.e. when IsPointCountDirty)
			+ If a texture is associated with the ship, RenderContext uses a different shader for ShipTriangles
			+ Krafting:
				+ Y offset for initial drop
				+ Remove one layer of hull from bottom, but see how much it bends afterwards

	+ Draw stressed springs with their own hardcoded texture (1D, 3 pixels: red, red/white, red) of a reddish line with "hot" centre
		+ https://stackoverflow.com/questions/17866308/texture-a-line-in-opengl
		+ Make it a 2D with semicircle around T,L corner
			+ textureCoords are inputPos
	+ Fix springs showing up around texture from structure
		+ Make test .shp with three masses and a rope
	+ Draw points:
		+ Ship uses RenderContext::UploadPoint(elementIndex), only for !deleted points
		+ Then, glDrawElements(GL_POINT)
		+ Nuke PointProgram as it's dupe now
	+ RenderContext:
		+ Get rid of pre-generated texture names and create on-demand
			+ Test!
		+ See if can describe point, color, and texture VBOs at init
	+ Should draw each connected component at once
	+ ShipTexture: Experiment with different min/mag filters
		+ Try mipmaps, should help make the Titanic artifacts disappear
			+ OpenGLGame::UploadMipmappedTexture(imageData) -> void
				+ Does base and all the dimensions down to 1x1, using floored extents
				+ Algo: take avg of each square of points, including alpha
			+ Use GL_LINEAR_MIPMAP_LINEAR
			+ See https://www.khronos.org/opengl/wiki/Texture
			+ Then nuke ImageData stored in RenderContext's
			+ Use at:
				+ Ship
				+ Remove from Land? Test w/out and see if border
			+ Test perf
	+ VectorField rendering
		+ Final cleanups:
			+ Check all vector fields wrt deleted points
			+ RenderContext: initialize vector render mode to None
			+ Make vector field render mode changeable in SettingsDialog, Render tab
			+ Add length adjustment as render parameter, multiplied by RenderContext before passing to ship
				+ No dialog adjustment needed yet
	+ ShaderManager
		+ WetColor, LightColor: make them static hardcoded params
		+ Use in and out, and 130
		+ Replace all shaders
			+ RenderContext
				+ Use "in" as prefix of inputs
				+ glEnableVertexArrays: all at top, as they have nothing to do with VBOs
					+ ShaderMgr enables all the used ones
					+ Ship/RenderContext Code only disables zero when it's not used
			+ ShipContext
				+ Ship/RenderContext code only disables zero when it's not used
				+ Remove unnecessary bind's for VBO's that source dedicated attributes
		+ Get rid of vector_arrows shader, use matte
			+ Will need to re-bind attribute (GenericPosition or VectorPosition=0) to vectors VBO
			+ Deep cleanup
				+ enums
				+ shader
		+ Replace glBufferData with glBufferSubData when size does not change; at Ship only:
			+ Point positions, color, water
			+ Check perf before and after:
				+ Pre: 26.6
				+ Post: 27.3
	+ Fullscreen:
		+ ESC to go out, menu option/F11 to fullscreen again
		+ Add to changes
		+ Text at RenderContext
			+ Do Render:: move
			+ Render::Font
				+ Loads itself like TextureDatabase, with IProgress
				+ Owned by Render::TextRenderContext, created at cctor
					+ Render::TextRenderContext owned by Render::RenderContext, which fw's all calls to it
				+ Has method to calc pixel size given char* and size_t
				+ Has method to append vertices given char* and size_t
					+ Returns # of vertices appended
			+ TextRenderContext
			+ TextLayer:
				+ Owned by GameController, which FW's to it
				+ SetEnabled(bool)
			+ Debug:
				+ glCheckError macro at GameOpenGL.h
					+ Make it inline
					+ Use it at RenderContext and ShipRenderContext setup and rendering, instead of various checks
			+ Cleanup Font.h
			+ Add & change StatusText font
			+ See response to Toggle Status Text
			+ Do better initial text (invoke at MainFrame cctor)
			+ Update AboutBox and tell guy
			+ Check perf
			+ Perf optimizations:
				+ Precalcd stuff in FontMetadata, indexed by char
	+ Option to enable drawing of force vectors for each point
		+ Ship::Update() takes also RenderContext const &, so can check if need to save force buffer
			+ Points::SaveForceBufferForVectorRender()
		+ Copied right before integration
	+ Orphaned points
		+ Idea: always draw orphaned points - those that come after destruction
		+ Orphaned point == points with 0 connected springs
		+ We unify ephemeral points uploading and rendering with ship points (either debug or orphan) uploading and rendering
			+ Plane ID is enough to keep them on separate planes
		+ Verify first that connectivity visit really assigns plane IDs also to orphaned points 
		+ Impl:
			+ We must first stop deleting points just because springs are deleted
				+ Though should still delete them at Destroy() and Bomb(), for example
			+ Unify non-ephemeral and ephemeral points in element VBO
				+ Need hint from Points on whether or not ephemerals will follow
			+ ShipRenderContext:
				+ Nuke RenderEphemeralPoints and its structs and members
				+ Have just one single RenderPoints
					+ Always invoked, except when DebugShipRenderMode is not None and not Points
					  (i.e. when it's Springs, EdgeSprings, etc. but not Points)
		+ Test L'n'F'
		+ Cleanup:
			+ Ship: generation of air bubbles: atm we don't generate air bubbles for orphaned points; see if this should change instead
	+ Bug: bombs et al fade more rapidly than ship when ambient light goes away
	+ Make font white inversely to ambient light
	+ Stars at night
		+ Render:
			+ Need to be done at clouds, w/water stencil
		+ Physics::Stars
			+ Update(GameParams) -- recalcs if # changed
			+ Upload(RenderContext)
			+ Managed by world
		+ Test ambient light -> transparency curve
		+ Test customizability
		+ Compare with screenshot
		+ Check performance
			+ FPS: 28.4
			+ PerfAnalysis
	+ Add world end markers
		+ Add texture (square,repeatable in both directions)
		+ RenderContext::init: 
			+ Don't load in atlas
			+ Make it repeated
		+ Final step @ RenderContext::Render
			+ Checks first which sides, if any, have to be drawn
			+ Renders quad for each side
				+ Width is in NDC
				+ alpha = 0.5 (in shader)
	+ (Retry) Use CPU and GPU in parallel
		+ Finalize render (glFlush) before render step, not after
			+ Research glFlush()
			+ By invoking glFlush() and SwapBuffers() in MainFrame, before Render()
	+ Test using gl_TexCoord to pass texture coords from vertex to fragment
	+ Selector to change color of (intaken) water

+ Gfx Optimizations:
	+ Try without buffer population: 			
		+ Point has vec2f * const mPosition and vec2f * const mColour, pointing into two fixed buffers
			+ vectors are packed (static_assert on contiguous 2 or 3)
			+ Point does not live in PointerContainer but in std::uq_ptr<Point>[]
				+ Delete does nothing (Destroy does relationships though), just marks it
		+ Point also has mElementIndex, queried by springs and triangles when rendering themselves
			+ Can make Ship::Render const again, then
		+ Pointers to fixed buffers (as arrays of vectors) are owned by Ship and
		  are given by Ship to RenderContext at each Render via 
		  RenderContext::UploadVertices(vec2f*, vec3f*, count)
		+ RenderContext usage of two buffers at each DrawElements:
			glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
			glVertexAttribPointer(vertexPositionAttribute, 3,  GL_FLOAT, false, 0, 0);
			glEnableVertexAttribArray(vertexPositionAttribute);
			glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);
			glVertexAttribPointer(vertexColorAttribute, 4, GL_FLOAT, false, 0, 0);
			glEnableVertexAttribArray(vertexColorAttribute);
		+ Point's vector pointers are populated by Point::Rebase(buf1, buf2),
		  invoked by Ship at construction
			+ Rebase() uses mPointIndex (rename of mElementIndex) to calc pointers
		+ Try: could also use buffer with mLight and mWater (uploaded each time to GPU as well) to be used by V->F shader 
		  to blend fragColor with two fixed colors (water blended before ambient light, light after)
			+ F shader needs to start doing ambient light now, rather than point
			+ Need Point::CalculateWaterColorIntensity() (clamps and copies mWater to buffer), 
			  and a dummy Point::FinalizeLightColorIntensity() (dummy because mLight is already finalized)
			  + or do clamp in shader, so use mWater and mLight straight from buffer, no CalculateX() needed
			+ If we put light and water in shader, then we don't need to reupload color buffer each time
		+ Bonus: also test GPU interpolation of mLight and mWater by emitting them at vertex
	+ Plan:
		+ 0: Test with additional mLight and mWater uploaded to RenderContext (same Point struct), and fragment shader doing math
			+ F Shader needs params: ambientLightIntensity; constants: waterColor, lightColor
			+ Remove point color calculation
			+ Check perf:
				+ Before: 16
				+ After: 14.1
				+ Keep in mind that we're adding to the buffer, while later we'll remove the colors
			+ Also test bonus: GPU interpolation of mLight and mWater by emitting them at vertex				
		+ 1: if OK: PointCore struct (@GameLib) with {position, light, water}, based into Point
			+ Separate color buffer: 
				+ Color struct (vec3f) has static_assert's for alignments
				+ Created by Ship::Create(), moved into Ship member (ElementRepository<vec3f>)
				+ Uploaded one-shot at first Ship::Render()
					+ via RenderContext::UploadShipPointColors(vec3f *, size_t elementCount):
						+ Uploads to GPU right away, with GL_STATIC_DRAW
						+ Stores size (mShipElementCount) for later assert
			+ Check perf: 14.2
			+ Commit 
			+ Separate PointCore buffer:
				+ PointCore struct has static_assert's for alignments
				+ Created by Ship::Create(), moved into Ship member (ElementRepository)
					+ Points have already been based, at cctor by Ship::Create()
				+ Uploaded at each Ship::Render()
					+ via RenderContext::UploadShipPoints(PointCore *, size_t elementCount):
						+ Asserts size same as color buffer (mShipElementCount)
						+ Then uploads to GPU right away, with GL_STREAMING_DRAW
		+ Final:
			+ Nuke Point::CalculateColour
			+ Also do light/water color blending at ship *point* fragment shader
	+ Only keep separate color buffer and water/light done in F shader; point disembodiment was not a good idea

	+ Pack vertex attributes @ other shaders:
		+ clouds
		+ text_ndc
		+ FPS: 28.2/28.4

	+ Reduce # of bind VBO calls by delaying upload of buffers we own until we bind the VBO for drawing
		+ Land at RenderContext::UploadLandAndWaterEnd/RenderLand
		+ Also disable vertex attribute index zero once
		+ Test all ship shaders with 2 connected components
		+ FPS: 28.5

	+ Use MapBuffer when we know the sizes in advance, eventually re-allocating GPU buffer when the size changes
		+ Clouds
			+ Rename middle "RenderCloud" as "UploadCloud"
			+ Rename SharedAttribute1 as SharedAttribute0, et al
		+ Land, Water
			+ Also make clouds, land, and water use disjoint vertex attributes, so can bind once at each XYZStart()
			  before mapping buffer (and subsequently describe, when needed)
			  + Water, matte_water: use vec3 WaterAttribute
				+ Shaders
				+ RenderCore
				+ Description, once at initialization
				+ Disable 0 before running program
			  + Clouds: use vec4 SharedAttribute0
				+ Shaders
				+ Bind, allocate, and map at RenderStart()
				+ Description at Render() after unmapping buffer
				+ Enable 0 before running program, after description as usual
			  + Land: use vec2 SharedAttribute1
				+ Shaders
				+ Bind, allocate, and map at RenderStart()
				+ Description of SharedAttribute1 at Render() after unmapping buffer
				+ Disable 0 before running program
		+ FPS: 28.1/28.3/28.4
	+ Now, compare with replacing MapBuffer with BufferSubData
		+ Copy exe first
		+ Just this:
			+ Replace mXYZMappedBuffer with std::unique_ptr<XYZ[]>
			+ (Re)allocate buffer whenever we (re)allocated GPU buffer
			+ Remove MapBuffer call
			+ Replace UnmapBuffer call with BufferSubData
		+ FPS: 28.2/28.3/28.4
	+ Get full perf, including other laptops
	+ Texture atlas:
		+ Spec:
			+ Atlas is built on-the-fly, completely independently from texture DB, via a separate
			  component (TextureAtlasBuilder) that is given multiple TextureFrame's and eventually spits out TextureAtlas
			+ TextureAtlas:
				+ Contains:
					+ image: consumed by GameOpenGL helper for mipmapping
					+ metadata: used by GameOpenGL helper for mipmapping, owned by RenderContext (for clouds, land, and water) 
					  and (by reference) by ShipRenderContext (for GenericTextures)
				+ Structure:
					+ ImageData Texture
					+ TextureAtlasMetadata Metadata:
						+ TextureAtlasFrameMetadata:
							+ box in atlas (i.e. texture coords, as 2xvec2f)
							+ TextureFrameMetadata
						+ vector<TextureAtlasFrameMetadata> / anything else addressable via TextureFrameId (see above)
			+ Separate mipmapper helper in GameOpenGL takes ImageData (by move) and TextureAtlasMetadata
		+ Impl:
			+ Phase 1: Clouds
				+ TextureAtlas
				+ ResourceLoader::SaveImage
				+ Resize all clouds to powers of two
					+ Test look & feel
				+ RenderContext: 
					+ Cctor: create atlas and add just Clouds
					+ Upload texture - w/no mipmap for the time being
					+ Store Metadata (by value) and handle
					+ Use Atlas metadata at UploadClouds()
				+ Test 1
				+ Get rid of need to use TextureRenderManager at RenderContext for clouds
				+ Draw all clouds together at once
					+ Need triangles
				+ RenderContext:
					+ Call GameOpenGL mipmap helper moving Texture and passing Metadata
				+ Test 2
					+ FPS: 28.5/28.6/28.7
			+ Phase 2: Generic Textures
				+ Resize all generic textures to powers of two
					+ Pin
					+ RC Bomb
					+ RC Bomb Ping
					+ Timer Bomb
					+ Timer Bomb Defuse
					+ Timer Bomb Explosion
					+ Timer Bomb Fuse
					+ RC Bomb Explosion
					+ Timer Bomb Explosion
					+ Test look & feel
					+ Fix timer bomb issue
				+ Fix texture coordinates in atlas to be between 0.5/dim and 1-0.5/dim
					+ Test it first simply at current generic texture upload
					+ See Moleskine
					+ Do in atlas UV coordinate generation
				+ RenderContext:
					+ Cctor: add entire database to atlas minus land and water
						+ Make builder stateful
					+ Pass Metadata and texture handle to ShipRenderContext
					+ Bind:
						+ Atlas before clouds
						+ Land, Water before land and water
				+ ShipRenderContext must take from RenderContext:
					+ Atlas texture handle (&), for binding it at GenericTextures
						+ At least until we do Z and GenericTextures moves up to RenderContext
					+ metadata (&)
				+ ShipRenderContext:
					+ Bind atlas at GenericTextures
					+ Use box in atlas at Generic Textures upload
					+ Modify GenericTexture to run once for all textures (still for each connected component until Z)
						+ Populate quads directly in connected component GenTexElement vector
							+ Make room as needed (emplace_back)
							+ Store max size among all connected components in SRC member
						+ Upload connected component GenTexElement vector at RenderGenericTextures()
							+ Realloc buffer if new max size != m allocated max size
							+ Then always BufferSubData
						+ Test with multiple connected components
					+ Nuke TextureRenderManager member and cctor arg
					+ Cleanup RenderContext's upload of textures				
			+ Remove test saving of atlas
	+ Figure out what's most expensive with perf analysis and noinline
		+ Only triangles: 42fps
		+ Triangles and ropes: 42fps
		+ Only springs: 32fps
		+ Is it stenciling, flushed at Ship::RenderEnd()?
			+ With no stenciling: FPS: 29.4/29.5
	+ Enable stenciling only when needed
		+ FPS: 29.0
	+ Try Render1/Update1/Render2/Update2
		+ @ GameController and down
		+ No improvements
	+ All textures: test changing GL_LINEAR_MIPMAP_LINEAR to:
		+ GL_LINEAR_MIPMAP_NEAREST
		+ At:
			+ Land and Water
			+ Atlas
	+ In texture or structure mode, draw only springs that are visible
		+ i.e. springs with # of triangles < 2
		+ Impl:
			+ Springs:
				+ New buffer: SuperTrianglesCount - type: ElementCount
					+ Publicly exposed
					+ Populated via argument at Springs:Add
						+ Calc'd by ShipBuilder via Triangles below, during component springs discovery
					+ Decremented via Springs::RemoveSuperTriangle() // no args
			+ Triangles:
				+ New buffer: ComponentSprings - type: std::array<ElementIndex, 3>
					+ Publicly exposed
					+ Populated via argument (of type std::array<ElementIndex, 3>) at Triangles:Add
						+ Calc'd by ShipBuilder
					+ Never changed
					+ Used by Ship::TrianglesDestroyHandler() to decrement count for each component spring
			+ Triangle destroy: remove self from springs
			+ Springs destroy: remove self from super triangles
			+ ShipBuilder:
				+ Adjust to new
				+ Also take care of traverse springs
			+ New ShipRenderMode: EdgeSprings only
				+ ShipRenderContext: treated exactly like SpringsOnly
				+ Springs::Render: used to decide what to upload
			+ Springs::UploadElements: in all modes except SpringsOnly, upload only springs with # of super triangles < 2
				+ Re-enable TODOTEST code
			+ Ship::Render() has to remember what ShipRenderMode was used last time, so to consider elements dirty
			  also when ShipRenderMode has changed

	+ See if can use multiple texture units
		+ Bind once atlas, land, and water at cctor, to each unit
		+ Change shaders to have one single texture sampler param, and set uniform locations to texture unit
		+ Do only for clouds, generic texture, land, and water
			+ Revert RenderContext.cpp, ShipRenderContext.cpp, TextRenderContext.cpp
			+ Fonts and ship stay as before, they use texture unit 0 - SharedTexture
			+ Shaders
			+ Remember to activate texture unit 0 before binding, at:
				+ Ship texture, stressed spring texture, font
		+ Fix: land, generic
		+ : test
		+ Replace calls to glActiveTexture with ShaderManager::ActivateTexture(parameter)
		+ Fix/Recheck progress bar
		+ Redo perf FPS measurement
	+ Z buffer:
		+ Rationale: more connected components => slower (multiple batches); try to draw one single batch then, using Z buffer and depth test 
		+ Spec:
			+ Assign Z based on cousin of connected component ID (named "Plane ID", uint32_t)
				+ All points have PlaneId
					+ Can we revert ShipId and ConnectedComponentId to start from zero and having None=max? 
						+ Yes, no one used NoneConnectedComponentId
						+ When we need stuff on top we can always use member variable with max plane ID and/or the total 
						  count of ships 
						+ If so, Plane ID starts from zero
					+ Own buffer (it'll have to be uploaded to GPU)
				+ Points that belong to a connected component also have ConnectedComponentId
					+ What doesn't have a ConnectedComponentId?
						+ ConnectedComponentId is used for:
							+ Frontier (possibly?)
								+ In this case we don't want to assign them to "cables" (0-triangle edges a.k.a. 
								  0-SuperTriangle springs), nor to standalone points
							+ ForceFields that spring from a point
								+ But we can get rid of this and just explode all over the place, after all
								  explosions travel through air
							+ Not by light diffusion algo, see below
					+ We keep ConnectedComponentIds for future use, but do the frontier-type propagation, i.e.
					  we don't propagate them through "cables" nor assign them to standalone points; all of these 
					  won't have a ConnectedComponentId at all
					+ So, what doesn't have a ConnectedComponentId?
						- "strings"
						- standalone points
				+ Assignment of PlaneId is done via the same connectivity visit used for assigning ConnectedComponentId's,
				  but we assign "single-spring paths" to the origin's PlaneId and don't propagate to solid body again
					+ So we draw as separate two pieces that are connected solely by a "cable" (**)
					+ Also rope triangles must be assigned to the origin's PlaneId
					+ Propagation algo: don't propagate if coming from a spring with zero SuperTriangles to a spring
					  with >0 SuperTriangles, unless these are all rope triangles
						+ New "IsRope" property of Triangle, pop'd by ShipBuilder; new buffer
				+ Light diffusion algo follows PlaneId's, instead of ConnectedComponentId's, as it's really about planes
				+ We assign Z after orthomatrix - in NDC - and thus positive is near
			+ We only enable Z test and writing to Z buffer at RenderContext before doing ships
				+ And later, if we move GenericTexture to RenderContext, also when we do generic textures
		+ Figure out range of Z:
			+ World: -1000 -> -1  ==> NDC: +1 -> -1
			+ We assign Z after orthomatrix - in NDC - and thus positive is near
			+ After matrix it's NDC: [-1, +1] (far, near)
			+ When given to fragment shader it's [0,+1], but we don't care anymore at this moment, as we calc Z in vertex shader!
		+ Mapping of <ShipId, PlaneId> to Z in NDC:
			+ Normal: ShipId=0 and PlaneId=0 are furthest
		+ Plan:
			+ Branch
			+ Preliminaries:
				+ Test explosions without connected component ID constraint; if ok, eradicate connected component IDs
				  from ForceFields
				+ Test perspective with hardcoded z=-1 at triangle shaders and z=-999 at springs, and see if it makes any difference
					+ Undo afterwards
				+ Do test images:
					+ Get problematic # of CC's first, with AM bomb on Titanic: 6,000
					+ ConnectedComponentsTestShip1: 8192 CC's, 33280 points, 49152 springs
					+ ConnectedComponentsTestShip2: 1 CC, 36588 points, 47882 springs
				+ Get initial perf:
					+ Default: 30.8
					+ ConnectedComponentsTestShip1: 3.10
					+ ConnectedComponentsTestShip2: 11.6
			+ Step 1:
				+ Add "PlaneID"
					+ GameType
						+ Same integral type as ConnectedComponentId
						+ Change ShipId, ConnectedComponentId, PlaneId to start from zero and have None=max (see @Spec above)
					+ Points: new buffer
				+ Points: add connected springs' "other endpoint"
					+ As part of Network
					+ Test fixed_size_vector::erase_first with/lambda
						+ Check assembly with unit tests
					+ Populated by whatever populates ConnSprings now (ShipBuilder or Points::Add)
					+ Nuke Springs::GetOtherEndpointIndex
					+ Write off work item from elsewhere in this file
				+ Run in debug and validate
					+ Revert to Render::uploading ConnCompId's 
					+ Test crash w/Goliath
				+ Check perf
			+ Step 2:
				+ Connectivity visit:
					+ New PlaneId propagation (see @Spec above and Moleskine)
					+ Change ConnectedComponentId propagation to match frontier style (i.e. not on strings)
				+ Light diffusion algo now follows PlaneIds (see @Spec above and Moleskine)
				+ All the other things that currently require a ConnectedComponentId for rendering purposes:
					+ Bombs: substitute ConnCompId with PlaneId
					+ PinnedPoints: substitute ConnCompId with PlaneId
					+ Triangles: no ConnCompId nor PlaneId
					+ Spring: no ConnCompId, just PlaneId
					+ Ephemeral particles (check all Points::CreateXYZEphemeralParticle(...))
				+ Render: upload PlaneId instead of ConnectedComponentId
				+ Do ad-hoc tests to validate assignment of plane IDs and connected component IDs
				+ Run in debug and validate
				+ Commit
			+ Step 3:
				+ Ship/RenderContext: UploadPlaneIds(..., maxMaxPlaneId)
					+ Send to GPU right away, in buffer mapped to shared vertex attribute
				+ Test
				+ Commit
			+ Step 4:
				+ Enable Z test and writing to Z buffer:
					+ At RenderContext before doing ships, and disable afterwards
						+ Need World to invoke RenderShipsStart()/End() before going through individual ships
					+ Also clear Z buffer at canvas clear
					+ glEnable(GL_DEPTH_TEST);
					+ glDepthMask(GL_TRUE); // This at initialization
					+ glDepthFunc(GL_LESS); // This at initialization
				+ Test
					+ Also FPS: 32.0 - MIRACLE?!?!?
				+ Commit
			+ Step 5:
				+ Ship/RenderContext: PlaneID->Z calculations
					+ OrthoMatrix:
						+ Rename RenderContext's as "GlobalOrthoMatrix"
						+ Ship has own per-layer, calc'd (and set as uniform) at:
							+ private ShipRenderContext::OnViewModelUpdated()
								+ Invoked at:
									+ UpdateCanvas/Zoom/Cam (use struct - @ parent - with all params)
										+ What about visible world w/h?
									+ Changed nShips at RenderContext::RenderShipsStart()
										+ via ShipRenderContext::UpdateNumberOfShips(nShips)
									+ Changed MaxMaxPlaneId at UploadPlaneIds(...) call
				+ RenderContext ans ShipRenderContext: change OnXYZUpdated/UpdateXYX pattern: no args
				+ Test
				+ Commit
			+ Step 6:
				+ ShipRenderContext:
					+ See if can get rid of optionality of ship's texture
					+ Make dedicated shaders for each layer:
						+ Current => New:
							- Ropes: ShipRopes => ShipRopes
							- Triangles:
								- ShipTrianglesTexture: if !debug && RenderMode==Texture
								- ShipTrianglesColor: otherwise
								=> ShipTrianglesTexture, ShipTrianglesColor
							  & Springs:
								- ShipTrianglesTexture: if !debug && RenderMode==Texture
								- ShipTrianglesColor: otherwise
								=> ShipTrianglesTexture, ShipTrianglesColor
							- StressedSprings: ShipStressedSprings => ShipStressedSprings
							- Points: ShipTrianglesColor => ShipPointsColor (copy)
							- GenTex: GenericTextures => ShipGenericTextures (rename)
							- Vectors: Matte => ShipMatte (copy)
					+ Complete: assign per-layer ortho matrices
					+ Test & commit
			+ Step 7:
				+ Do actual ship ortho matrix calculation at ViewModel::CalculateShipOrthoMatrix
					+ See Moleskine for calc'ns
				+ All ship shaders take new vertex attribute and calc Z via OrthoMatrix
					+ Test first with triangles layer
					+ Do all other layers and shaders next
				+ Test all layers
				+ ShipRenderContext::UploadXYZElement() do not take anymore connected component ID
					+ Dismantle ShipRenderContext connected component tracking; store everything in buffers and/or upload directly
						+ cctor:
							+ // Elements:
								+ Reserve vectors w/maxes from old func
								+ Create VBO's 
					+ Ship: nuke mConnectedComponentSizes
					+ Ship::Render: 
						+ Nuke connected component empty check
						+ if mIsStructureDirty or debug mode changed:
							+ Upload parts individually
				+ Do ship triangles correct sorting
					+ Store bool owned_by_point in Points::ConnectedTriangles (see MOLESKINE)
						+ Store it sorted
					+ Replace Triangles::UploadElements() with Triangles::UploadElements<TIndices>(TIndices const &, ...)
					+ Ship:
						+ Populate std::vector<ElementIndex> at ConnectivityVisit with owned triangle indices only
							+ vector reserved at cctor
						+ ::Render(): still when mIsStructureDirty: Triangles::UploadElements(mIndices)
				+ Verify old behavior (ship triangles in texture mode are drawn incorrectly): 
					+ With Titanic's back flag
					+ Temp triangles upload in old order
					+ Temp no springs draw 
				+ Verify new behavior: OK
				+ Put back ShipRenderContext's Springs rendering
				+ Commit
			+ Step 8:
				+ Issues:
					+ Ropes jumping ahead (when new connected components come up)
						+ Due to incorrect planeID direction on Z axis: higher plane ID (recipient of string
						  assigned to previous (lower) plane ID) must be nearer (than string and its solid body)
					+ (Edge) springs countoured with background
						+ Testable with Titanic funnel
						+ Solution: draw triangles before all
					+ Ropes and anti-aliasing issue:
						+ Option 1: draw ropes *after* triangles and springs, but still in current layer (farther)
						- Option 2: see https://stackoverflow.com/questions/30426178/lines-appear-segmented-after-enabling-depth-testing:
							- Draw ropes first (in invoke order) with Z write off (Z test is irrelevant, as it'd be the first)
								- BUT: if there's no Z write then there's no Z test among ropes, hence
								  they'd cover each other wrongly
							- Draw everything else with Z write (and Z test) on
					+ Piece of rope appears to belong to higher connected component
						+ Was to be expected - after all last segment of rope is between two points that have
						  two different plane IDs, hence a part of the last segment will be visible
						+ Possible solution is to stop doing the "smart" string plane propagation altogether
					+ When pieces belong to same plane, (edge) springs are drawn in disagreement with triangles
					  (e.g. triangles invisible but their edge springs visible)
						+ Option 1: springs are drawn in layer Z-behind
						- Option 2: depth-sort springs as well
					+ After we start drawing ropes temporally after triangles (because of anti-aliasing issue):
						+ Ropes are now occluded by transparent (texture) triangles from same plane
							+ This is because ropes layer is Z-behind triangles layer
							+ Option 1: alpha test in shader
					+ Same plane: covering is now more random
						+ Analyze visit pattern
						+ Try with deque
						+ Try with old-style visit (step 9 below)
						+ Try following raster visit using per-plane indices in final vector
							+ 1: ConnectivityVisit: populate N+1 vector with # of triangles per plane
							+ 2: Triangles::Upload: take it and send endpoints to ShipRenderContext
							+ Test
							+ If ok:
								+ Add # of owned triangles to each point (new buffer)
									+ Init to 0 at Points::Add
									+ Update count at Points::Add/RemoveConnectedTriangles
									+ Use it @ ConnectivityVisit instead of counting triangles
				+ Undefine flood rendering
				+ See if need to and can make alpha threshold higher, to eliminate artifacts around ropes close to their endpoints on 
				  Titanic's funnels
				+ Test texture mode
				+ Test structure mode
					+ See if loss of ropes over structure is ugly; if we can live without it, remove conditions and dual 
					  rope rendering
				+ Test full RenderMode x DebugRenderMode matrix:
					+ Texture, ...
					+ Structure, ...
				+ Test stressed springs
				+ Commit
			+ Step 9: cleanup:
				+ ConnectivityVisit: redo visit from L to R and thus simplify ortho matrix
				+ Remove commented-out connectivity visit
				+ Commit
			+ Step 10: generic textures
				+ GenericTextures: is now own pass that uses own plane IDs as input for Z's in shader
					+ Upload plane IDs instead of conn comp IDs
						+ Fix at all calls from:
							+ Bombs
							+ Points::UploadEphemeralPoints
								+ The texture ones can now pass real plane ID, fix call chain up to caller
							+ PinnedPoint
					+ Fix grow problem at ShipRenderContext
					+ For now keep doing per-plane partitioning of textures for depth-sorting; we'll try alternatives later
					+ Pass PlaneID into gen tex shader (which must NOT take point's vertex attrib)
					+ Try without padding?
					+ That TODO for moving allocation of vertex buffer
						+ And rename of member: mGenericTextureRenderPolygonVertexAllocatedSize
				+ Test
					+ Gen textures are correctly covered by things (ropes, triangles, gen textures) in nearer plane, 
					  and correctly cover things (ropes, triangles, gen textures) in further plane
					+ Test bombs - different planes
					+ Test pinned points - different planes
					+ Test eph particles - different planes
				+ Commit
			+ Step 11: vectors
				+ Add PlaneID to vectors
				+ Test & commit
			+ Step 12: ephemeral points
				+ EphemeralPoints: is now own pass that uses plane IDs as input for Z's in shader
				+ When eph particles are created (e.g. at Points::CreateEphemeralParticleDebris()), we write to the planeId buffer but
				  don't re-upload it; should mark plane ID buffer as dirty, but at two different segments, and then blindly
				  invoke UploadPlaneIdsIfDirty() from ship
				+ Test: eph points from multiple parts
				+ Commit							
		+ Tests:
			+ Do perf analysis to catch low-hanging fruit
			+ Run in Debug
			+ Post perf test
				+ Benchmark:
					+ Orig:
						+ Default: 30.8
						+ ConnectedComponentsTestShip1: 3.10
						+ ConnectedComponentsTestShip2: 11.6
					+ New:
						+ Default: 29.1/29.5
						+ ConnectedComponentsTestShip1: 10.4/10.6
						+ ConnectedComponentsTestShip2: 10.8/11.1

				+ Gradual reduction to smithereens (anti-matter bomb w/Titanic)
					+ Check whether slowness during gradual decomposition - due to conn visit - is acceptable
		+ Cleanups:
			+ Points: order connected triangles so that owned are first
				+ Might be best done @ insert
				+ ConnectivityVisit::population of triangle indices: cut short connected triangles' visit as soon
				  as isAtOwner==false
			+ Light spread on surface changes abruptly when piece is cut; see if it makes sense for diffuse
			  to only light points whose plane ID is behind lamp (thus planeID<=lampPlaneID)
		+ Optimizations to try:
			+ PlaneID's being float's to start with
				+ ...as long as we don't need bucketization for GenericTextures' depth-sorting
			
		+ See if drawing springs & triangles at separate depths also helps generally with render speed, even for one single
		  connected component (for springs' fragment shader - may be it takes shortcuts if it knows it's behind)
	+ Use VAO's (*)
		+ Branch
		+ New OpenGLObject w/deleter
		+ Stars
			+ ShaderManager: allow for reusing numeric values
				+ UTs
			+ BoundedVector
				+ UTs			
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test			
		+ Clouds
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test			
		+ Land
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test			
		+ Move vertex attribute enabling out of shader manager and, for now, to where it is described
		+ Ocean and rest of RenderContext
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute names)
			+ Test			
		+ Verify asm for Upload->emplace_back
			+ @ Stars::Upload
		+ TextLayer
			+ Test
			+ Then, move upload to VBO right after creating vertices
			+ Test
		+ Ship:
			+ GenericTextures
				+ Code
				+ Shaders
				+ Test 
					+ Different planes
				+ Commit
			+ Vectors
				+ Code
				+ Shaders
				+ Test 
				+ Commit
			+ Ship:
				+ One per "input configuration" + vertex element array 
					+ Make sure to bind element array indices to the VAOs
				+ Have to repeat descriptions
				= Code
					+ Do explicit element array binding :-(
					+ Reduce VAOs
						+ To 1; nuke DescribePointVBOs()
					+ Reduce other calls
						+ LineWidth
						+ Texture activation and binding
				+ Shaders
				+ Test
				+ Commit
			+ Cleanup:
				+ RenderCore.h/cpp: remove unused attributes and other TODOs
		+ Get new FPS
		+ Merge
	+ Misc OpenGL Optimizations (*)
		+ Try all of these in isolation, or building on the previous one if the previous one is a clear winner
		+ Try STREAM with ship VBO buffers (apparently should do it without even testing!)
			+ RenderContext:
				+ Water, Land, Clouds
			+ ShipRenderContext:
				+ Mutable point attributes (pos, light, water)
		+ Try orphaning VBO
			+ RenderContext:
				= Water, Land, Clouds
			+ ShipRenderContext:
				= Mutable point attributes (pos, light, water)
			+ Figure out if should do null+subdata vs data
			+ Verdict: no detectable improvement
		+ Try with single VBO for elements, appending stuff to it
			+ Test:
				+ Dynamics between structureDirty changes and debugShipModeRender changes
			+ See if can cleanup enforced order between triangles and others
		+ ShipRenderEnd(): see if using the same shader for triangles and springs buys us anything
			+ Not really
	+ Vertex Buffer Optimization (*): reduce number of vertex attributes for ship shaders 
		+ We've already confirmed that one less attribute vertex sends FPS frpom 29 to 30
		+ At this moment, all Ship shaders - except for stressed springs - have the following inputs:
			in vec2 inShipPointPosition;
			in float inShipPointLight;   *
			in float inShipPointWater;
			in vec4 inShipPointColor;    *
			in float inShipPointPlaneId; *
		+ Test 1: Light + PlaneId
			+ Requires "float planeID" work item first
			+ Code
				+ Points: make struct, with comment on "rendering performance"
			+ Shaders
			+ Test 
			+ See FPS: 29.3/29.7/29.9/30.8
			+ If good:
				+ Commit
		+ Undo V->F shader in/out packing which we did at TrianglesTexture 
			+ And move wetness calculation into vertex shader for all
			+ See if there are other shaders as well
			+ See if want to keep it:
				+ FPS: 29.8/29.9/
		+ Test 2: += Water + Pad
			+ Code
				+ Note: includes workBuffer copy @ WaterDynamics!
				+ GameTypes:Add to PointAttributeGroup1
				+ Points:
					+ Remove buffer
					+ Change getter & setter
					+ Wo workbuffer copy (replace water one)
				+ Ship::WaterDynamics
					+ Use PointAttributeGroup1.Water instead of Water
				+ RenderContext:
					+ Nuke upload water vector
				+ ShipRenderContext:
					+ Nuke upload water vector
					+ Describe new vertex attribute
					+ Nuke RenderCore::AttributeType
					+ Shaders
			+ Test
			+ Get FPS
				- Make sure laptop is quiet
			+ New Perf Analysis
			+ Commit if good
		+ Test 3: other shaders
			+ None
		+ Test 4: Bas' idea
			+ Revert to before Test 1
				+ ...but keep shaders
			+ Do interleaving just at ShipRenderContext
			+ Test:
				+ Light
				+ Water
				+ Vectors
			+ Check assembly
			+ Unbind VBO
			+ Check FPS:
				+ 30.0/30.4/31.1/31.2 (supercharged)/31.7
			+ Commit			
		+ Test 5:
			+ ShipRenderContext: use MappedBuffer
				+ GameOpenGLMappedBuffer<TElement, WRITE_ONLY>
					+ Map(size)
					+ emplace_back(...)
						- w/assert that is mapped
					+ Unmap()
					+ ~()
						+ Unmap if mapped
					+ Remove that ugly GameOpenGLObject()
				+ Use where we upload temporarily to local buffer:
					+ Clouds
					+ Land and Ocean
				+ Check if good and, if so, commit
					+ 30.25/30.3/30.4/31.0/31.15
		+ Test 6:
			+ See if can also interleave Position and TextureCoordinates
				+ Name the other "AttributeGroup2"
					+ Fix all
				+ Make new "AttributeGroup1"
					+ Uploaded straight at ShipRenderContext::UploadPointMutableAttributes()
				+ Shaders
			+ Check perf:
				+ FPS: 30.7/30.7/30.8/30.9/32.0
				+ U/R: 193%
			+ Commit
		+ Do perf analysis
	+ Points' buffer perf improvement
		! Test perf: allocate (and thus upload) Points' mutable attributes in one single buffer 
		+ Changes to Buffer:
			+ Hierarchy with two Buffers:
				+ 1: 
					+ static size_t CalculateByteSize(size_t elements)
						+ Also use at UTs
					+ cctor that takes shader_ptr<uint8_t *>, byte offset, et al
					+ No swap(.)
					+ Add UTs
				+ 2:
					+ Like now (makes and owns own buffer)
					+ Yes swap(.)
						+ Add UT
		+ Replace Points' individual buffers with:
			+ 0: ElementContainer(SysSpecifics::make_aligned_float_element_count(.))
				+ Move logic out of ElementContainer
			+ Undo changes to containers
			+ ElementContainer:
				+ See if iterator could be the range iterator
					+ If so, add one for buffer
					+ If so, use the one for buffer @ 2 places in Ship_Interactions.cpp
			+ 1: mMutableAttributesBuffer == unique_aligned_buffer, SysSpecifics::make_unique_aligned_buffer...(byte size)
				+ Calc total byte size via Buffer<T>::CalculateByteSize(size_t elements)
			+ 2: Buffers offseted to three portions, using sums of Buffer::CalculateByteSize(.) for previous
		+ Then do a single upload
		+ Perf: has decreased!
	+ Try interleaving Update's with Render's
		! First, quick and dirty: do at stars, clouds, ocean
		+ GameController:
			+ Nuke Update() and Render()
				+ 1) Update: used by step-by-step
					+ Replace with GC::PulseUpdate()
						+ Sets mIsPulseUpdateSet
						+ RunGameIteration(.) checks it together w/pause, and always clears it
				+ 2) Render: OnPaint
					+ Should not be needed anymore, nuke it
			+ 3) Replace implementation of RunGameIteration(.)
				+ Incorporate (and then nuke) inline the implementations of InternalUpdate and InternalRender
					+ i.e. end up calling World::Update and World::Render directly, one after the other
			+ 4) Test
				+ Normal
				+ Pause, step-by-step
				+ Resize, minimize/maximize, fullscreen/nofullscreen
		+ 5) GameChronometer
			+ using std::steady_clock
			+ Use
		+ World:
			+ Replace Update(...) and Render(...) with 
			  UpdateAndRender(..., bool doUpdate, GameChronometer::duration & updateElapsedTime, bool doRender, GameChronometer::duration & renderElapsedTime)
			  + GC passes mTotalUpdateDuration& & friend&
			  + For now as-is
		+ Test
		+ Make status text in millis
		+ Perf improvements:
			+ Start: Default: FPS=30.0, U/R=22.x/10.x, pause:R=21.5; Ball of Iron: FPS=49.0-50.0-55.0F, U/R=5.x/14.x, pause:R=19.9
			+ First: move RenderStart at beginning and see if it's worse
				+ Test on all boxes
					+ Samsung: 90/11
			+ Call World::UpdateAndRender just once
			+ World::UpdateAndRender(.):
				+ Remove doRender arg
				+ Interleave at:
					+ Sky
					+ Ocean
			+ Advanced:
				+ Breakup sky rendering:
					+ Update+Render Stars
					+ Update ...
					+ Render Clouds

+ Dynamics
	+ Try half of the relaxation iterations
		+ Might need to adjust stiffness
	+ Adjust springs stiffness
		+ Test other values:
			+ 0.1 => should break faster : YES
			+ 1.7: explodes
		+ Test with same strain also for compression	
			+ And force at 0.0058
		+ Test with slightly higher stiffness - see if less bending but same breaking
	+ Realistification:
		+ Ship::Damp: damping 3 times at end should have the same effect
		+ Exploding ship:
			+ Check if higher damp factor helps: was 0.5, now 0.8
		+ Spring equilibrium: 
			+ Find right overshooting factor (may be slightly smaller)
			+ Compare behavior with old game
				+ Steel Ball and broken default ship in old game: explodes? yes
	+ Test completely force-driven dynamics:
		+ Create branch
		+ Each iteration (test initially with 1 iteration per step; then see with more, but scale dt)
			+ Apply forces: 
				+ For each spring:
					+ Spring force (Stooke's law - need k, try fixed at first)
					+ Damping (try along spring first - like now)
					+ see https://www.scss.tcd.ie/Michael.Manzke/CS7057/cs7057-1516-14-MassSpringSystems-mm.pdf for equations
			+ For each point:
				+ Gravity (with buoyance)
				+ Drag
			+ Apply verlet integration
			+ Zero force
			+ ...do tension strain check...
			+ ...electrical and water...
		+ Improve:
			+ Masses				
			+ Gamma - from original (NOT from original, doesn't work)
			+ Better grab force:
				+ Have optional<float force, vec2f position>; at each iteration, if not none:
					- Do force spreading with force/NumIterations
				+ Also, all non-static GameParameters initialized at cctor in cpp				
				+ Check ropes afterwards
			+ Collision with sea floor and (original) "bounce"
				+ v += adjusted Pos - pre-adjusted Pos
				+ Double-check new V
			+ Make SimulationStep a templated constant (double and float)
			+ Clean up code
		+ Perf:
			+ Get baseline:
				+ FPS: 15.8
				+ GameController::DoStep: 44.98%
					- UpdateDynamics: 32.96%
						- UpdateSpringForces: 15.33%
						- UpdatePointForces: 8.51%
							- GetWaterHeight: 5.24%
							- fminf: 1.23%
						- SeaFloorCollisions: 5.40%
							- GetOceanFloorHeight: 3.69%
						- Integrate: 3.71%
					- BalancePressure: 5.70%
					- GravitateWater: 4.30%
				+ MainFrame::Render: 46.67%
			+ Do constants
				+ FPS: 16.15
			+ Do Spring.XYZFactor/s
				+ See if can get rid of dt parameter in funcs
				+ FPS: 16.25
			+ Do Point.MassFactor
				+ const calc'd at cctor via GameParameters::dt and GameParameters::numIterations
				+ See if can get rid of dt parameter in funcs
				+ FPS: 16.50
			+ Do cached WaterHeight and ocean floor height
				+ Also useful for LeakWater()
				+ If period chosen wisely (< expected ship world width), saves on calculations
				+ Physics::WaterSurface class, only visible by World, which exposes own getters
					+ cctor(): allocate buffer
					+ Update(currentTime, gameParameters): populate buffer
					+ GetWaterHeight(x): 
						+ Convert x to absolute sample index, via dx and taking floor
						+ Interpolate height between asi%buffer_size and (asi+1)%buffer_size
				+ At end:
					+ Remove gameParameters from World::GetWaterHeight and cleanup World.h
				+ Optimize
			+ Get baseline:
				+ FPS: 17.0/17.2
				+ GameController::DoStep: 41.85%
					- UpdateDynamics: 28.10%
						- UpdateSpringForces: 13.90%
						- UpdatePointForces: 5.87%
						- HandleCollisionsWithSeaFloor: 4.27%
						- Integrate: 4.24%
					- BalancePressure: 6.47%
					- GravitateWater: 4.88%
					- LeakWater: 0.22%
				+ MainFrame::Render: 48.99%
			+ Test fma in Integrate()
				+ check assembly: REJECTED, it's function call!
			+ UpdateSpringForces:
				+ Don't check for IsDeleted, but just set coeff's to zero for deleted springs
				+ FPS: 17.4/17.5
			+ Spring::WaterPermeability
				+ Set to 0.0 if hull spring or deleted, else 1.0f
					+ Set at cctor
					+ Set to 0.0 at Destroy() ("...avoid draining water to destroyed points...")
				+ Remove two if's at BalancePressure and GravitateWater
				+ FPS: 17.3/17.5
	+ Set springs' K in material
		+ Multiplies with C (0.8) in Spring::CalculateStiffnessCoefficient()
		+ Fix Titanic masts
			+ See if need to increase iterations
			+ Testing wood: 1.10 to 1.15
		+ Fix ropes (they don't move as fluid and continuous as before)
			+ Test with own K for ropes (start with half K)
		+ Change exponential of StrengthAdjustment, for expanded small values
			+ 0.001+((exp(x/70)-1)/2.3)^3.4
			+ Verify inverted formula
			+ finalize default StrengthAdjustment: 0.03421?
	+ Pin points
		+ Point::TogglePin():
			+ If pinning: set MassFactor to zero, and set velocity to zero
			+ If unpinning: recalc MassFactor (using same helper used at cctor)
		+ The entire search is implemented by Points
			+ Together with isPinned (used at search to avoid pinning pinned point), also maintains
			  stack of pinned point indices
				+ Toggle: find topmost point in stack merely within radius; if found -> toggle it & remove from stack 
				  & mark as dirty for re-upload and return true; 
				  + else: find closest non-pinned point; 
					+ if found: toggle it & add to stack & mark as dirty for re-upload & return true
					+ else: return false
				+ Destroy: also remove from stack, if there
					+ And if there, mark as dirty for re-upload
		+ Given that connected component changes affect rendering of pinned points:
			+ Move stack and mArePinnedPointsDirty back into ship, together with search logic
				+ Points gets back Pin() and Unpin()
				+ Ship::Destroy as well
			+ Pinned points are uploaded by decision of Ship
				+ Decision: if mAreElementsDirty || mArePinnedPointsDirty
				+ Ship does start & end & points
		+ ShipRenderContext: draw pinned points using texture (centered)
			+ Ship uploads coordinates and ConnectedComponentID of point
			+ ShipRenderContext: behave exactly as with StressedSprings (i.e. reset at ElementsStart()), as 
			  we're sure we'll re-upload pinned points when elements are dirty
				+ Rename as "Elements"
				+ Do with buffer
				+ Calc bounding box, centered over point, like clouds
			+ Render(): draw at very end of each connected component render, after stressed springs
			+ Redo cursor and move to \textures
		+ Tool just toggles:
			+ Ship checks if exists pinned point in radius: if yes, unpin; else, pin
			+ Returns true if points belongs to ship, so to stop search by World
			+ Cursor is a pin
		+ ShipRenderContext::UploadPinnedPoint(): do pinned point insertion at end of own connected component
		+ Texture: 
			+ lighter
			+ plug hole
		+ Fix crash when loading Titanic
		+ Max 64 pins
			+ CircularList
				+ Add() is templated on OnRemoved() handler
					+ When over, older are removed
				+ Unit tests
			+ Constant at GameParameters
		+ Spring deletion at stress: also unpin endpoint if the endpoint has no more springs attached to it
			+ Requires global destroy handler above
			+ Do at Ship::SpringDestroyHandler
		+ SoundController reacts to IGameHandler event (true/false) with two sounds (Pin/Unpin)
			+ Random choices, Over/Underwater - NO material
				+ Update sink event
			+ Do sounds:
				+ 4 pin
				+ 4 pin underwater
				+ 4 unpin
				+ 4 unpin underwater
	+ Find sweet spot of stiffness and strength between bending and more strength for pinning
		+ stiff: 0.500750
		+ strength: 0.006200
			    0.005376
		+ pinning: fine (can't pin when it's very fast)
		+ wood: 2.0 (titanic masts like before)
		+ new titanic structure
	+ Cosmetics:
		+ Explain Spring's coefficients (in terms of fractionXYZ* of return-to-rest-length, etc.)
		+ Rename Points::MassFactor as IntegrationFactor and explain
	+ Is Verlet implemented right?
	+ Review parallel calculation, it suffers from races
		+ Also See if can continue queueing tasks without waiting for all blocks of chunks
	+ Bombs:
		+ Spec:
			+ Placed and removed with similar tool as Point Pinning
			+ Two types of bombs: timer and remote controlled
			+ A bomb explodes when:
				+ Its timer times out or the remote control is triggered
				+ The point it's attached to is destroyed 
				+ A point or spring in the "neighborhood" (a separate, small radius) is destroyed (includes nearby explosion)
			+ When one or more bombs are detonated, ship needs to know only position, connected component ID, and blast radius, 
			  not even point index
				+ Thus (exploded) bombs are independent from lifetime of point that they were attached to,
				  allowing ship to destroy point immediately at first step of detonation, for example
				  if we have multiple-step detonations
				+ By not using point index we allow explosions to affect multiple connected components (of same ship though)
			+ Bomb decides for itself when it's to be deleted, and Bombs consequently removes it from
			  collection (and from point indirectly via Bomb::Destroy which, if attached to point, calls Points::Detach)
				 
		+ Impl:
			+ Final test
			+ TEST: bombs are attached to springs instead of points
				+ Move isAttached buffer from Points to Springs
				+ Move mass trick to springs
				+ Bomb position becomes positionA and positionB (bomb attached across)
					+ Also BlastHandler argument is positionA and positionB
					+ Blast calculated's by ship from middle point
				+ inline Springs::GetPointA/BPosition(Points const &)
				+ Points::SetMassToMaterial(float ~offset)
				+ Restructure positionA and positionB:
					+ Freeze position and rotation offset, not positionA and positionB
				+ Fix calculation of alpha - check just zero
			+ TEST: lead-in: continuate ping counter, just different velocity and different translation to frame index
			+ TEST: 360 rotation
			+ Fix mass augmentation
				+ Also update springs' coefficients
			+ Fix blast flipping
			+ TEST: run in debug
			+ FIX: first blast handler is so small that it doesn't find point in radius
				+ Go linearly from 0.6 to BlastRadius
				+ At end, re-enable texture frame for explosions
			+ FIX: ContinuousSound start while paused issue
				+ DesiredState
			+ FIX: TimerBomb x,y offsets
				+ Restore cursor hotspot
				+ Add temporarily fixed world offset at ShipRenderContext
					+ Desired center: 147, 228 off 300, 300 => +3, -78 over 12.0, 12.0 makes 0.12, -3.12
				
			+ Bomb base class, w/type enum
				+ Update(OnBombExplosionStep(position, radius)) -> bool = 0: 
					+ Runs state machine with local clock
						+ Advances animations (textures of bombs, sounds via events)
					+ Invokes handler for each explosion step
					+ Returns false when needs to be deleted
				+ GetRenderFrameIndex() -> size_t
					+ Specialized for state machines
				+ NeighborhoodDisturbed() = 0
					+ Invoked when needs to explode because own or near point is disturbed
			+ Two subclasses - TimerBomb and RCBomb
				+ RCBomb:
					+ RCBomb::Detonate(): input to state machine
					+ Update():
						+ Basics
						+ Explosion
					+ Finalize GetArea(): decide if new enlarged explosion looks good
					+ NeighborhoodDisturbed()
						+ Equivalent to RCDetonate()
				+ TimerBomb:
					+ Update(): state machine
						+ Sparkles: sort frames by distance on fuse and do random choice on sliding window
						+ Add a base frame of bomb with no fuse
							+ Rename all frames
							+ Fix calculation of base frame count at Update()
						+ Smoke:
							+ 3 sequential frames
					+ NeighborhoodDisturbed()
						+ Explodes only if state machine duration < own time left
			+ Bombs class
				+ Not ElementContainer, just manager
				+ cctor takes shared_ptr<IGameEventHandler>, ExplosionHandler, Points &
				+ Update(OnBombExplosion(position, radius)) -> void
					+ Runs through all bombs and invokes ::Update() on each
					+ Removes a bomb if its Update() returns false
						+ Detach it if attached
				+ ToggleTimer/RCBombAt(position) 
					+ same logic as pinned points
					+ returns boolean
				+ DetonateRCBombs()
					+ Calls Detonate() at each RCBomb
				+ Upload(RenderContext)
					+ Always upload all bombs, each w/current render frame index
				+ OnPointDestroyed(idx)
					+ For each bomb:
						+ If bomb is attached to this point:
							+ Detach bomb from point
						+ If bomb within (new, smaller) radius from point:
							+ Call bomb->NeighborhoodDisturbed()
				+ OnSpringDestroyed(idx)
					+ Bombs also takes Springs
					+ For each bomb:
						+ If bomb within radius (new GameParameters parameter, smaller) from spring mid-point:
							+ Call bomb->NeighborhoodDisturbed()

			+ Points also has bool HasBombAttached buffer for interactions & lookups, just like pinned points 
				+ Also changes mass (just at point, for gravity only...)				
				+ Flag and mass change is done at Points::AttachBomb()/Points::DetachBomb() 

			+ Events:
				+ OnRCBombPlaced/Removed(size, underwater): used by MainFrame to enable/disable detonation menu item
					+ Also invoked when explodes
				+ OnTimerBombPlaced/Removed(size, underwater): used by SoundController to start/stop and set volume
				  of timer bomb sound
					+ Also invoked when explodes
				+ OnBombDetonated(size): used by SoundController 
				+ OnRCBombPing(size): used by SoundController 

			+ Ship implements:
				+ ToggleTimer/RCBombAt(position)
					+ FW to Bombs
				+ DetonateRCBombs()
					+ FW to Bombs
				+ @Update(): invokes Bombs::Update() w/handler
					+ After spring stress check, so explosion is visible before it breaks things up
				+ @Render(): invokes Bombs::Upload(RenderContext)				
				+ Ship::PointDestroyHandler: 
					+ Bombs::OnPointDestroyed(idx)
				+ Ship::SpringDestroyHandler: 
					+ Bombs::OnSpringDestroyed(idx)

			+ RenderContext:
				+ RenderContext:
					+ Load textures
						+ RC bomb
						+ Timer bomb
						+ Make sure textures are sorted by index
							+ First index for multi-frame is 0 in filename as well
					+ Forward calls
				+ ShipRenderContext
					+ Buffers just like pinned points
					+ Render
			+ MainFrame/Tool:
				+ Register for events and process OnRCBombPlaced/Removed() to enable
				  Detonate menu item
				+ Load 2 cursors
					+ Set hotspot
			+ SoundController:
				+ Event handlers

			+ Media:
				+ TimerBomb cursor
				+ RCBomb cursor
				+ TimerBomb textures:
					+ Bases w/different fuse lengths
						+ With fuse burning, separate unlighted frames
					+ Explosion frames
				+ RCBomb textures:
					+ Base
					+ Pings
					+ Center
					+ Explosion frames
				+ Bomb explosion sounds
					+ N1 normal, N2 underwater
				+ RCBomb ping sounds
					+ 1 normal, 1 underwater
				+ TimerBomb fuse sound
					+ 1 fast, 1 slow
				+ Timerbomb defused sound ("sizzle")
				+ Bomb placed sounds
					+ N1 normal, N2 underwater
				+ Bomb removed sounds
					+ N1 normal, N2 underwater

		+ Bomb explosions: see if better done with force fields
			+ At each explosion frame: radial forces, centered at center, strongest at radius=f(expl frame)

		+ 3rd type of bomb: anti-matter bomb
			+ [Do after texture json]
			+ When it explodes: first sucks everything in, then evertyhing out
				+ Controllable also via ultra-violent mode
				+ Uses "ForceFields" (rename of "ToolForces": applied at each iteration of UpdateMechanicalDynamics and then cleared)
				  for suck-in
					+ ForceFields.cpp/h
					+ Move swirl, grab, bomb explosion to this one
			+ Requires ExplosionType argument at Ship::BlastHandler, or new BlastHandler altogether
				+ Or see if easy to move BombBlaster inside bomb (i.e. explosion code is in bomb's state machine)
				+ Or another way
			+ Plan:
				+ Media:
					+ Sound: continuous (3 choir tones)
					+ Sound: implosion_one (FM)
					+ Sound: implosion_two (whirring, up)
					+ Sound: explosion
						+ Choir with delayed repetitions
						+ First choir is mixed with electronic thud
						+ More emphasys on initial explosion
						+ Redo eventually, with long LFO
					+ Texture: armor
						+ Diagonal arms as well?
					+ Texture: ball, empty
					+ Texture: ball, cloud content
					+ Cursor
				+ Texture DB:
					+ Textures.js
					+ New groups in enum
				+ Sound controller:
					+ New additive continuous sound (like fuse) with random choices and volumes for each
					+ Others
				+ Bomb::IPhysicsHandler
					+ Implemented by Ship
					+ Passed to Bombs and stored as GameEventHandler (i.e. *)
					+ Test 2 old bombs
					+ Create force fields
				+ ForceFields
					+ Move DrawTo and Swirl
						+ Test
						+ Clear ToolForce's
					+ Commit
					+ PreImplosion
					+ Implosion
						+ Trim sound and shorten state machine interval to match
						+ Test coriolis - angular F depending on V of point
						+ Test with angular F being stronger when closer to center
						+ Test with mass-independent accelerations (divide forces by mass)
						+ Test with progress moving along 1/(x-a)
						+ Multiplier for ultra-violent mode
						+ Cleanup force field
					+ Explosion
						+ Add to centrifugal

			+ Lower volume of all breaking/stress (passive) sounds
				+ class GameSound : sf::Sound
					+ setVolume
					+ setMasterVolume
					+ setMuted
						+ each sets volume immediately, no checks
					+ Test:
						+ master volume changes only affects currently-playing category
						+ master volume changes affect future sounds
						+ play farewell sound affects currently playing
						+ play farewell sound affects future music
				+ Find another version of volume sum
				+ Then test again break and stress sounds for volumne
				+ Need to mark CurrentlyPlayingSounds as expendable or not			

			+ Animation:
				+ Cloud rotation slows down during pre-implosion, down to a halt					
				+ Then starts slowly again from the other way around, with v=square of progress
				+ Cross of light
			+ Misc:
				+ Can get rid of deletion checks in force fields?
				+ Test fuse's (slow and fast) sounds for new ContinuousSound architecture
				+ Prevent removal if not in containment (i.e. if detonated already)
					+ Bomb::MayBeRemoved()
					+ Test with all 3
	+ Swirl tool
		+ Force applied is r * AngularForce; AngularForce==m*AngularAcceleration
			+ CW; if Shift -> CCW
		+ Cursors
		+ Need own sound - replicate Draw infrastructure and use different drill
	+ Fix power bar room at all cursors
		+ Try: MakeCursors: make non-transparent pixels green or red, multiplying
	+ Saw
		+ Spec:
			+ Deletes springs (and affected triangles) that cross the *path* of the tool
			+ Continuous sound, overwater and underwater, depending on where x,y is
		+ Impl:
			+ Media:
				+ Cursor up and down
				+ Sound
			+ Events:
				+ Need boolean true/false for sawing
			+ Tool:
				+ L-Down: 
					+ prevMousePos = mouse X, Y
					+ Fire event (asking GameController for game event handler)
					+ Set new cursor
				+ L-Up: 
					+ Reset prevMousePos
					+ Fire event (asking GameController for game event handler)
					+ Set new cursor
				+ Move: if l-down:
					+ if has prevMousePos:
						+ GameController->Saw(prevMousePos, current)
					+ prevMousePos = current
			+ Ship:
				+ Do EnumFlags class in EnumFlags.h
					+ Use it 2 X in Springs
				+ Make sure Spring::Destroy only deletes triangles that share one edge with the spring
					= Nuke Point::Breach and do everything instead in Ship's destroy handler, driven off
					  Springs::DestroyOptions
				+ Test whether should fire the Break event even if only springs are deleted 
					+ For points we fire the event in the ship's PointDestroyHandler; if we
					  want to fire now from ship's SpringDestroyHandler, we must be told whether 
					  the spring destruction comes from a point destruction or not: FromPointDestroy vs FromSpringDestroy
					  + If we do this, we can now also remove firing of break from within Springs::UpdateStrains,
					    as the ship's SpringDestroyHandler would be invoked with FromSpringDestroy
				+ Use Geometry::Segment::TestIntersect()
					+ Also add to it GetAngle...
						+ Move from Texture Rotation
					+ Move also AABB to Geometry
			+ SoundController: new continuous sound
				+ Also underwater
	+ Ultra-violent flag: very strong Draw and Swirl forces
	+ Buoyancy redesign:
		+ test with hack what would happen if all non-hull materials were 1/nth of the mass
		+ python script: allow empty cells (skip cols if != index)
			+ Make template more compact
		+ Regenerate template
		+ Re-check bomb weight
		+ Regenerate template
		+ If ok:
			+ Before unhack: fix ships:
				+ Do Masts and investigate mass effect on breakage
				+ Fix Titanic:
					+ Lighter rudder
					+ Also generally Lighter?
					+ Stronger under funnels (make tin stronger?)
					+ Make it break
						+ Study tension based off mass
							+ Solve integral manually
							+ Do tests
						+ Softer again under funnels
					+ Fix mast
					+ Glass breaks immediately
				+ Fix Base III: make it float
					+ Larger base, boat-shaped
					+ See if it's cooler if it floats more (another floating level)
					+ See with thicker columns (make a new one and call it Base II)
				+ Fix default ship: just lighter
				+ Fix cargo ship
					+ Y offset
				+ Fix Carnival - lighter
				+ Fix Krafting - no sudden stress
			+ Rewrite buoyancy code - use WaterMass
			+ Change materials
				+ No Mass but object with:
					+ nominalMass
					+ density
				+ Springs: get mass from points, not from material
				+ Add density = [copy from current hack] 1/6th for hull, 1/(6*10or4)
				+ Material loading: just store mass*density at mass
			+ Redo Materials Template
			+ Watch out for strength: it was (/ mass * 1000)
			+ Fix strength adjust
				+ Fix max, min
					+ Rethink exponential slider: takes also midpoint (1.0 for us) and then it's two exp curves
		+ Add to change list
	+ Fix buoyancy
		+ Maintain trick with which hull points don't feel buoyancy (or else wood hull would never sink)
		+ Adjust gravity force though
		+ See perf (orig was 3.36%)
		+ Cleanup old
		+ Commit
	+ Make collisions with sea floor more dramatic
		+ Bounce velocity with specular vector
	+ Ephemeral Particles:
		+ Spec:
			+ Carve out fixed-size room at tail of Points for ephemeral particles				
				+ Each has own lifetime
			+ Ephemeral particles cannot be deleted
			+ Rendering: via:
				+ ShipRenderContext::UploadEphemeralParticlePoints (e.g. for points)
					+ Just indexes
					+ Color/alpha portion of buffer has to be uploaded first
				+ ShipRenderContext::UploadGenericTexture (e.g. for bubbles)
					+ Need to also support alphaTransparency
			+ Ephemeral particles are drawn with own color, including alpha going to transparent as lifetime increases
				+ Test first perf impact of using vec4f for point colors
					+ If sucks a lot, will need new extra buffer just for points' alpha
						+ Also this buffer is segmented
				+ Ephemeral portion of entire points color buffer needs to be reloaded at each Upload() 
				  or UploadEphemeralParticles() (2*)
					+ Use glSubBufferData
					+ If we go for separate alpha buffer: also do for ephemeral portion of alpha buffer
		+ Impl:
			+ Test vec4f for colors
				+ Points
				+ ShipBuilder
				+ RenderContext/ShipRenderContext
				+ Shaders
			+ Set max eph particles to 1024
			+ Points allocs extra room
				+ Also stores ship point count and start index
			+ Points has new buffers:
				+ EphemeralType (uint8 enum)
					+ None (set at non-ephemeral and at dead ephemerals)
					+ Debris
					+ Sparkle
					+ AirBubble
					+ Smoke
				+ EphemeralStartTime (clock point)
				+ EphemeralMaxLifetime (std::chrono::milliseconds)
				+ private: 
					+ EphemeralState: union of public structs (much like ElectricalElements::ElementState)
						+ Debris: {}
						+ Sparkle: {}
						+ AirBubble: {}
						+ Smoke: {}
					+ Buffer<EphemeralState> mEphemeralStateBuffer;

			+ Ship: limit point range:
				+ @ destroy tool, @ bombs explosions, and @ anything else that destroys point: do not destroy ephemeral points
				+ @ toggle bombs: do not attach to ephemeral points
				+ For all of these: use Points::NonEphemeralPoints iterator, or check EphemeralType != None, depending on the case
						
			+ Points::CreateEphemeralParticleDebris: 
				+ Args:
					+ Position, Velocity
					+ MaxLifetime
					+ Material *
						+ Requires MaterialDatabase to be handy at invoker of CreateEphemeralParticleDebris
							+ Ship must take a DB by value at cctor
						+ Though Debris uses spring's material
				+ Impl:
					+ Find first expired particle; if not found, pick the oldest
						+ Requires mFreeEphemeralParticleSearchStartIndex
						+ In private ElementIndex FindFreeEphemeralParticle()
							+ sets mFreeEphemeralParticleSearchStartIndex
					+ Store Color, Position, Velocity
					+ Store Mass
					+ Do any other initializations that we do at Points::Add(...)
					+ Store MaxLifetime, and zero lifetime
					+ Set mAreEphemeralParticlesDirty = true

			+ Points::UpdateEphemeralParticles(clockNow):
				+ For each point, check lifetime vs max lifetime
				+ If time has expired (now):
					+ No need to mark as deleted to hide them, EphemeralType==None suffices to prevent them from being rendered
					+ Reset velocity and integration factor of expired particles to avoid drifting
						+ Rename Points::Pin/Unpin() to Freeze/Thaw()
					+ Set EphemeralType to None
					+ Set mAreEphemeralParticlesDirty = true
				+ Else: do per-type state machine, with dispatch coded in method depending on type, invoking 
				  per-type state machine method; for example:
					+ Those that are points:
						+ Calc remaining life
						+ Update alpha either in (portion of) color buffer or in (portion of) alpha buffer
					+ Those that are textures:
						+ Calc remaining life

			+ Points::UploadEphemeralParticles():
				+ 1) Upload portion of color buffer/alpha buffer specific to ephemeral particles
				+ 2) If mAreEphemeralParticlesDirty:
					+ RenderContext::EphemeralPointUploadStart()
				+ 3) For all ephemeral points with EphemeralType != None: use dispatch coded in method depending on type, invoking 
				     per-type upload method; for example:
					+ Those that are points:
						+ Add point index to a buffer
					+ Those that are textures:
						+ Call directly ShipRenderContext::UploadGenericTexture(...)
				+ 4) If mAreEphemeralParticlesDirty:
					+ RenderContext::EphemeralPointUploadEnd()
					+ Set mAreEphemeralParticlesDirty = false

			+ Ship::UpdateEphemeralParticles(clockNow):
				+ Calls Points::UpdateEphemeralParticles(clockNow)
				+ Emits ephemeral particles from emitters (e.g. smoke)
					+ For now empty
		+ Cleanup:
			+ See if can control debris generation via GameParameters, which must be made available at 
			  Ship::SpringDestroyHandler
		+ Tests:
			+ Pin ephemeral particle
			+ Many connected components
	+ Do debris each time a spring breaks
		+ Look'n'feel: 
			+ Points of the color of the spring's material
				+ Actually, points of the spring's material
		+ At Ship::SpringDestroyHandler()
			+ Choose 0, 1, or 2 debris // Experiment
			+ For each:
				+ Material = spring's material
				+ Position = midpoint of spring
				+ Velocity = point on circle as:
					+ Radius: random in [1, 5] // Experiment
					+ Angle: random in [0, 2PI]
				+ MaxLifetime = from GameParameters static const, plus random factor in [0.5-1.0]
		+ Debris:
			+ Update: 
				+ Update color's alpha based off remaining lifetime, linear
			+ Upload: 
				+ Just store index in buffer

		+ Test look'n'feel and finalize constants
	+ Ocean depth bitmaps
		+ OceanFloor cctor takes ResourceLoader
		+ ResourceLoader used by ocean floor to load image
		+ OceanFloor translates image into float[] with raw pixel y's
		+ At update, raw pixel y's are normalized/enhanced with new GameParameters constant
		+ Test	
	+ Slider for "simulation quality", affecting num of mechanical simulation iterations
		+ Update GameParameters - Points and Springs might have to recalc things on changes
			+ Ship
			+ Points
			+ Springs
		+ Fix: invoke points.updategameparams
		+ SettingsDialog: under mechanics tab
		+ Requires extended status text w/measurements
		+ See what to do with stiffness setting: max 1.0f? Leave it
	+ Fix ephemeral particles
		+ Pass also "now" all over the place
			+ End put back UpdateEphemeralParticles where it was
		+ Just single vector of PointIndex, no connected components
		+ Make ephemeral particles' update based on simulation clock, not wall clock
			+ "now" passed everywhere really has to become a "simulationNow" float
		+ Test
		+ Finalize constants
	+ Do chainsaw sparkles with Ephemeral Particles
		+ At Ship::Chainsaw for each broken spring
		+ Initial particle dynamics:
			+ Position: midpoint of spring
			+ Velocity: radial vector:
				+ Butterfly perpendicular to *direction of sawing*, not spring
				+ Magnitude: uniformly random in range
			+ Number: per Update step: uniform random centered around SparkleDensity (ratio over 10, initially) (from GameParameters, adjustable)
			+ Color:
				+ Metal: brightest red to bright red
				+ Else: base material's render color
			+ Finalize parameters
			+ Final test
	+ Add cloth material
		+ Test, basically rope-like but no rope
			+ Low stiffness, hight strength
		+ If fine:
			+ Make it for all basic colors
			+ Structural Template:
				+ Cloth and Rope on same row
				- Redo
			+ Cloth sound			
			+ Make ship with Dutch and Italian flags
	+ Buoyancy rearc
		+ Double-fix for rope/buoyancy/hull unhack and fast-falling wet rope/cloth
		+ First of all, test with Integrate taking into account max(water, 1.0) for mass
			+ At integrate
			+ At spring relaxation, for spring masses
				+ NOPE: here it hurts; wet springs really don't break at all
			+ Check reality-ness
				+ Problem: ship sinks very slowly
					+ Due to: mp>>Mw: v=g*dt; mp<<Mw: v=0
		+ Introduce volumetric fill: fraction of 1m3 that is filled by material
			+ Also: fraction of 1m3 that may be filled with water
			+ Also: volume of displaced water
			+ Default: 1.0
			+ Explicitly set to low value at:
				+ Rope, Cloth
				+ All Hull's (zero)
			+ Remove Points::Buoyancy
			+ Use volumetric fill at:
				+ UpdatePointForces()
				+ Integrate() (temporarily - becomes IntegrationFactor again, but re-calc'd explicitly at each step)

		+ Reintroduce water absorption
			+ High absorption at ropes and cloth
			+ Points buffer
			+ Use it at UpdateWaterIntake

		+ Test look'n'feel
			+ Test for less bouncy crashes: springs using wet mass, again
				+ No, worse
			+ Existing ships
				+ Pay attention to crashes onto sea floor
			+ Rope
				+ WaterRestitution
				+ Fast-falling-when-wet bug
				+ Buoyancy/sinking
			+ Cloth
				+ WaterRestitution
				+ Fast-falling-when-wet bug
				+ Buoyancy/sinking

		+ Now, optimize:
			+ Points::UpdateTotalMass(): calculates:
				+ (New) IntegrationFactor (vec2)
				+ TotalMass (for UpdatePointForces())
			+ Invoke at Ship::UpdateMechanicalDynamics before all
			+ Then, undo changes at Integrate()
			+ Then, use new quantities at UpdatePointForces()
			+ Test:
				+ Changes to Simulation Quality are picked up
				+ Bombs' extra mass

		+ Cleanup TODO's at Ship (SpringForces attempt)
		+ Points::UploadForceBuffer: decide length
		+ Update materials.md docs with new properties, including water
		+ Update ShipAnalyzer for correct buoyancy-adjusted mass
	+ Improve light diffusion
		+ Use real distance
		+ No more non-linear behavior

	+ Add "Low-Dimmed Lights" and "Medium-", and "Portholes"
		+ New Electrical Property of Lamp ("Luminescence") at ElectricalMaterial
		+ New Lamp property at ElectricalElements
			+ Consumed by DiffuseLight
		+ Use at Queen of Unova
	+ Wind and cloth
		+ Step 1: Points has WindReceptivity buffer, for now set at Add(.) to 1.0 if material is one of cloth
		+ UpdatePointForces:
			+ Add wind force vector to overwater points, multiplied by WindReceptivity
				+ From mParentWorld.GetCurrentWindForce()
					+ Step 1: GameParameters.WindDirection * GameParameters.WindSpeed
					+ Will become erratic later on			  
		+ Test with new flag (Iceland) attached to FlagShip
		+ Step 2: new StructuralMaterial property: WindReceptivity
			+ Optional in json (default=0.0), only set for cloth
			+ Update guide
		+ Step 3: erratic behavior of wind
			+ GameParameters::WindSpeed becomes WindSpeedBase
			+ World::UpdateWind(): implements state machine and calcs current wind force
				+ Incorporate gust adjustment
				+ See if we need to up force a bit for fater response
					+ See first w/64 fps first if more respondent - skinnier test ship 
				+ Use short running average to smooth transitions (minimally)
					+ Make it 4
					+ Get rid of intermediate states
				+ Do piecewise state machine, w/various prob types
					+ Gust transitions are still poisson, but not their duration
		+ Step 4:
			+ See interaction of wind on waves
				+ Hi-freq sine whose amplitude is normally zero unless wind force over base
		+ Add all wind settings to SettingsDialog
			+ Include global flag
		+ Sound:
			+ Layered like waves:
				+ 1 continuous sound
					+ Triggered by abs threshold, 30
				+ 1 one-shot sound (Gust)
					+ Triggered by abs threshold && force > .9*Max
			+ IEventHandlers::OnWindForce...(zero, base, max)
			+ Do more gusts
			+ Fix initial ramp up
				+ RunningAverage::Fill(float)
				+ Remove log message @ SoundController
			+ Remove probe
			+ Make sound's volume change inertial
		+ Add probe for wind force
		+ Step 5: implications of low wind settings
		+ Test: 
			+ SettingsDialog: 
				+ Dealing with negative wind
					+ See ripples
				+ Gust adjustment
				+ Modulation off
		+ Try: 
			+ Debris and Sparkles created with WindReceptivity=1.0
			+ Rope has small WindReceptivity
		+ SettingsDialog: expose "Play Wind Sound"
			+ Test
		+ Re-dimension wind force
			+ Try default being -24
				+ Flip Flagship
			+ Say it's km/sec and transform to F (m/sec, w/air mass) in ApplyForce
			+ Eventually adjust receptivity of cloth and rope
			+ If ok:
				+ Also change receptivity of sparkles and debris
				+ Test 
			+ Test Sailship 1
			+ Increase strength of cloth to avoid stress at Flagship
		+ Check with wind speed = 0 - divisions by zero!
			+ Wind
			+ Water
			+ Sound?
		+ Test another re-dimension:
			+ Fw = 1/2 rho v2 A  				
		+ Test perf
			+ Do perf analysis to rule out sound
		+ Rearc: Wind exports speed (vector & magnitudes), in km/h
			+ Ship calcs force
			+ Calc & adjust sound factors
			+ Test:
				+ Force on cloth
					+ Lower receptivity
				+ Force on Titanic's cables
				+ Sound
					+ Lower curve
				+ Waves
					+ Make them faster
				+ Clouds
				+ Max settings
		+ Cloth:
			+ Less heavy
				+ Up strength by same factor
			+ Less stiff
				+ No		
		+ Do SailShip 2
			+ Larger sail?
			+ Cleanup texture
			+ Add ropes
			+ Finish structure
	+ Decay (rust)
		+ Spec:
			+ Over time, *wet* points and springs get decayed (grey), and strength lowers
			+ GameParameters: DecayAcceler8r controls how quickly
				- 0  = +INF == never
				- 1  = 5m (default)
				- 10 = 10s
			+ Low-frequency Ship update does job
		+ Impl:
			+ Points: new Decay float buffer
				+ Init as 1.0
					+ Idea is that Ship::DecayStructure sends it asymptotically to 0.0
			+ Springs: new MaterialStrength float buffer
				+ Init with material strength, same as Strength
				+ Getter const
			+ Points: ConnectedSprings structure contains size_t with # of springs owned by the point
				+ Update at Add/RemoveConnectedSpring
					+ And make owned first, non-owned next
				+ Clone same to triangles - remove isAtOwner flag there
			+ FastLog2 benchmarks
			+ Commit
			+ Ship::LowFrequencyUpdate()
				+ Invoked by Ship::Update
				+ Checks whether currentSimTime >= lastLowFrequencyUpdateSimTime + GameParameters::LowFrequencySimulationStepTimeDuration<float>
				+ Does:
					+ Ship::RotPoints() -> decay
						+ alpha = (10^-5)^(f(Acceler8r)/300) (~total decay in 300/f(RotAcceler8r) steps)
							+ Accel = 1 => 300 steps (5 mins)
							+ Accel = 10 => 30 steps (30  secs)
							+ Accel = 0 => +INF steps
							+ Come up with reasonable min, max
						+ for each point p:
							+ beta = alpha * log(1 + p.water) (beta << 1)
							+ if p.isLeaking: beta *= 5.0
							+ p.SetDecay(decay *= (1.0 - beta))
								+ Check assembly for p.SetXYZ() vs p.GetXYZ()*=y !

						+ Points.MarkDecayBufferAsDirty()

					+ Ship::DecaySprings() -> strength
						+ for each spring: strength = material's strength * avg of two endpoints' decay
						+ Check assembly
					+ Spread out the two calls
						+ Check with large ship if stutters
					+ Do RotPoints at SimulationStepSequence%4 and DecaySprings at SimulationStepSequence%5
						+ Change visit sequence number to SimulationStepSequenceNumber
							+ Double-check first
							+ Type (SequenceNumber, never zero) and variable (SimulationStepSequenceNumber
			+ (Ship)RenderContext:
				+ UploadDecayBuffer
					+ Just like upload plane ID, opportunistic
					+ Interleaves in attribute group 2, at the place of padding
				+ Shaders:
					+ Group2: vec3 -> vec4
					+ Triangle, Spring, Ropes, and Point shaders give value to fragment shader
					+ Fragment shader uses it for:
						+ Pre-test: triangle shader: just display white*decay
						+ Production:
							+ Blend with rot color == l(brown) + (1-l)(green), with l==lightness
					+ Do also at ship_color shader
			+ Less stress sounds when really decayed
			+ Ship::Render:
				+ Points::UploadAttributes
					+ Now also uploads Decay buffer @ //mutable attributes// if dirty, and of course resets flag
			+ SettingsDialog: 
				+ RotAcceler8r
				+ Debug option for rendering decay
			+ Debug option for rendering decay
				+ Make 1 single layer
			+ Scrub tool
				+ Cleans when moves (sends decay back to 1.0) 
					+ Along trajectory, magnitude dependent from distance between tool and point 
				+ Icon: sponge
					+ Make separate down and up
				+ Sound: scrub, with movement (based off feedback from GameController, like saw)
				+ Better sounds with vector directions
				+ Help
	+ Repair tool
		+ 1) No Points::Destroy/Delete, but Detach()
			+ Points::Detach(.), also at Handler
			+ No IsDeleted() checks anymore, anywhere
			+ Whenever we used to delete, we now detach and inject velocity
				+ Encapsulate debris' randomness in Ship::ChooseRadialVelocity(rnd coeffs)
			+ Bombs::OnPoint"Detached"			
			+ At these places should only consider non-ephemerals and non-expired ephemerals
				+ Ship::Get/QueryNearestPointAt
				+ PinnedPoints::Toggle: 
			+ Ship should have EphemeralPointExpired handler
				+ Calls PinnedPoints::OnEphemeralPointExpired
			+ Decide what to do with event handlers - destroy and/or detach
				+ Points invokes OnDestroy at DestroyEphemeralParticle
				+ Ship::DetachHandler invokes OnPointDetached at DetachHandler *iff* really ended up detaching anything
					+ Points::Detach does not invoke anymore OnDetach directly, only ship handler does
					+ OnPointDetached/Attached: make aggregations
					+ SoundController::OnPointDetached: use break
			+ Check steady clock
			+ Test in Debug mode:
				+ Bombs neighborhood
				+ Destroy
				+ Destroy AirBubble
				+ PinnedPoints:
					+ AirBubble
					+ Remaining at point
					+ Destroyed
					+ On ephemeral that becomes expired
			+ If pinned points OK: remove TODOTEST for OnSpringDeleted
			+ Check perf
				+ 29.9/30.0
			+ Commit (to new branch)
		+ Do perf analysis with many air bubbles
			+ Make sure we don't make OpenGL calls for the zero-size gentex vectors
			+ Check perf impact of single GenTex draw call
				+ Mapbuffer & copy all
				+ Get rid of maxMaxPlaneId for gentex's
				+ Test:
					+ Bombs cover each other
		+ Run in Debug
		+ Check flood tool change (Tool::Initialize - verify sound starts)
		+ 2) Maintain factory connections
			+ Not electricals (at least for now)
			+ Points:
				+ AddFactoryConnectedSpring(...)
					+ -> ConnectSpring(...)
				+ Connect/DisconnectSpring(...)
					+ assert it's in factory-connected springs
				+ See if connecting-spring-kung-fu should be done by struct itself
				+ FactoryIsLeaking
			+ Springs:
				+ FactorySuperTriangles
			+ Other factory connections as necessary by restore algo
			+ Springs::Restore
				+ Undo deletion
				+ Call SpringRestoreHandler
			+ Ship::PointDetachHandler:
				+ See if it's true that we don't need to destroy triangles
			+ Springs::Restore			
			+ Ship::SpringRestoreHandler(s)
				+ Add others to self
					+ Copy factory supertriangles
				+ Add self to others
					+ Connect self to endpoints
					+ Add self to each supertriangle's subsprings
				+ Set IsStructureDirty=true
			+ Triangles::Restore
				+ Undo deletion
				+ Call TriangleRestoreHandler
			+ Ship::TriangleRestoreHandler(t):
				+ Add t to its endpoints
				+ Fire Attach event
				+ Set IsStructureDirty=true
			+ Update invariants verification
		+ Commit
		+ Try changing Points::GetMass to Points::GetAugmentedStructuralMass
		+ Move tolerance check _after_ movement
			+ Movement is still only done if not within tolerance
				+ And changes distance
		+ 3) Repair tool and action
			+ Repair(Pr):
				+ for each s in Pr.FactorySprings:
					+ if s.IsDeleted:
						+ if s.length <= s.restLength: // Restore
							+ Springs::Restore(s)
							+ Try with force instead of velocity
						+ else: // Attract endpoint
							+ Points.GetForce(s.OtherEndpoint) += c * <normal>(Pr.Position - OtherEndpoint.Position)
							+ Try with force instead of velocity
				+ for each t in Pr.FactoryTriangles:
					+ if t.IsDeleted:
						+ If all t.FactorySubSprings are !Deleted:
							+ Triangles::Restore(t)	
				+ Restore endpoints' IsLeaking
					+ Only for endpoints that now have all of their factory springs
				+ Decide on:
					+ Radius
					+ Force
					+ Ultra-violent mode effect
			+ Test pinned points now
			+ RepairStructureTool:
				+ repair_structure_cursor_up/down.png: wrench
					+ multiple frames for different rotations
					+ sync with sound
					+ do other 22.5-degree frames
				+ Adjust cursor hotpoints
			+ SoundController: 
				+ RepairTool sound
				+ OnRepair
					+ Sounds:
						+ Metal
						+ Cable
						+ Cloth
						+ Glass
						+ Wood
						+ X2 (underwater!)
						+ Lower volume
		+ Parameters:
			+ Remove repair force adjustment from GameParameters
	+ Also dry points should rot, albeit very slowly
		+ ...and also do "rust_receptivity" material property
		+ Rotting factor: (inner water + (isUnderwater ? 0.1 : 0.0)) * material.rust_receptivity
			+ 0.2
		+ Do stainless steel materials
			+ Test ball half/half in "New Materials Balls.png"
		+ Add new property to materials guide
		+ See general speed of rotting
	+ Make waves with Shallow Water Equations
		+ Implement
			+ Rename to OceanSurface
			+ Step 1: basic SWE with reflecting boundaries
				+ cctor: wave initialization
				+ Update:
					+ SWE update -> next buffers
					+ NextHeightBuffer + Wind gust sines -> mSamples
					+ Swap buffers
			+ Step 2: perturbation tool
				+ OceanSurface::AdjustTo
			+ Rearc:
				+ Basal waves
					+ Params:
						+ Width (wavelength)
						+ Height
						+ Period (=> speed=Wavelength/Period)
					+ Impl:
						+ Funcs:
							+ sin
						+ Composition of SWE and basal:
							+ add
						+ Wave width is "WaveWidthAdjust"
							+ fraction of MaxWidth - MinWidth(H)
							+ MinWidth(H) = 6*H
							+ 1.0 means "max width" = f(height)
						+ Wavelength and period correlated: 
							+ Change period into speed (m/s) = S
							+ S = 1/sqrt(2PiL/g)
							+ Adjustment makes +/- 50%
								+ Speed is never zero
								+ See if need to adjust percentage bands to avoid "almost still" waves or too slow waves 
								  or too fast waves
						+ Actual wave speed = speed * direction(wind speed) + wind speed * factor
							+ With speed > 0						
						+ Multiple components:
							+ Two components:
								+ 2nd component has sin phase with very slow period						
						+ Find good initial conditions
							+ Need "as if" wind was 40, but not simply 2x as wind=100 makes wind'=200
					+ Controls:
						+ WidthAdjust, Height, Period (>0)				
				+ SWEs
					+ Tool
						+ Tool does no smoothing
						+ OceanSurface implements trajectory
							+ Delay rate must itself depend on delta H
						+ Test max delta H
						+ Find correct falling water speed
						+ Check if average water depth increases
					+ Cursor: set arrows at same positions as adjust terrain cursor
					+ Tsunami
						+ GameParameters: "TsunamiArrivalTime", mins
							+ Min = 0 => no tsunamis
							+ Max = 15
							+ Settings Dialog, under "Wave Phenomena"
								+ Tooltip: "...disables automatic generation of..."
						+ Tools menu entry - w/no accelerator key
						+ OceanSurface:
							+ Tsunami-specific StateMachine member, std::optional
							+ When not set:
								+ Run choosing until chosen
									+ Do not trigger within first 1 minute
								+ TriggerTsunami() when triggered
							+ void TriggerTsunami(): 
								+ Emplace state machine
								+ Test if slower rise (not fall) makes better long-run wave
								+ Fire "OnTsunamiTriggered" event
							+ State machine
								+ Height = 105 (5%)
								+ See if need custom fall rate
									+ If so, new state machine altogether
							+ Publish "OnTsunamiTriggered" event
								+ Break IGameEventHandler into smaller pieces
									+ Do separate one for hi-freq events
								+ Ship takes GameEventDispatcher directly
								+ GameController registers for OnTsunamiTriggered and runs TsunamiNotificationStateMachine
									+ TsunamiNotificationStateMachine: private class, cctor takes:
										+ TextRenderContext (for text)
										+ RenderContext (for shaking)
										+ bool Update(): when returns false, GameController nukes it
									+ Text 
									+ Shaking
								+ SoundController:
									+ Tsunami sound, one-shot (overridable): rumbling + siren + background SOS
							+ UI preferences: show tsunami notifications checkbox
								+ UIPreferencesManager:
									+ It's a test for SettingsManager
									+ Replaces UIPreferences
										+ Also given to ShipLoadDialog et al
									+ Also acts as storage for some of them (those not owned by GameController)
									+ Exposes setters and getters for all (like SettingsManager)
									+ Takes GameController at cctor	
										+ And gives it GameController's owned properties after having loaded them
									+ Tooltip: say "visual notifications"
										+ We keep sound
									+ Test entire preferences dialog
									+ Test tsunami notifications
					+ Rogue waves
						+ GameParameters: "RogueWaveArrivalTime", mins
							+ Min = 0 => no rogue waves
							+ Settings Dialog, under "Wave Phenomena"
								+ Tooltip: "...disables automatic generation of..."
						+ Tools menu entry - w/no accelerator key
						+ OceanSurface:							
							+ RogueWave-specific StateMachine member, std::optional
							+ When not set:
								+ Run choosing until chosen
								+ TriggerRogueWave() when triggered
							+ void TriggerRogueWave(): 
								+ Take Wind & calc right locus index based off direction
							+ State machine
								+ Height = 101 (1%)
								+ See if need custom fall rate
					+ Re-check exponential distribution
						+ And make helper at GameRandomEngine that takes CDF
					+ Test with basal waves added to SWE height field, instead of added to samples
					+ Test with 3 samples being modified at SWEWaveStateMachine
					+ Test with SWE with double's to see if long-running wave is better
				+ SettingsDialog:
					+ "Wind and Waves" tab
						+ Static box for basal waves
						+ Tooltips
					+ Run in Debug
			+ Final touches:
				+ Cursor
				+ WaveMaker:
					+ Double-check hotspot
					+ Tool sound
						+ Continuous with fade-in and fade-out
						+ Fix restart while fading-in
						+ Better sound
						+ See linear fade-out again
				+ See if can stop making reflective boundaries with height field=0
				+ Smooth some other parameters
					+ Ocean depth, ocean bumpiness, ocean detail
				+ SWE boundary conditions: try 5 bc samples, damping heights and braking down linearly
				+ Try with other formulation of SWEs
				+ Optimize alpha changing for text
				+ Reduce world width
				+ Cap interactive height
			+ Optimizations:
				+ FPS before: 28.6/28.6/28.7/29.5/29.6/
				+ 1: Basal wave params and abnormal wave CDFs calc'd only at GameParameters changes
					+ Test all param changes
					+ Test tsunami notifications
				+ UR/Ratio: 220/230
				+ 2: Pre-calc'd funcs (sin)
					+ Arg needs to become current_arg/2PI
				+ 3: Samples: advance x's with sums, no multiplications
					+ Take into account current_arg/2PI
				+ 4: Anomaly choosing done only at scheduled (wallclock) times, every ~0.5 sec
					+ AnomalyTriggerSampleInterval = 500ms
					+ Adjust exponential coefficients
						+ If we want 1 tsunami every TsunamiRate * 60.0f second, we want 1/(TsunamiRate * 60.0f) tsunami
						  every second, and thus we want 1/(TsunamiRate * 60.0f * 1s / AnomalyTriggerSampleInterval) every interval
						+ Double-check wind while you're at it
					+ Verify rates
				+ FPS: 30/30.15; UR/Ratio: 206
				+ 5a: See if both advections are really needed
				+ 6: Two field updates in one, so that we have a single loop
					+ Then, check assembly
				+ FPS after: 30.4/30.6; UR/Ratio: 218
			+ See to reduce flattening of waves
				+ Test lower offset
				+ Try again with height offset
				+ View values
			+ Check width of tsunami wave
			+ Retry damping boundary conditions
				+ Between advection and update
				+ Test first in visible world
				+ Finalize
			+ Merge
	+ Heat and Combustion
		+ Spec:
			+ Integration of Decay with Combustion:
				+ Combustion also is a source of decay
				+ Springs should get weak based off decay, independently from source
				+ It is really 3 distinct processes:
					+ 1a: Point rotting:
						+ Low-frequency
						+ water + isLeaking => decay
					+ 1b: Point combustion:
						+ Any frequency (combustion state machine update frequency)
						+ combustion y/n => decay
					+ 2: Spring decay
						+ Low-frequency
						+ p.decay => s.strength
							+ Use both endpoints' decay
						+ Impl:
							+ Springs::Decay(Points const &)
								+ For each spring: strength = material's strength * avg of two endpoints' decay
									+ float buffer: MaterialStrength
			+ Rendering of flames:
				+ Need depth-sorting:
					+ Ship has heap of indices of burning points						
						+ Ordering of heap: plane ID
						+ Heap created from scratch at connectivity visit
						+ Heap updated by Points's combustion state machine update (heap passed by Ship) when points start
						  or stop burning					
						+ Heap used by Points's Upload() (heap passed by Ship)
		+ Impl:
			+ Properties and Materials:
				+ New StructuralMaterial properties:
						+ Ignition temperature (T)
						+ Melting temperature (T)
						+ Thermal conductivity 
						+ Specific Heat
						+ Combustion type (Combustion, Explosion)
					+ Add all of them via script, with switches based off material type
						+ Thermal conductivity: see https://en.wikipedia.org/wiki/Thermal_conductivity#Units
						+ Then, manual tune
					+ Add all of them to guide
				+ Points:
					+ MaterialIgnitionTemperature
					+ Temperature/Buffer
					+ CombustionState/Buffer
				+ Springs:
					+ MaterialMeltingTemperature (avg of two endpoints, calcd at Add())
					+ MaterialThermalConductivity (avg of two endpoints, calcd at Add())
				+ Renames:
					+ Points::TotalMass -> "CurrentMass" (and UpdateTotalMasses)
						+ TODO: rethink this one; "Mass" contains augmentation nowadays
					+ Springs::Stiffness -> "MaterialStiffness"
					+ Springs::Coefficients -> "CurrentCoefficients"
					+ Springs::StiffnessCoefficient -> "CurrentStiffnessCoefficient"
					+ Springs::DampingCoefficient -> "CurrentDampingCoefficient"
					+ Springs::Strength -> "CurrentStrength"
					+ Springs::GetMaterialStrength
					+ See whether all "current" should go and become _just_
			+ Heat overlay:
				+ Ship/RenderContext flag
				+ SettingsDialog
				+ Ship::Render: when flag set, upload heat buffer (much like we do w/Decay)
					+ Ship/RenderContext UploadHeat
						+ Maintains dirty flag and exposes MarkTempBufAsDirty - exactly like decay - which is invoked by:
							+ Heat propagation
				+ Ship/RenderContext render
					+ Rendering:
						+ RenderCore enums
					+ Shaders:
						+ Do point, spring, and triangle shaders
							+ Do second, richer version of main ones - "...WithTemperature..." - that completely
							  replace the first ones when the heat overlay is activated
								+ Texture
								+ Color
							+ Parameter setting
						+ Use temperature buffer (of floats) to produce "temperature color" as:
							+ tint3 = mix(c1, c2, some f of temperature ~= 1-e^(-paramHeatContrast*T)) // see https://en.wikipedia.org/wiki/Incandescence#/media/File:Example_incandescence_colors_(temperature_range_550_-_1300_C).svg
						+ Make it glow in the night
						+ Use function (in include) to apply heat overlay
							+ Nuke static params 4 colors
						+ Try multi-band gradient
					+ Transparency at SettingsDialog
						+ "Render" section under "Heat"
						+ Figure out right default value
			+ Physics update:
				+ Ship::Update: 
					+ @Beginning: either call Springs::UpdateParameters(params, points) or call 
					  Springs::UpdateDecayAndTemperatureAndParameters(params, points), depending on simulation step
						+ Springs::UpdateParameters(params, points): 
							+ iff params updated: UpdateDecayAndTemperatureAndParameters(params, points)
						+ Test:
							+ Stress and break (Titanic)
							+ Mass augmentation
							+ Repair (restore)
							+ Param changes
						+ Springs::UpdateDecayAndTemperatureAndParameters(params, points):
							+ Assumption: Decay and Temperature have changed (Parameters not necessarily)
							+ (Params, P.Temperature, P.Mass) -> StiffnessCoefficient
							+ (Params, P.Mass) -> DampingCoefficient
							+ (Params, P.Decay, P.Temperature) -> S.Strength
								+ Params are needed to include StrengthAdjustment and NumMechanicalDynamicsIterationsAdjustment
								  in "current" strength
								+ Add "MaterialStrength", and use "Strength" for strain
									+ Check for all current uses of Strength and replace with MaterialStrength
								+ Since we're touching this: factor in Strength the other things that we calculate at 
								  UpdateStrains, namely:
									+ StrengthAdjustment, NumMechanicalDynamicsIterationsAdjustment
									+ Rest Length
							+ Flip burning and melting point in metals
						+ Nuke Ship::DecaySprings and, with it, Springs::Set(Current)Strength
						+ Cleanup low-frequency schedule now that DecaySprings is gone
							+ Change frequency altogether to 7*6
						+ Verify assembly: hopefully no call to UpdateForDTP(...springIndex...) from UpdateForDTP(all)
					+ Later on: Ship::UpdateHeatDynamics:
						+ At one slot: call Ship::PropagateHeat()
							+ Propagation and dissipation
								+ New global constants: AirTemperature, WaterTemperature
								+ Use specific dt's calc's as constexpr's in UpdateTemperature based off frequency of steps
								+ Dissipation: use air or water temp, depending on whether it's above water or below
									+ Exaggerate water dissipation, so that smothered fire does not rekindle immediately
										+ First, double-check calculations, however
							+ Cleanup TODO's (and do we have a useless step frequency constant now?) to keep it at each step
						+ At another slot: call Points::UpdateCombustionStateMachineLowFrequency(...)
							+ For each point:
								+ If it's not combusting:
									+ Check combustion transition
										+ Notify
										+ Choose random max development
								+ Else (it's combusting):
									+ Check exhaustion transition
										+ Notify (boolean for water-caused)											
									+ Do decay: burn rate (i.e. decay speed) ~= structural mass (the lower the mass, the faster decays)
										+ Verify default, min, and max
									+ No temperature and no raise and lower flames, done below at Points::UpdateCombustingPoints()
								+ Water (both underwater and flood) should apply regardless of state
								+ Do phased ignitions (N at a time)
									+ Run low-frequency state machine M times for 1/Mth of the points each time
									+ Choose number of promoted randomly = N
										+ Find right N: depends on M
									+ At each step: choose top N ignitions over all candidates, sorted
									  by temperature over ignition temperature
						+ At all steps: call Points::UpdateCombustionStateMachineHighFrequency(heap)
							+ Points uses heap (with burning points) and evolves the "burning"
							  state machine
								+ Raise flames up and down
									+ Redo 3 curves, see paper
								+ Heat to self and neighbors
									+ Do code changes
									+ Do flag to turn off flame rendering
										+ Move flame rendering to heat & combustion?
			+ Ship::ConnectivityVisit:
				+ Call Points::ReorderBurningPoints()
			+ Ship::Render:
				+ Calls Points::UploadFlames()
					+ Uploads flames in order of heap
			+ See Pac0master's bug: looks like when the cardboard of the funnel touches the water it starts generating a super high amount of heat
			+ See Pac0master's bug: Spawn the default ship,  max out the Thermal conductivity and  dissipation the back of the ship will start to heat up and melt very fast
			+ Melting improvements:
				+ Option 1: Test with sticky strength
					+ Springs has new buffer, "MeltStrengthComponent", always > 1.0
					+ We might also need sticky stiffness, but try with strength first
				+ Option 2: Test with sticky rest length
					+ StiffnessCoeff and Strength are memory-less: they return to their original values when no melting occurs,
					  but RestLength not
					+ First test in-place modifying RestLength; if ok:
						+ Make "FactoryRestLength" buffer
						+ Verify all usages of RestLength and choose accordingly
							+ Repair: try using both as targets and choose best
						+ Decide performant way of making rest length sticky
						+ Update comments at Springs
					+ Do asymptotic stiffness, not zero
					+ Try different DeltaTMax's
					+ Repair: recalc coeffs when we've set a new rest length
						+ Adjust rest length before all, "snapping" rest length to factory when close enough
							+ Also set rest length to factory when spring restored
						+ Use boolean flag to recalc coeffs just once per spring
						+ General:
							+ See if should be faster (play with settings' speed)
							+ See if UltraViolent mode makes sense
						+ Decide whether to target current or factory rest length
			+ Electrical: devices generate heat, and lights and generators break at low and high temperatures
				+ New electrical material properties - "HeatGenerated" and operating temperatures
				+ GameParameters: electrical heat generated adjustment
					+ Settings dialog: new "Electrical" section between HeatBlaster and World
				+ Rearc:
					+ ElectricalElements has buffer with operating temperatures
					+ ElectricalElements::UpdateSourcesAndPropagation (rename from "Connectivity")
						+ Move from Ship
						+ Uses mSourceIndices as starting point, instead of just generators
							+ Nuke generator indices
						+ For each source:
							+ Check preconditions:
								+ Wetness
								+ Operating temperature
							+ If ok:
								+ Generate heat (using also adjustment)
								+ Flood graph for VisitSequenceNumber
					+ Rename "AvailableCurrent" as "AvailableLight"
					+ ElectricalElements::UpdateSinks (replaces "Update")
						+ Uses mSinkIndices (vector of indices, not only lamps)
						+ Lamps: run lamp state machine
							+ Consider also operating temperatures in state machine and transition accordingly
							+ Each time AvailableLight is > 0, generate heat (using also adjustment)
					+ Make self-combusting ship:
						+ Make heat-resistant materials (low thermal conductivity and high heat capacity):
							+ Electrical:
								+ Generator
								+ Lamp
								+ Heating Element
									+ And catch at script
						+ Do ship
						+ Redo template
			+ Make flames smaller when point is orphaned
				+ 1: Ship::SpringDestroyHandler: invoke Ship::OnPointOrphaned for each endpoint that becomes orphaned
				+ 2: Ship::OnPointOrphaned: invoke Points::OnPointOrphaned
				+ 3: Points::OnPointOrphaned: 
					+ Suddenly truncate development
						+ Try even smaller ?
			+ Interaction with bombs:
				+ Triggering:
					+ Timer, Impact, RC: 
						+ Trigger when temperature > GameParameters::BombsTemperatureTrigger = 773.15 (500C)
					+ Anti-Matter: + 1000
				+ Explosion:
					+ Timer, Impact, RC: 
						+ Produce heat directly at Ship::DoBombExplosion
							+ Verify first it's called at these 3
							+ Add heat to each point in blastRadius, considering ultra-violent mode as well
								+ Use GameParameters::BombExplosionHeatProduced
									+ Also at settings dialog, under Interactions
					+ Check if default value is good
					+ Check maximum again
			+ Flamethrower:
				+ Physics:
					+ Ship::Interaction:
						+ GameParameters::FlameThrowerHeat
							+ Absolute value, in J
							+ SettingsDialog, under "Flamethrower" in "Heat"
						+ Convert into DeltaT and inject in radius, smoothing radius
					+ Radius at SettingsDialog, under "Flamethrower" in "Heat"
					+ Fix default value of heat <-> slider
				+ Max power: 20,000
				+ Rename it: "Heat Blaster"
					+ Code & UI
					+ Shift cools down
						+ New HeatBlasterAction enum at GameTypes {Heat,Cool}
						+ Interaction: switch on action and either add or remove heat (w/fraction though, for 3rd principle)
						+ Rendering:
							+ Shader chosen depending on mCurrentHeatBlasterAction
								+ Two shaders, use #include's returning radius with parameters to make these changes:
									+ Flame direction (outward or inward, "speedMultiplier")
									+ Then make flame colors (for cooling: turn R into B)
						+ Cursor (simply upside-down and mirrored)
						+ Sound (wind or air vortex)
				+ Option to turn off flame rendering
					+ @ GameController
				+ Help
			+ GameParameters:
				+ ThermalConductivityAdjustment 
				+ IgnitionTemperatureAdjustment (in SettingsDialog: "Burning Point Adjust")
				+ MeltingTemperatureAdjustment (in SettingsDialog: "Melting Point Adjust")
				+ CombustionSpeedAdjustment
				+ CombustionHeatAdjustment
				+ Also add all of these to settings dialog, under "Heat" tab
				+ Make max burning points adjustable
					+ All sub-systems need to allow for > max burning particles, because when the user changes the value down,
					  the excess ones will need some time to disappear
						+ Test
					+ RenderContext: realloc VBO each time # of flames changes by 100
					+ Points: doesn't care as it uses vector
					+ SettingsDialog
						+ Under "Heat", with warning icon like Simulation Quality
				+ Make air and water temperature adjustable
				+ See if should lower default MaxBurningParticles (per impact of all burning)
				+ See if should allow higher heat blaster
			+ Flame render:
				+ Make better transition for bottom
				+ Skew wind speed with smoothstep
					+ And reverse wind direction
				+ Make yellow core more narrow, in favor of thicker red border
				+ Make more vivid red
				+ Smoothen wind change (via running average @ RenderContext)
				+ Add slider for flame size
				+ Move wind rotation before noise sampling
					+ Nuke wind randomization
				+ Reduce local coherency of noise
					+ Add FlamePersonalitySeed shader param, straight from ship into vertex buffer
				+ Make same colors as flamethrower
				+ Adjust bottom
				+ Try without red border, to better merge multiple flames together
				+ Multi-flame improvements:
					+ Make better personality (less locality-aware, more randomized)
						+ Assign actual random number between zero and one at ignition time
						+ Change shader to expect value between zero and one
					+ Try dual-phase rendering: border only first, body only then
						+ Test
						+ Do vertex includes
						+ Test perf with instanced drawing(x2)
				+ See if can fix problem with flames on ropes that swing behind triangles
					+ Separate render step for chains, and flames belong to chains if their point
					  has no attached triangles
					+ Test
					+ If works:
						+ Go back to one single buffer (& single VBO, & single VAO), having StartUpload declare total # of flames, 
						  and adding bg ones at beginning and fg ones at end
							+ Keep track of beginning of fg ones == end of bg ones
					+ OnChain detection: use # of factory triangles, not current triangles (heuristic to avoid jumping planes
					  when triangles are destroyed by fire)
				+ Try different color scheme
					+ If keep: do also at:
						+ Flames2
						+ HeatBlaster flame
			+ Sound:
				+ Media:
					+ Burning loop
					+ Sizzling X 2 or 3
				+ SoundController:
					+ Subscribe to OnCombustionBegin/End: adjust cumulative volume of Burning sound
					+ Subscribe to OnCombustionSmothered: play one-time sizzling
		+ Experiments/Improvements:
			+ Consider higher default heat from flamethrower tool
				+ Current (900k) is fine for wood and ropes and cloth
			+ Fire-generated heat should be 10x in order to spread more
				+ Or: check if heat should depend on ignition temperature of that point 
					+ Is it possible that the heat we release now from burning hi-ign-temp points is actually lower than the one
					  the point has in order to be at that temperature?
				+ Spreads just fine on wood, ropes, and cloth
			+ Lower the min decay for extinguishing, so things break easier once burnt
			+ When state is Burning, also decay non-burning neighbors on top of decaying self (so to smear burnt color more around)
				+ At low-frequency update
			+ Max flame development depends on number of springs connected to point (so ropes have smaller flames)
			+ See if heating element should heat less
			+ Try max air and water temp to 5K
			+ Make melted stuff break earlier
				+ Limit breaking length somehow
				+ Try with limiting rest length instead
				+ Avoid breaking: try with non-smoothstep melt depth (and lower breaking length when melted)
			+ Flame render:
				+ Move more with wind
				+ Transparency on border - slightly more transparent at discard threshold
				+ Noise sampling tests, who knows - it might get better:
					+ Try different noise resolution
					+ Try without second noise component
					+ Try with third noise component
			+ Flamethrower flame render:
				+ Large flamethrower should have higher resolution
				+ Softer border
		+ Optimizations:
			+ Pre FPS: 17/18 fps, 34 U/R @ 111 flames (normally 40, 188)
			+ Do perf analysis for low-hanging fruit first
			+ Low-freq combustion state machine:
				= Burning candidates: 
					+ Sticky priority queue: leverage temporal coherence of overheated particles
						+ Contains:
							+ buffer for heap, maxSize = nPoints
							+ buffer of int32_t where element I contains either index in heap buffer of that element,
							  or max<int32>
						+ Exposes:
							+ remove_if_in(ElementIndex)
								+ If in heap, removes it
							+ add_or_update(ElementIndex, val)
								+ If in heap: update and update heap
								+ Else: add
					+ Do benchmarks: (10 out of 20/100/500)
						+ Vector_AddAndSort
						+ PriorityQueue_Add
						+ PriorityQueue_AddAndPop (sort by lowest, and keep top 10)
						+ Vector_AddAndNthElement
						+ Sticky_PriorityQueue
							+ Loop: makeup index w/ (i%200)
						+ TruncatedPriorityQueue
							+ New class altogether, no tracking
					+ Use NthElement w/member BoundedVector
			+ HeatPropagation:
				+ Do perf analysis invoking it N times per frame to exaggerate: 10.4/10.6
				+ Try impact of storing outgoing flows @ local array
			+ Flame rendering:
				+ Do perf analysis to see impact
				+ Shader:
					+ Replace pow with 3 mult's - see FPS gain
					+ When YesBorder, also discard at core
					+ Move discard earlier
					+ Move GetNoise inline
					+ Precalc wind angle in code and send as param
					+ Precalc noise offset in code and send as vertex attrib, replacing flame personality seed
						+ And do not set param time anymore
				+ Get timings
		+ Cleanup:
			+ Test generic textures change (gen tex's + air bubbles at same time) and nuke comment
			+ Test cross of light change
			+ SettingsDialog: Heat Dissipation tooltip: "...dissipate or acquire..."
			+ Run in Debug			
		+ Flamethrower tool:
			+ RenderContext exposes UploadFlameThrower(worldPos)
			+ GameController stores worldPos at ApplyFlameThrower(screenPos) and later, at Render, invokes RenderContext::UploadFlameThrower()
			+ Cursor
			+ Sound
				+ Continuous
			+ Tool
				+ Engages (and starts sound) only if GameController::ApplyFlameThrower(screenPos) returns true (i.e. point found in radius)
			+ Fix radius & size (smaller radius for catching points, same render size)
			+ Radius setting
			+ Apply heat (& Ultra-Violent mode)
		+ Update changes.txt
	+ Storms
		+ Another physics component
		+ Game wall-clock based
		+ State machine with concentric phases:
			+ Wind (and thus waves)
				+ Make clouds more sensible to speed - should go faster at higher speeds
				+ No zero state while there is storm
				+ Test storm wind on top of wind modulation					
			+ Cloud Darkening
			+ Darknening
				+ Out of phase with cloud darkening, to avoid ugly crossing
				+ RenderContext exposes UploadStormDarkening(float), which is used as multiplier with ambient light
				  and triggers a param update for shaders' effectiveAmbientLightIntensity (rename)
					+ Rename shaders' param
						+ RenderCore
						+ Shaders
						+ RenderContext.h
					+ Add RenderContext method and trigger EffectiveAmbientLightIntensity param update if 
					  stormDarkening is different than current
					+ Invoke from storm
					+ Test combined changes in intensities
			+ Clouds
				+ Rearc clouds: 
					+ Clouds:
						+ Position is maintained into x=[-1.5, +1.5]
						+ Normal clouds: 
							+ New clouds: random
							+ Old clouds: removed
							+ Roll clouds around
						+ Storm clouds:
							+ New clouds: at spaced intervals, checked w/last in vector (arbitrarily),
							  at +1.5 or -1.5 depending on total wind speed sign
								+ Higher scale range, with median larger with progress
							+ Old clouds: removed when rolled over
							+ Roll clouds around
						+ Cloud darkening:
							+ Per-cloud, storm only
							+ Use values: 0.3, 0.56, 0.93
							+ Shader		
					+ RenderContext:
						+ map into NDC
						+ Remove test overrides
				+ See if can enlarge small cloud
				+ See if may make storm clouds larger, so to cover whole sky
			+ Rain
				+ Shader
					+ Try with more spatial density
					+ Discard
						+ See if it helps with perf: NO
					+ See double-speed
					+ Discard if tile off - see perf impact
					+ Lower density (and thus up volume)
				+ Sound (continuous, like wind)
			+ Thunders
				+ Others random with same distribution as wind gusts
				+ Events
				+ Sounds (N, one shot)
			+ Lightnings
				+ Storm state machine
					+ Invoke both OnLightning("Touchdown") and mParentWorld.ApplyLightning after .3 of progress
						+ In which case, externalize state machine as we need to emit event
						  during progress
						+ Upload also renderProgress
							+ Save one attribute (space Y, which is == position Y)
					+ Finalize duration
				+ Candidate choice: 
					+ Exclude orphaned points 
					+ Candidates should be further apart
				+ Storm damage
					+ See if speed of sparkles is ok
					+ Heat
					+ Sound: make 1-3 mixes manually of each material, and make new event ("OnLightningHit(material)")
						+ Mixes: various combinations of Destroy Small sounds
				+ Shader				
					+ Figure out daylight colors
					+ Review zig-zag density (before & after duration finalized)
				+ Test:
					+ Lightning above top
					+ Lightning touching well below
				+ See how to make bg lightnings visible during storm
					+ Just less clouds? NO
					+ Render: if exist background lightnings, draw last X clouds afterwards
		+ MainFrame: disable menu during storm
		+ Storm::Parameters:
			+ Given to Wind, who uses its WindSpeed = [0.0 ... +INF] to increase wind in calculations
				+ OceanSurface: gets in indirectly and makes waves
			+ Given to Clouds, who uses its StormMagnitude for darkness of clouds
				+ Param at shader, passed to RenderContext at RenderContext::UploadCloudsStart(...) via new "CloudDarkness" float param
					+ RenderContext::UploadCloudsStart: only sets param when val != mCurrentCloudDarkness
				+ Shader
		+ Wind volume: start with storm
			+ Need additional arg to wind event
		+ Manual storm trigger
		+ Manual lightning trigger
		+ Storm: complete auto-triggering
		+ StormStrengthAdjustment:
			+ GameParameters
			+ Use at Storm for:
				+ Replacement of StormMaxWindSpeed
					+ Make max wind smaller at Adjustment=Max
				+ Adjustment to rain density
					+ Change shader
				+ Adjustment to darkening
				+ Adjustment to lightning and thunder rates
			+ Also include ultra-violent mode
		+ SettingsDialog: 
			+ All interesting parameters
			+ Verify saved
		+ Rain extinguishes fire and dissipates heat
			+ Do personality seed work:
				+ Points: RandomPersonalitySeed
					+ At Add(), passed from outside
					+ Also use at other places where we need a per-point random number
			+ Combustion state machine: rain extinguishes fire
				+ Smothering is too fast: try with consumed instead of smothering, or add SlowSmothered
			+ Heat dissipation
		+ Cleanup:
			+ If StormRate is OK in minutes, make it also for tsunami and rogue wave
			+ See perf at Lightning hit when UltraViolent on
				+ Destroy vs. Heat: it's Destroy
				+ Destroy:
					+ Detach: 10%
					+ Sparkles: 70%
						+ CreateEphemeralSparkleLightning
							+ Reduce reset quantities
							+ Run in debug and verify
							+ See if may agglomerate buffers for ephemeral particles
								! Baseline: >= 3000 bubbles: FPS = 23.8-24.something
								+ Now: >= 3000 bubbles: FPS = 24.something-25.something
						+ Rendering: 0%
					+ Notify: NO
			+ Do perf analysis - Andrea Gail slows down a lot
				+ Also give crash to MS
	+ Explosive combustion:
		+ To be done after new explosions
		+ New materials:
			+ "Gunpowder":
				+ Takes-in water
			+ "Diesel"
				+ Doesn't take-in water
		+ Make test ship
		+ Modify combustion state machine
			+ At ignition check loop:
				+ Store combustion type in buffer
				+ Identify top N (=6? Local constexpr) candidates; conditions:
					+ Temperature threshold
					+ and: not wet (smothering watermarks)
					+ Do not care about UnderWater (that's for ignition)
				+ StartExplosion each, with:
					+ Radius, Strength: formula over IgnitionTemperature (the higher, the stronger), "just because"
					+ Heat: uses CombustionHeatAdjust
						+ Does it need combustion heat constant currently used at combustion update to generate heat to neighbors?
						+ Make it a (constexpr) GameParameter
						+ So at the end, heat of explosion is same generated by combustion
					+ Type: Combustion
				+ Transition to new state:
					+ Exploded
			+ At state update:
				+ Ignore
			+ At render:
				+ Ignore
		+ Need Point::Restore
			+ Invoked by repair tool
			+ Resets combustion state machine
				+ Test w/Repair
		+ Do new game event handler, OnCombustionExplosion
			+ Additive (just like bombs)
			+ New sounds x {underwater, size}
		+ Test UltraViolent mode
		+ Cleanup:
			+ Nail down top N candidates
			+ Make new structural materials template
			+ Finalize "Flawed Design" (or "Imminent Disaster"?)
				+ Name, Description
	+ Smoke ephemeral particle emitters
		+ Add ThermalExpansionCoefficient to all materials
			+ Points::Buffer
			+ All materials have it almost as zero (use real)
			+ Air, hydrogen have own
				+ Test blimp filled with hydrogen
					+ Change external structure to something light, e.g. cloth
			+ Add to Guide
		+ UpdatePointForces: if any point is above water, apply air buoyancy (*)
			+ i.e. always end up applying one buoyancy, either water or air
			+ Any buoyancy depends on temperature of particle and on temperature of "ambient air"/"ambient water"
				+ Use ThermalExpansionCoefficient at both buoyancies			
				+ Pre-multiply with gravity
		+ See if want to do heat dissipation also on ephemeral particles
			+ So that "frozen" air bubbles start floating again
		+ See perf impact: 29.4 FPS (1 FPS lost!)		
		+ Another type of electrical material: SmokeEmitter
			+ ParticleEmissionRate
			+ Add to DB			
		+ ElectricalElements::UpdateSinks(...)
			+ Run state machine and eventually invoke Points::CreateSmokeEphemeralParticle
				+ Conditions:
					+ Not destroyed
					+ Connected
					+ Not underwater
				+ Calculate next emission timestamp when needed
			+ Points::CreateSmokeEphemeralParticle:
				+ Create particle of Air (just like AirBubble), but at high temperature
			+ Points::UpdateEphemeralParticles: Smoke
			+ Points::RenderEphemeralParticles: Smoke
				+ For now, just point - like debris
		+ Do test ship
		+ Run in Debug
		+ Optimize ship's UpdateHeat::springOutboundHeatFlows
		+ Rendering: Simple texture (one of N alternatives) via GenericTextures
			+ Alpha and scale change with progress
			+ Finish scale function
			+ Nail down database's world dimensions
			! "Violent" smoke params:
				! Emission rate: 0.05
				! scale: 1.07f * (1.0f - exp(-3.0f * progress));
				! alpha: SmoothStep(0.0f, 0.05f, progress) - SmoothStep(0.85f, 1.0f, progress);
				! "worldWidth": 48.0, "worldHeight": 48.0
		+ Expire smoke ephemeral particles that end up underwater
		+ Cleanup (if everything's fine):			
			+ Add particle_emission_rate to Guide
			+ StructuralMaterial: "waterVolumeFill" -> "buoyancyVolumeFill"
				+ json
				+ Materials.*
				+ Guide
			+ Add smoke emission rate adjustment global param
				+ SettingsDialog
			+ Add smoke maxlifetime adjustment global param
				+ SettingsDialog
				+ Make scale independent from adjustment
			+ Try white smoke			
			+ Do smoke emitter at Titanic with Lights
			+ BuoyancyCoefficients: make them float, using gravity magnitude, and multiply with gravity dir at use time
			+ Try to replace bomb fuse smoke with real smoke particles
				+ Do "violent" emission, use scale formula above
				+ Test (with sound)
				+ Nuke old textures
			+ R.M.S. Titanic with Lights
			+ Redo materials templates
			+ Add diesel to both titanics
			+ changes.txt:
				+ Hydrogen to explosive materials
				+ Air buoyancy and its relationship with temperature
					+ Hindenburg update
				+ New SmokeEmitter material
					+ Cruise Vessel, Titanic update
	+ Switches:
		! Spec:
			! Two new electrical material types:
				! Interactive switch
					! Controlled by user
				! Water sensing switch
					! Controlled by water
			! Color trick like ropes to have unique and deterministic IDs for switches
				! One material (base structural color) for initially on and another one for initially off
					! Property: conducts_eletricity, just sets the default value
			! New electrical property: ConductsElectricity, bool - used at connectivity visit
				! Lights, Cables, Generators have it as true (also in ElectricalMaterial and in json)
				! Switches have it as true or false depending on whether switch is "on" or "off"
					! The act of switching ("Toggle...()") toggles the boolean
		+ Electrical materials:
			+ Two new types:
				+ GameType enum
				+ Interactive switch
					! Controlled by user
				+ Water sensing switch
					! Controlled by water
			+ New electrical property: ConductsElectricity, bool - used at connectivity visit
				+ Lights, Cables, Generators have it as true (also in ElectricalMaterial and in json)
				+ Switches have it as true or false depending on whether switch is "on" or "off"
		+ GameTypes:
			+ ObjectId overhaul:
				+ ObjectId is unique only in the context in which it's used (e.g. bombs vs switches)
				+ ObjectId == <ShipId (new GameType alias, uint32_t w/ None), LocalObjectId (uint32_t)>
					+ LocalObjectId is provided by caller
					+ ObjectIdGenerator only provides helper for globally unique - with no guarantees - or should go
				+ All ship ID ints become ShipId
				+ All object ID ints become ObjectId
			+ LocalSwitchId typedef (uint32_t)
			+ SwitchId == ObjectId<LocalSwitchId>
			+ SwitchState enum (mapped to bool)
		+ Ship json adds optional names for each ID
			+ as vector<std::string>
		+ ShipBuilder detects all switches as electrical elements
			+ Instance ID is from color code
			+ Checks for duplicate instance IDs - errors out if duplicate found
			+ Instance ID is only used to match with ship's switch names from json (or to make default label when no label specified), 
			  then each switch gets name as part of Electrical Elements data communicated to ship
				+ If label not present -> "Switch <instance ID>"
				+ ElectricalElements::Add now also takes std::string label
				+ ObjectId is implicit and not specified now (local ID is index in container of switches's ElementIndex within ElectricalElements)
		+ Electrical dynamics:
			+ ElectricalElement has new "conductsElectricity" buffer
				+ ~ Material (init'd with material's) and "current", in same struct (~ double "Switch")
				+ cctor: value of material's x 2
				! ElectricalElements::UpdateSourcesAndPropagation automagically considers it as it is now in the connectivity graph
			+ GC->World->Ship->ElectricalElements::SetSwitchState(SwitchId, SwitchState)
				+ Checks if state different than current
				+ If so:
					+ Sets conductsElectricity
					+ Then updates ConductingConnectedElectricalElements (see below)
					+ Then fires OnSwitchToggled(SwitchId, new state) event
		+ ElectricalElements connectivity:
			! Most performing approach is to alter connectivity graph with switch toggles
			+ mConnectedElectricalElementsBuffer: stays as is, i.e. structural connectivity
				+ Changes with structural changes only:
					! Point destruction: just mark as deleted, as springs have been destroyed already
						! assert
					! Spring destruction: remove s.endpoints from each other *iff both A and B are electrical elements*
						! Do via ElectricalElements::RemoveConnectedElectricalElement
					+ Point restore: just clear deleted flag, as springs will be restored later
						+ Do via ElectricalElements::Restore(idx)
					+ Spring restore: add s.endpoints to each other *iff both A and B are electrical elements*
						+ Do via ElectricalElements::AddConnectedElectricalElement
			+ mConductingConnectedElectricalElementsBuffer:
				! Intersection of mConnectedElectricalElementsBuffer and mConductsElectricityBuffer:
					! For each electrical element A: A.ConductingConnectedElectricalElements contains B iff:
						! A.ConnectedElectricalElements contains B
						! AND A.ConductsElectricity
						! AND B.ConductsElectricity
				+ Changes with:
					+ Structural changes:
						+ Point destruction: <nothing, as springs have been destroyed already> 
							+ assert
						+ Spring destruction: remove s.endpoints from each other *iff both A and B are electrical elements*
							+ Do via ElectricalElements::RemoveConnectedElectricalElement
						+ Point restore: <nothing, as springs will be restored later>
							+ Do via ElectricalElements::Restore(idx)
						+ Spring restore: add s.endpoints to each other *iff both A and B are electrical elements*
						  AND *iff A.ConductsElectricity AND B.ConductsElectricity*
							+ Do via ElectricalElements::AddConnectedElectricalElement
					+ ConductsElectricity changes (i.e. @ SetSwitchState):
						+ F->T: for each elem B in ConnectedElectricalElements such that B.ConductsElectricity:
							+ Add B to this.ConductingConnectedElectricalElements
								+ assert not already in
							+ Add this to B.ConductingConnectedElectricalElements
								+ assert not already in
						+ T->F: for each elem B in ConductingConnectedElectricalElements such that B.ConductsElectricity:
							+ Remove B from this.ConductingConnectedElectricalElements
								+ assert already in
							+ Remove this from B.ConductingConnectedElectricalElements
								+ assert already in
			+ ElectricalElements::UpdateSourcesAndPropagation: only consider ConductingConnectedElectricalElements
				+ Make ConnectedElectricalElementsBuffer private
			+ Test repair
				+ Fix repair:
					+ Repair point if it's in a "bad state"
					+ Keep also count of repaired points
				+ Generator doesn't get repaired
				+ Leaking at times doesn't get repaired				
			+ Fix repair problem: springs::Restore adds connected electrical elements, but these are deleted
			  and won't be undeleted unless point is restored
				+ Where we restore elec connections now: only do for !Deleted electrical elements
				+ At ElectricalElement::Restore: also here restore (eligible) connections
		+ Repair: move eligible points' restore flat into radius points
			+ i.e. not subject to session constraints
			+ Test before and after
		+ Water switching: at Ship::<UpdateElectricityPhase>::UpdateAutomaticElectricalConductivity()
			+ Uses list of elements (which included water-sensing switches) for perf
				+ mAutomaticSwitches
			+ If current conductsElectricity==material's && water > high watermark:
				+ SetSwitchState(!current)
			+ Else if current conductsElectricity!=material's && water < low watermark:
				+ SetSwitchState(current)
			+ Test water switching
				+ See why light is always on
			+ Finalize high/low watermarks
		+ New game events:
			+ Ship::cctor invokes ElectricalElements::AnnounceInteractiveElements(GameEventDispatcher &) 
				+ New IGameHandler: "electrical"
					+ Also includes lights fizzling
				+ Visits switches among ElectricalElements and fires OnSwitchCreated(SwitchId, name, type, state)
					+ state is current value of ConductsElectricity (i.e. still from electrical material)
			+ Ship::ElectricalElementDestroy/RepairHandler's fire OnSwitchEnabled(SwitchId, false)
				! Also clears (on destroy) ConductsElectricity
					+ Thus see if may avoid checking for deleted at UpdateElectricalPropagation
			+ Ship::ElectricalElements fires OnSwitchToggled(SwitchId, new state) at:
				+ 1) ToggleSwitch(SwitchId switchId)
				+ 2) Water-sensing switching - which is done at ElectricalUpdate()
					+ But invokes ToggleSwitch(.) anyway
				+ state is new value of ConductsElectricity, i.e. after the toggle
		! MainFrame gets switches via AddSwitch event, with all metadata (SwitchId, name, type, state)
			! SwitchBoard panel (see below)
				! Registers as event listener at cctor
				! Uses GameController (own shared ptr) :: SetSwitch(SwitchId switchId, state) to control switches
					! Water-sensing switches are not controllable, they just provide feedback
		+ MainFrame:
			+ Also registers for AddSwitch and shows SwitchBoard on first add
				+ As long as UIPreferences::AutoShowSwitchBoard is set (default=true)
			+ Hides it again only at Reset()
		+ SwitchboardPanel:
			+ MainFrame menu pops it up and down (and MainFrame also pops it up automagically at first switch add, see above)
			+ Has control to hide it back (kinda like "close" button at top-right corner)
			+ ShipInteractiveSwitchControl: much like slider, button (w/2*2 switch images, via cctor) with label below
				+ Has state (SwitchState mCurrentState)
					+ Purely for drawing
				+ May be disabled/enabled (via SetEnabled(isEnabled) override), making it grey and non-functional
				+ User-generated toggle event is via lambda(SwitchId, new state)
				+ Exposes SetState(enum) and ToggleState() for externally-generated toggle events
					+ Does not invoke lambda in this case
				+ Images:
					+ {on, off} X {enabled, disabled}
				+ Tooltip displays keys (whose labels are provided by creator via cctor)
			+ ShipAutomaticSwitchControl
				+ Merge two switch controls into one - base and two derived classes; both expose:
					+ SetEnabled
					+ SetState
				+ ...nuke all the "casting switch(type)" from panel
				+ Images:
					+ {on, off} X {enabled, disabled}
			+ Floating/Docked state machine:
				+ Fix stack overflow issue
				+ Test with EventTicker/ProbePanel on				
			+ Panel: much like ProbePanel
				+ Has:
					+ ResourceLoader const & (used @ cctor only for button images)
					+ GameController (see others for shared_ptr or &)
				+ Registers as event listener
					+ Processes IGameEventHandler::OnSwitchCreate/Delete
					+ Processes IGameEventHandler::OnSwitchToggled(ObjectId, new state)
					+ Processes Reset() to delete all
				+ Has unordered_map<ObjectId, SwitchInfo>
					+ SwitchInfo:
						+ uq_ptr<SwitchControl>
						+ bool IsEnabled					
				+ OnSwitchCreated:
					+ Create uq_ptr<SwitchControl(key)>
						+ Does the mapping here from switch type to images and class
					+ Add SwitchInfo to map
					+ Add to panel - center-aligned, overflow and grow
						+ json:
							"electrical_panel":{
								"0": {"panel_x"=-1, "panel_y"=0, "label"="Test 1" },
								"1": {"panel_x"=0, "panel_y"=0, "label"="Test 2" }
							}
							+ ShipMetadata::ElectricalPanelMetadata
								+ x, y, label
								+ Move from definition's to ShipMetadata
							+ Verify (at ShipBuilder::CreateElectricalElements):
								+ No dupe instances (done by json already?)
								+ Exist instance key for each metadata
							+ Passed to ElectricalElements::Add as std::optional
								+ Which stores it in  mInstanceInfos (own struct w/ instance ID and epMD) and later uses it 
								  for announcements
						+ Announcement:
							+ OnElectricalElementAnnouncementsBegin/End
							+ Switch and PowerMonitor announcements take extra:
								+ ShipMetadata::ElectricalPanelMetadata
						+ Panel:
							+ OnElectricalElementAnnouncementsBegin: clear maps
							+ On...:
								+ Make label if no panel element metadata, then pass to control
								+ Store ctrl and panel MD in ElementInfo
							+ OnElectricalElementAnnouncementsEnd: do positioning for all
								+ Layout algo in LayoutHelper
								+ AddControl(ctrl, x, y)
						+ Nuke PowerMonitor extra map and add type to map element (own enum)
						+ Change CircuitTest's electrical:
							+ 1: SingleSwitch (just rename of current): single instance at center, 1st row, no metadata
							+ 2: <normal>: Add switches w/whole json
				+ OnSwitchEnabled: 
					+ Enable/Disable switch control
					+ Enable/Disable in SwitchInfo
					+ Leave in map
				+ OnSwitchToggled(ObjectId, new state):
					+ Lookup from map and call SetState(new state) on control (regardless of disabling)
				+ Keys:
					+ At layout: if interactive, calc key and store in vector<ElectricalElementId> 
					  for key mappings
						+ Make constant w/max elements per row (11)
						+ Ctrl/Alt 1...0
					+ Gets key events from MainFrame when MainFrame does not recognize
						+ OnKeyEvent: returns bool for processed/not processed, so MainFrame can chain					
						+ Uses key mappings to figure out ElectricalElementId
						+ On key:
							+ If SwitchInfo.IsEnabled:
								+ Call SwitchControl->ToggleState() -> newState
								+ Call GameController->SetSwitchState(SwitchId, ctrl->GetState())
				+ Gfx:
					+ Grey hint panel
					+ Use wxCustomBackgroundWindow for the switchboard panel, with a (tiled) background
						+ Try with whole panel, rather than with SwitchPanel only
						+ Try other background
						+ Nail down color of text labels
					+ Nail down font size
					+ Test:
						+ Remove hint label
						+ Just change checkbox's graphics
						+ Move checkbox to top right
		+ SoundController::OnSwitchToggled(., new state)
			+ {on, off} x {3} sounds
		+ Gfx:
			+ Do push switch (mechanical)
			+ Do automatic switch: grey, blue, grey (disabled)
				+ Darker blue, but brighter
			+ Do powermonitor: red, green, grey (disabled)
		+ ShipBuilder: do not propagate new materials (switch, etc.) through ropes
		+ Cleanup:
			+ Test electrical panel w/all controls bottom-aligned
			+ See how to avoid lights flickering with plain switch off
				+ Hack: each time a switch is toggled, ElectricalElements::mHasSwitchBeenToggledInStep is set to true
				+ Use it at lamp state machine
				+ It is set back to false after ElectricalElements::UpdateSinks()
			+ See if can avoid flickering at reload of ship w/circuit
			+ See if can avoid weird position of board at initial load						
				+ Cleanup GameReset/Announcement sequence
			+ Docking sounds
			+ More intuitive pin
				+ Closer to "Switches" label
			+ Clear TODOTEST's in SwitchboardPanel
			+ Mouse pointer on switchboard
				+ SwitchboardPanel::cctor: SetCursor
				+ See whether tool controller should set it only on canvas rather than on application
					+ ToolController::cctor and Tool::cctor take wxWindow for parent, not wxFrame
				+ Make finger pointer
			+ AutoShowSwitchboard preference saving
			+ Nuke ElectricalElements.h::GetConnectedConductingElectricalElements [if not needed]
			+ Nuke Ship.h::commented-out getters [if not needed]
			+ Sound at open and close
			+ Materials guide:
				+ Add new ElectricalElementTypes
				+ Add new properties:
					+ conducts_electricity
			+ Decide whether SwitchboardPanel should be double-buffered or not
			+ Website: add FAQ for heat settings -> Gabe's blog
		+ Run in Debug
			+ Test panel across loading ships
			+ Test electrical repair
	+ Improve "friction" of sea floor: things don't slide down easily; may be add a slider
	+ Power probes:
		+ Rename: "Monitor"->"Probe" in current code
		+ GameTypes:
			+ First off, tag ObjectId
			+ Add PowerMonitorId
			+ Add Switch types:
				! ToggleSwitch
				+ PushSwitch
			+ Add PowerProbe types: PowerMonitor and Generator
				! Engine has own type, EngineMonitor, see at Propulsion (*)
		+ EventHandler:
			! No enabled/disabled
			+ Add power monitor events
				+ Take ElectricalState
		+ New Instanced Generator electrical material
			+ Add to json, new generator altogether, other is !IsInstanced
			+ ElectricalElements::Add: add both generators to sources, treat both of them equally
		+ New PowerMonitor electrical material - and type
			+ Add to json - IsInstanced = true
			+ ElectricalElements::Add: add to sinks
		+ These ElectricalMaterial's announce themselves as power probes:
			+ PowerMonitor (announcement type 1)
				+ Uses arbitrarily initial state as current state
			+ (Instanced)Generator (announcement type 2)
				+ Uses own state's IsProducingCurrent as current state
		+ Simulation of PowerMonitor:
			+ Make it a sink
			+ Keep cur state at PowerMonitor state machine at ElectricalElements::UpdateSinks() and fire toggle events upon state toggle
		+ Simulation of Generator:
			! IsProducingCurrent is same as announced state
			+ At ElectricalElements::UpdateSources(): fire toggle events upon state toggle
		+ Destroy/Repair at ElectricalElements::Destroy/Repair:
			! Make sure announcement follows when generator is restored and becomes powered
			! Alignment of state::IsProducingCurrent with announced state: it's the same
			+ At Destroy:
				+ Generator: if IsProducingCurrent:
					+ Toggle to false and announce
				+ PowerMonitor: if State says it's on:
					+ Toggle to false and announce
			+ At Restore:
				+ Generator: nothing to do: at the next UpdateSources() that makes it work the generator will start 
				  producing current again and it will announce it
					+ assert(IsProducingCurrent is off) // iff guaranteed to be called only when destroyed
				+ PowerMonitor: nothing to do: at the next UpdateSinks() that makes it work there will be a state change
				  and it will announce it
					+ assert(State says it's off) // iff guaranteed to be called only when destroyed
		+ UI:
			+ ElectricalElementControl
				+ InteractiveToggleSwitchElectricalElementControl
				+ InteractivePushSwitchElectricalElementControl
				+ AutomaticSwitchElectricalElementControl
				+ PowerMonitorElectricalElementControl
				+ Redo hierarchy
		+ Switchboard:
			+ Register for power probe events
			+ Swap bitmaps: 
				+ Current non-interactive becomes power monitor
				+ Also rename pngs
			+ Add power probes to switchboard
				+ Type 1 (PowerMonitor): red/green
				+ Type 2 (Generator): Volt gauge (on continuous value) (new GaugeControl, cctor args are bitmaps, center, 3 angles)
					+ Map ElectricalState to min/max values at SwitchboardPanel
		+ Finalization:
			+ Complete Gauge
				+ IUpdateableElectricalControl
			+ Refresh electrical elements' materials template
			+ changes.txt
	+ Propulsion
		! Requires "Forces Rearc" or "Position-based Springs"
		+ 1 new ElectricalElementType: Engine
		+ 2 electrical materials: engine x {LR/UD}
			+ Need a new engine-specific electrical material property: engine_direction, radiants 
		+ 1 new ElectricalElementType: EngineController
		+ 1 electrical material
		! EngineController (telegraph) controls all connected engines, value={-1.0, ..., +1.0}
			! Force that will be imparted is directed along an axis that depend on the control-engine axis and on the direction of the engine
			  material
		+ EngineController announces self as EngineController
			+ And updates use {-1.0, ..., +1.0} values
		+ Engine announces self as EngineMonitor 
			+ And updates use {0.0, ..., +1.0} values
		+ Dynamics:
			+ EngineController: API to set value {-1.0, ..., +1.0}
				+ Updates value in state
			+ EngineController state has array of ConnectedEngine={EngineElectricalElementIndex, sin+cos}
				+ Never modified, usage must check for deletion
			+ ElectricalElements::Add*Factory*ConnectedElectricalElement(..., octant)
				+ Invoked only by ShipBuilder
				+ First, if this is EngineController and other is Engine: populates EngineController state
				+ Then invokes AddConnectedElectricalElement(...)
			+ EngineController is Sink
			+ Engine is *not* sink, but Engine (new indices type)
			+ UpdateSinks: 
				+ For each EngineController sink that is powered:
					+ For each connected electrical element that is Engine:
						+ Calculate power force vector:
							+ Dir = f(octant, points, MaterialEngineDirection)
							+ Magnitude = f(EngineControllerState::ControlValue)
						+ Add power force vector to Engine::State::CurrentPowerForceVector
						+ Engine::State::CurrentPowerValue = max(
							Engine::State::CurrentPowerValue,
							abs(controller's current val));
				+ Then, for each Engine: 
					+ Calculate force=f(State::CurrentPowerForceVector, GameParameters::EngineThrust)
					+ Apply force to point (NonSpringForce)
					+ If Engine::State::CurrentPowerValue != State::LastPublishedPowerValue:
						+ Publish EngineMonitor -> Sound+Panel
						+ State::LastPublishedPowerValue = Engine::State::CurrentPowerValue
						+ Do visual notification if enabled
					+ Reset State::CurrentPowerForceVector
					+ Reset State::CurrentPowerValue
			+ Enable/Disable engine controller upon destroy/create
			+ Engine power should only raise after +/-1, but sound should come at +/-1
				+ unsigned int GameParameters::EngineTelegraphDegreesOfFreedom = 11
					+ static_assert it's odd
				+ Events carry int telegraphValue
				+ Engine power does math to calculate power={0.0, 1.0}
				+ Engine notifications: rpm and thrust
			+ Publish zero value at engine destruction (iff currently not zero)
		+ Adjust thrust
			+ Change circuit test: one single engine now
			+ Add EngineThrustAdjustment
		+ Gfx:
			+ EngineController: Telegraph with hand
				+ N already-rotated hand bitmaps
				+ Mouse events
				+ Key events: back and forth, do not go around
			+ EngineMonitor: RPM Gauge (GaugeControl w/other bg)
		+ SwitchboardPanel:
			+ Handle creations of EngineController and EngineMonitor
			+ Handle enabling/disabling of EngineController
			+ Subscribe to updates of EngineController and EngineMonitor
		+ Sound:
			+ EngineController (telegraph) sound
			+ Engine sound:
				+ Hook volume, pause, reset, etc.; test:
					+ Global mute
					+ Effects volume
					+ Pause
					+ Reset
				+ Fade-in
				+ Add engine_type as new electrical material property
					+ MultiInstancedSound: replace Initialize() with AddSoundType(TSoundTypeEnum, sound buffer)
						+ Stores in unord_map<TSoundTypeEnum, sound buffer>
					+ Communicated at announcement (via ElectricalMaterial)
						+ Stores in unord_map<instance ID, sound type> 
							+ ...in MultiInstancedSound, mInstanceIdToSoundType
					+ Start: takes sound type
						+ And another override that takes instance ID, in which case does forced lookup
						  in mInstanceIdToSoundType
				+ Register for EngineMonitor event, only RPM
				+ Simple continuous sound, keyed by object ID
				+ Add pitch controls to Sound
				+ React to EngineMonitor, track object ID and set object's sound pitch
		+ Click on glass of non-interactive elements => IGameController::HighlightElectricalElement
			+ ElectricalElements: concentrate all highlighting @ HighlightElectricalElement(idx)
			+ Highlight
			+ Sound
			+ Cursor ('?')
		+ Make engines conduct electricity
			+ Json: does not conduct
			+ At engine update: conduct_electricity=(rpm > threshold)
			+ Change circuit_test
		+ Fix highlight/last highlighted
		+ Do engines with different properties:
			+ ElectricalMaterial Properties:
				+ Power (in HP)
				+ Responsiveness
				+ Engine Type:
					+ Steam
			+ Different json materials
				+ Use actual HP, not newtons
				+ Outboard
					+ Sound type
					+ Mount on LifeBoat
				+ One more powerful LR steam engine
			+ Store responsiveness and power in EngineState at ElectricalElements::Add
					+ Pre-convert HP -> Newton
			+ Do responsiveness state machine
			+ Nuke GameParameters::EngineThrust
		+ Switchboard panel: display finger mouse pointer only at interactive controls
			+ Set into ctrl from panel
			+ Dockable checkbox too
		+ Make engines lose power progressively when wet
			+ At Engine update: quantity of water determines target RPM damping
				+ e^(-x + 5)/(5+e^(-x + 5))
			+ Mount engine on a new ship for testing
		+ Do wake with very short-lived ephemeral particles
			+ Only if underwater
			+ At EngineUpdate
			+ SettingsDialog:
				+ checkbox for engine wake
		+ Finalization:
			+ Use PI-based constants for gauge angles
			+ Do engine highlight only on 0<->nonzero transitions
			+ Engine produces heat when running
			+ Engine controller stops working at high temperatures
			+ Restore of engine controller
			+ Restore of engine
			+ Do progress at Switchboard constructor
			+ Switchboard: when scroll bar present, must be taller
				+ Add gridbag sizer to a new vSizer member, and add spacer when needed
			+ EngineController: SHIFT for plus/minus
			+ Draw highlights at right plane ID
			+ If the two switch types are physically identical, move switch type as new electrical property
			  and use it only for announcements
			+ SettingsDialog: EngineThrust or Adjust
			+ Ship preview: add electrical icon
			+ Ship preview: add HD icon
			+ Change "Titanic (with Lights)" into "Titanic (with Electricals)"
			+ Add engine_direction, engine_power, engine_responsiveness (and other properties?) to materials' guide
			+ Add all new types to materials' guide
			+ Refresh both elements' materials templates
			+ changes.txt









+ Water
	+ Water
		+ Ship::LeakWater:
			+ Try rearc: just check if leaking and if externalWaterPressure (0 if above World::WaterHeight) > mWater
		+ Test hull springs/water propagation
			+ Check if also in old program Titanic.png had non-wet hull rudder: YES
			+ Less hull material in Titanic, but maintain strength
			+ Test Titanic afterwards
	+ Did original game propagate water also through hull springs? YES. How did hull thin dividers work? THEY DIDN'T WORK
	+ Add Point::Hull Characteristic, and don't leak/propagate(incl. gravitate) water if at least one of the two points is hull			
		+ Alternatively: just make a spring hull if one point is hull; test it
 	+ Rush sound: should water rush sound be more....rushy?
	+ Water rearc:
		+ Points::Water is height of water column that provides equivalent pressure
			+ When 0<=Water<=1 is also fraction of volume filled with water
			+ Add comments at Points
		+ Ship::LeakWater:
			+ Calc velocity of entering water with Bernoulli
				+ Still need to cap to max (external pressure) because of dt possibly being too large?
			+ Also do negative pressure (i.e. water leaving cell)
		+ Do water-momentum based dynamics					
		+ Cleanups and deferred TODOs:
			+ Test with Bernoulli's spring velocity being added to point's water velocity (times its mass of course)
			+ Do U-shaped tube
			+ SettingsDialog:
				+ Flex spacing
			+ Rename water detail parameter: Water Detail Coarseness
			+ Take perf measurements:
				+ FPS: 26.8/26.9/27.0/27.4
				- MainFrame::RenderGame:	61.08%
				- GameController::Update:	32.92%
					- UpdateWaterDynamics:	 5.85%
						- UpdateWaterVelocities:	5.77%
			+ Refactor UpdateWaterVelocities:
				+ Normalize based off sum of magnitudes
				+ Finalize double-buffering
					+ Take perf measurements afterwards: 27.3/27.5/27.6
				+ 1) Test with memcpy of water buffer
					+ Perf before: UpdateWaterVelocities: 5.59%
					+ Inline first (taking also oldPointWaterBuffer * as restrict)
					+ Perf after: 27.4/27.6
					+ Move to Points as:
						- float * restrict CheckoutWaterBufferTmp()
						- void CommitWaterBufferTmp(float * restrict ...)
							- asserts same as own				
				+ 2) See to improve (sse for 2?) water momentum making/demaking
					+ Move to Points (anyway) as:
						- vec2f * restrict CalculateAndCheckoutWaterMomentumBuffer()
						  or: vec2f * restrict PopulateWaterMomenta()
							- Returns the buffer afterwards
						- void CommitWaterMomentumBuffer(float * restrict ...)
							- asserts same as own
						  or: void PopulateWaterFromMomenta()
				+ Use restrict pointers also for source buffers and springs' properties
					+ Start with only waterBuffer and waterVelocityBuffer, see if improves 1) pre- and post- steps,
					  and 2) main loop
					+ Check asm before
					+ Take perf measurements afterwards: 27.7/28.0
			+ Move "other endpoint" to Springs class
				+ Verify with asm: it's inlined
			+ Finalize 
				+ Take measurements: 27.4/27.7/27.9
				+ Check asm
					+ Momenta initialization
					+ Velocity recalculation
				+ Finalize perf snapshot
			+ ShipRenderContext: add waterLevelOfDetail param to all other shader programs
			+ SettingsDialog: make it tabbed: mechanics, fluid, rendering
			+ Add crazyness to SettingsDialog
			+ Rename GameParameters::GravityNormal to GravityNormalized
			+ GameParameters:
				+ Rename NumDynamicIterations as NumMechanicalDynamicsIterations
				+ Add NumWaterDynamicsIterations
			+ Is Springs::WaterPermeability still used?
			+ See if GameParameters::WaterPressureAdjustment still needed (or needs to change name)
			+ Remove old water dynamics code from Ship
	+ UpdateWaterVelocities: 
		+ See what happens when we also incorporate dest's velocity in Bernoulli
		+ See what happens with drag (after final calculation of velocities)
			+ See if needs to be linear or quadratic
		+ Test with reflected momentum
	+ Splash sound:
		+ First we need to cleanse "rushing water" of bubbles sound
		+ New "splash" continuous sound, with volume controlled by total magnitude of momentum change
			+ Test with ProbePanel, ScalarTimeSeriesControl
			+ Go for kinetic energy lost instead		
		+ Finalization:
			+ Nail down sound
			+ Nail down volume
			+ Measure perf:
				+ FPS: 25.9/26.1/26.2
				+ UpdateWaterVelocities (2m): 11.19%
					+ expf: 2.34%
			+ When removing Q from point, test with using only component of oldV along spring
			+ Recheck one-sided deltaT
			+ Cleanup
			+ Run in debug mode
			+ Averager needs to become member of ship
			+ Optimizations - things to test:
				+ That scalar/vector/scalar
				+ See if can either update all point water momentum once, or for each spring - not both like now!
					+ => FPS=26.2/26.5
					+ UpdateWaterVelocities (2m): 8.75%
						- expf: 0.81%
				+ Low-hanging fruit
				+ Initial point visit for populating exp(water) 
					+ Requires temp buffer
					+ Pre: 26.2/26.5
					+ Post: 26.8/26.9
				+ Initial spring visit for all Bernoulli's (scalar)
					+ Requires temp buffers
					+ Still need to assign sign depending on whether pointIndex is spring's point A or not
					+ Post: 26.8/26.9
					+ NOT WORTH IT
			+ Should replace water rushing in - decide
	+ Do water bubbles (at intake) and water drops (at outtake)
		+ Ephemeral particles emitted at UpdateWaterIntake()
			+ Intake:
				+ Material ("Air") with (very low) weight (real air weight) and full buoyancy so rises up automagically
					+ MaterialDatabase: special getter for it
						+ Mechanism for detecting this and Ropes: unique_type
						+ SoundType needs to become optional
						+ IsRope has to go/ColorKey comment has to go
				+ Ship must take MaterialDatabase 
				+ Emit
					+ Need to coalesce multiple emissions into one
				+ Points::Ephemeral support
				+ Sounds:
					+ Destroy-AirBubble
				+ Expose DoGenerateAirBubbles to SettingsDialog
				+ Air Bubbles Tool:
					+ ~Continuous Tool
					+ Cursor
					+ Continuous Sound
					+ Clean Destroy() doing air bubbles
				+ Don't steal ephemeral particle for air bubbles
					
			+ json comments
				+ Stripped out at Utils
				+ Add comment to air bubble water volume fill
		+ Cleanup: 
			+ Points::Ephemeral maxlifetime expiration is per-type, not global
				+ But buffer stays, useful for finding free slots
			+ Make vortex parameters GameParameters
	+ New sinking (and un-sinking) detection: (*)
		+ Sinking detection is broken - it currently only considers total water that entered the ship, which comes proportionally to external
		  water pressure; all this water could be confined to a tiny volume, and yet we trigger sinking
		+ Should be based off # of points underwater *and/or* total # of wet points
			+ Could be a very-lo-freq step that just checks y's against water height at that point
			  and/or total # of wet points
				+ Use HighWatermark/LowWatermark
				+ Sinking:
					+ Total # of wet points > 2/3 * total points
				+ Unsinking:
					+ Total # of wet points < 1/3 * total points
			+ Make music class with FadeToStop()
				+ Also call its ::Update(), which fades
					+ Called only for music's that we know are to fade
				+ Stop() stops immediately at any point
				+ Test music:
					+ Pause 
					+ Stop/Resink
			+ Test music fading
			+ Find right thresholds: just check default ship and balls and sailship2
		+ Check assembly
			+ See without restrict point but GetWater() directly


+ Debug light/drag issue
	+ Could be due to distance too close and shooting light to sky
+ Do connected component detection
	+ Get new baseline
+ See perf of merged LeakWater+DetectConnectedComponents vs Separate
	+ Use perf analyzer:
		+ Merged:
			- Ship::Update: 60.64%
				- PreparePointsForFinalStep: 3.14%
		+ Separate: 
			- Ship::Update: 63.69%
				- LeakWater: 0.11%
				- DetectConnectedComponents: 3.02%
+ Fix multiple clouds

+ Game Interactions and Controls:
	+ IGameEventHandler: individual methods, including parameter changes, all default-implemented
		+ OnDestroy(Material const *, size) // size=1 for each destroy, but Dispatcher aggregates assuming size=anything
		+ OnBreak(Material const *, size) // size=1 for each break, but Dispatcher aggregates assuming size=anything
	+ GameController::RegisterGameEventHandler(IGameEventHandler *)
		+ calls into GameEventDispatcher::RegisterGameEventHandler, who does:
			+ Registration of real sinks (vector of plain IGameEventHandler *)
			+ Aggregation of duplicate events 
				+ e.g.: OnBreak: keep distinct Material * and sum for size
				+ Clears aggregations at OnStepStart() (from GameController) and publishes them
				  to registered sinks at OnStepEnd()
	+ GameController gives shared_ptr<GameEventDispatcher> to Game at Game's cctor (as shared_ptr<IGameEventHandler>)
	+ GameController calls mGameDispatcher (shared_ptr<GameEventDispatcher>)->OnStepStart()/End()
	+ Invoke events at Game and below (pass handler at XYZ.Update())
	+ First GameEventHandler: EventTicker
		+ It's custom panel at bottom with text ticker
		+ EventTicker holds wxPanel and draws it (figure out OnPaint and DC...)
		+ Created by MainFrame and registered by MainFrame on GameController
		+ Hide it by default and only show via MainFrame menu option
		+ Complete event handlers
		+ Do ship sinking event notify in ship (mWater > 1/3 points)
	+ Increase max grab force
	+ Extended status text
		+ Shows:
			+ Current zoom
			+ Rendering vs simulation percentages
				+ GameController continuously updates, same way as FPS
			+ If paused
				+ Actually, this is from StatusText
		+ Multi-row:
			+ Text layer gets it split & gives vector to TextRenderContext
	+ Move tool
		+ Rename current "move" as "Pan"
		+ ShipId type (see around here)
		+ ObjectId type (see around here)
		+ With move tool enabled:
			+ Click on ship -> GameController returns std::optional<ShipId> -> if not None, tool is engaged (save cur screen pos)
				+ Works like pan 
			+ Moving tool tells GameController delta (offset) screen 
	+ Ship definition: multiple layers
		+ We want to maintain BW compat for ease of one-layer ship making
		+ Impl:
			+ json:
				+ "structural_colour" -> "color_key"
				+ "colour"->"color"
				+ Copy & rename
				+ Structural:				
					+ Refactor sound_type for all structural elements
					+ Remove electrical properties
				+ Electrical:
					+ Remove non-electrical materials
					+ Refactor materials
			+ Breakup material class
			+ MaterialDatabase
				+ Restructure 
				+ Find: fallback to rope
			+ ResourceLoader::LoadMaterialDatabase()
			+ IGameEventHandler events take now StructuralMaterial
			+ Points::new struct for materials
			+ Springs, Triangles
			+ ElectricalElements
			+ Ship
			+ ShipDefinition/File: new layers, plus bw-compat
			+ ShipBuilder
			+ Event publishing
			+ Event handlers
			+ Sound renames
				+ StructuralMaterial::MaterialSoundType MaterialSound
			+ GameController
			+ Fix issue with rope endpoints
			+ Fix issue with rope buoyancy
			+ Rope shader: use color from point color buffer
				+ And then get rid of rope color passed to RenderContext
		+ Get rid of IsRope from structural material
			+ Also from json
		+ Test:
			+ BW compat old ships
				+ Electrical
				+ Ropes
				+ All
		+ Renew ships:
			+ Make SS queen of unova use layers
				+ Fix structure as well
			+ Make Szersen cargo use layers
				+ Also test propagation of electrical (cable, in this case) along ropes
				+ Also test different colors for ropes
		+ Cleanup:
			+ Do two new material template screenshots and nuke old one
			+ Redo materials.md
	+ New "Impact" Bomb
		+ Only explodes when spring is destroyed
		+ State machine only for explosion
		+ See why huge explosion
		+ See why texture weird
		+ Center texture
		+ Help
	+ Tool to flood ship
		+ Name: Flood
		+ Shift: un-floods
		+ Icon: bottle (flood), syphon/dropper (unflood)
		+ New ToolController/Tool
			+ Continuous, like Destroy
		+ World->Ship::OnFloodAt(x,y,strength)
			+ Find closest (very small radius)
			+ Add water quantity to point
			+ Emit event
		+ Sound: continuous as long as ship takes water
			+ So, like sawed
				+ Update() attempts to stop i
	+ Control incisiveness (contrast) of water color for water in ship
		+ New uniform
	+ Save screenshots/photos 
		+ Saves automatically in custom folder
			+ New settings provider: UISettings
				+ Managed normally by SettingsManager, and thus tweaked via SettingsDialog
				+ Cctor sets default path (which will be default for SettingsManager)
		+ Code (at RenderContext::TakeScreenshot() -> returns ImageData)
		    glPixelStorei(GL_PACK_ALIGNMENT, 1);
		    glReadBuffer(GL_FRONT);
		    glReadPixels(0, 0, windowWidth, windowHeight, GL_BGR_EXT, GL_UNSIGNED_BYTE, pixels);
		    + See glPixelStorei and glReadBuffer
		    + Call glFinish before all
		+ MainFrame does the saving, via GameLib/ImageTools
			+ Move load functions from ResourceLoader to ImageTools
			+ All static methods
			+ Creates UISettings and passes to SettingsDialog
			+ MainFrame responsible for finding unique filenames like smartphone, with micro's portion
			+ Fires snapshot sound	
		+ SettingsDialog:
			+ Add DirCtrl under tab "TODO"
				+ https://docs.wxwidgets.org/3.0/classwx_dir_picker_ctrl.html
		+ Make actual snapshot sound
		+ Changelist
	+ Pick tool: ability to move individual connected components (*)
		+ After connected component has been overhauled
		+ Spec:
			+ New tool gets point ID from GameController::Pick() and passes it to new MoveTo()
			+ Move tool becomes this new one
			+ Old move tool becomes "MoveAll" tool
		+ Impl:		
			+ Pick engagement returns ObjectId for point ID (or none)
				+ Ship::Pick(vec2f position) -> opt<ElementIndex pointId>
				+ World makes opt<ObjectId>
			+ Ship::MoveTo(ElementIndex pointId, vec2f position, vec2f velocity) (new overload):
				+ If point deleted => return false (to disengage)
			+ Tool: copy from Move
			+ Make cursor for "MoveAll"
			+ Help
			+ Changes.txt
+ Sound:
	+ SFML:
		+ Build own
		+ Add bins reference to ship CMake
	+ Mute @ Menu
	+ Fix splash progress - make sure final "Complete" shows
	+ Break/Destroy: handlers also take bool isUnderwater (based off Y of broken thing wrt world's water height)
	+ MainFrame initializes SoundController, which implements IGameEventHandler
		+ Initializes off visit of Data/Sounds and Data/Music, w/Music and Sounds
			+ Mapping of sounds with IGameEventHandler events via:
				+ Material::optional<SoundProperties>
					+ SoundMaterial: enum(wood, metal, ...)
					+ Material enums have StrToX()
				+ Filename patterns of sounds and music (e.g. destroy_wood_small_underwater_1.wav)
					+ Parse: if 'destroy'=>expect SoundMaterial next, then ...
				+ Storage of sounds:
					+ Maps store vector<SoundBuffer>
						+ Values are all the variations of the sounds, and 
						  SoundController chooses randomly
					+ Sounds are created when played and stored in queue together with timestamp
				+ Sounds stored in maps (of maps of...) indexed by coordinates off filename patterns
					+ Material's enums used as coordinates, together with SoundController's own
					  enums (e.g. action, size, underwater type)
				+ ResourceLoader has: 
					+ GetSoundFilenames() -> all sound (relative) filenames
					+ GetSoundFilepath(filename)
		+ Do random choice
		+ Need to manage number of currently-playing sounds
			+ When currently playing > MaxPlayingSounds (constexpr):
				+ ScavengeCompletedSounds()
				+ If still full, stop oldest (among same SoundType, or absolute if none) and pop it 
			+ ScavengeCompletedSounds() also called at SoundController::Update()
	+ Stress event
		+ At break loop: for each spring:
			+ Spring->UpdateTensionStrain(..., IGameEventHandler):
				+ If is broken=> this->Destroy(); break event (calc undewater); 
				+ else if is stressed=>
					+ If !mIsStressed:
						+ set; stress event (calc undewater)
				+ else:
					+ mIsStressed = false;
		+ Spring::IsStressed()->mIsStressed, used for rendering
	+ Don't play soundbuffer if already playing for < 20ms
	+ Sounds:
		+ destroy, stress
		+ finish destroy 
		+ better cable snap
		+ Listen to all materials
		+ fix destroy cable/string's
		+ Batch convert all to flac
			+ Test and commit
		+ underwater: with reverb effect
			+ Batch mode, save aside current underwater's first!
	+ MainFrame registers SoundController as Handler with GameController
	+ Sinking music
		+ GameController starts it upon OnStartedSinking() event
	+ See if sounds should be spaced more apart
	+ See underwater cable sounds - sound like metal?
		+ break small 1, 3, 4
		+ destroy medium 1
		+ destroy small 4
	+ Draw event: 
		+ GameController fires Grab, simple
		+ SoundController: uses own sound.isPlaying as state and starts @ event/stops @ update
			+ Uses two consecutive Update() w/no Draw in-between as stop
			+ how to loop though?
	+ Rethink notification of Draw and Swirl events
		+ Remove from GameController, fire at tool via "Toggled(bool)" events
		+ Remove magic from SoundController
		+ Can always modulate sounds at Tool::Update, for example asking GameController::IsUnderwater(screen coords)
			+ Do at Chainsaw, do underwater sound 
				+ Change event handler:
					+ OnSaw(opt<bool> isUnderwater): off, on overwater, on underwater
		+ Test: get rid of all FlushEvents outside of update
			+ If OK, remove commented-out code
	+ Reset sound controller at ResetAndLoadShip()
	+ Water rushing-in
		+ Continuously-playing sound
			+ Find sample
		+ Volume time-interpolated off total quantity of water that entered ships during step
			+ Communicated via new event - OnWaterRushedIn(total_water_quantity)
			+ total_water_quantity update (passed by arg &) replaces mTotalWater update
				+ mTotalWater updated afterwards with +
			+ Volume = 100 * ( -1/(Qw+1) + 1 )
				+ Qw = some scaled version of total_water_quantity (1.0f might suffice)
	+ Separate sound control for tools
	+ Saw sound
	+ Turning down a bit the very high pitch stress noise
		+ Do it on flac - on all high-pitched ones (same amplitude)
	+ Sawing: do not publish destroy events when cutting springs, but new "Sawed" events with own metal/wood sounds
		+ Two new continuous sounds: metal and wood saw
		+ OnSawed is invoked with Type and size - size=0 means nothing
		+ Event handler sets continuous sound's volume up/down (when size=0), and eventually starts it
		+ Stopping continuous saw sound also sets volume of these two to zero

+ Put credits
	+ Splash: https://www.artstation.com/stukata/profile, contact the guy

+ Fix: When land is above water, water is upside down

+ Optimization: to improve locality: points in contiguous buffer
	+ No PointerVector but (fixed) std::vector<Point>, and others point to locations in the vector
	+ Points never deleted, just marked
		+ So have to check point.IsDeleted() each time the Point buffer is iterated
		+ No check
	+ Point destroy: also clear *own* references
	+ Try contiguous buffer also with springs and triangles
		+ And not checking isDeleted
			+ Remove assert's
		+ Multi-step create loop
		+ Spring destroy: also clear *own* references
		+ Triangle destroy: also clear *own* references
		+ Do check IsDeleted for Spring and Triangle operations that may affect connected non-deleted points
		+ New perf: 15.7/15.8
		+ See ElementContainer::range(start, end)
			+ UnitTests, verify last excluded
	+ IsDeleted needs only be checked at SpringRender and TriangleRender
	+ Try fast_qrt for vec2f::length()
	+ Test fast_XYZ at vector
		+ fast_inv_sqrt: 15.2/15.3/15.3
		+ 1/sqrt: 15.3/15.3/15.3
		+ Nuke'em if ok
	+ EventTickerPanel is stealing 1.99% even when not shown

+ Render optimization: only upload spring elements, triangle elements when they're dirty (deletion occurred)
	+ Get perf analysis first:
		- Game::Render: 34.90%:     Ship::Render: 31.53% (Incl)	3.05% (Excl)
			- RenderShipEnd: 28.24%	- Ship::RegisterDeletion: sets mAreSprings/TrianglesDirty=true
	+ cctor: true
	+ set to false after uploaded to RenderContext 
	+ Move XRay flag consumption to RenderContext 

+ Now that we have connected components, fix covering of ship pieces:
	+ Draw batches of triangles and springs by component, so that pieces are "covered" nicely
		+ Ship keeps track of # of connected components and of each size
		+ At RenderXYZ(), allocate N buffers for the vertex indices and dispatch each triangle/spring
		  to the correct buffer based off ConnectedComponentID 
			+ ConnectedComponentID passed by caller (spring or triangle) based off the (first) point
			  of the primitive
				+ assert other points have same ID
			+ Note: points themselves are not affected by this; they're still uploaded in their entirety 
			  once per cycle
		+ At RenderXYZEnd(), draw each connected component buffer from last to first
		+ Do for triangles
		+ Do for springs
		+ Each connected component must be drawn together - its springs then its triangles

+ Technical Debt:
	+ Resources: lowercase filenames
		+ git
		+ code
	+ /Data
	+ /Ships
		+ Uppercase ship filenames
		+ Code (ResourceLoader)
		+ source (git)
		+ CMake
	+ MainFrame::Die(msg of exc)
	+ Get rid of Game.cpp and move functionality to GameController
		+ ResourceLoader::LoadDefaultShip()
		+ Also, don't load default ship autonomously (need to register event handlers before that happens);
		  rely on MainFrame calling GameController::LoadDefaultShip() after registration
	+ Change calls to Point::SubtractFromLastPosition() to AddToLastPosition() and use (& implement) unary '-' operator for vectors
	+ Points and Springs and Triangles::Destroy()'s are templated on Point/Spring/Triangle"Being"DeletedHandlers (others than self),
	  & ship passes own methods
		+ OR: even better, as handler never really changes: cctor takes handler at beginning, given by ship,
		  and stores as std::function
		+ Handlers invoked *before* actual deletion
			+ Comment on handlers on connected-to-argument might be deleted
		+ Not re-entrant - can't delete from within
		+ Handling of pinned point deletion is then done here
		+ See if also whole logic of point<->spring<->triangle can be done in handler
			+ If so, don't pass containers at various Destroy()'s
		+ Test
	+ CircularList::Erase unit test: complete verification of returned iterator
	+ Containers::Destroy and GameEventHandler::OnDestroy rearc:
		+ 3 containers are given shared_ptr<GameEventHandler> and ParentWorld & at cctor
		+ The 2 Destroy()'s fire events (after invoking DestroyHandler), unless otherwise specified
		  via DestroyOptions
		+ Ship's DestroyHandlers don't fire events anymore, and Ship::SpringDestroyHandler takes boolean
		  for triangles (translated from Springs::DetroyOptions)
		+ Test assert's with Debug build
	+ Move definition of ElementIndex et al into GameTypes.h
	+ Move also pinned points to a PinnedPoints class, just like Bombs
	+ Textures are json files, with world size, offset, and lighting boolean
		+ SEE MOLESKINE
		+ Cleanup:
			+ RenderContext:
				+ Hook up IProgress to individual loads
					+ Double-check total count adjustment				
			+ Commit
		+ Then:
			+ (Ship)RenderContext: Do not store sizes but whole database instead
				+ Database must be associated with GLuint's of textures
				+ RenderContext stores (moves) database at cctor
				+ Passes reference to ship
				+ TextureDatabase::GetFrameMetadata(TextureFrameId)
					+ TextureDatabase builds map of references at cctor
			+ Remove hardcoded sizes and offsets and substitute with metadata lookups
				+ Cloud size
				+ Water size
				+ Land size
				+ Pinned point size
				+ Bombs sizes and offsets
			+ Test
				+ Double-check clouds's aspect ratio
				+ Anchor at all frames of timer bomb
			+ Commit
			+ ShipRenderContext: replace pinned points and bombs with Upload(Ship)TextureRenderSpecification:
				+ PinnedPoints
				+ Bombs:
					+ Upload4Render() eventually invokes twice (lighted and unlighted)
					+ Frame indices are TextureFrameIndex instead of uint32
				+ Args:
					+ ShipID (used only by RenderContext to dispatch)
					+ ConnectedComponentID
						+ Until Z-rearc: ShipRenderContext has one TextureRenderSpecification per-connected component
						- After Z-rearc: put in buffer for shader to transform to Z
					+ Position (vec2f)
						+ Of anchor
					+ Orientation (std::optional<vec2f, vec2f>)
					+ TextureFrameId
				+ ShipRenderContext gets TexturePolygon from TextureRenderManager::CalculateTexturePolygon
					+ TexturePolygon is declared at RenderTexture.h, which includes other Texture render .h's
					+ Contains 4X{pos,textureCoord, and AmbientLight adjustment}
					+ For the time being it calculates also rotation
					+ Nuke RotatedTextureRenderInfo.h
				+ Use a single shader for these "simple" textures
					+ Takes TexturePolygon, described to OpenGL
				+ ShipRenderContext rearc:
					+ Textures -> TBD Name="Generic"
					+ Simplify alpha and beta with just beta, and beta is "ambientLightSensitivity"
				+ ShipRenderContext: Detach textures from ConnectedComponentData
					+ RenderContext::RenderShipStart(connected components)
					+ RenderContext::RenderShipEnd()
				+ Double-check cloud rectangle calc'n against TexturePolygon
				+ Test
					+ Double-check clouds's aspect ratio
					+ Anchor at all frames of timer bomb
					+ Rotation of bombs
				+ Move TextureRenderManager::AddRenderPolygon method to .h, and call it EmitRenderPolygon
				+ Move bind into TextureRenderManager, templated
				+ Nuke old bombs/pinnedpoints at ShipRenderContext
				+ Commit
		+ Change the single shader to do *all the work* (for the "simple" textures, including rotation) for all ships and connected components
			+ Initially, runs on 1 texture at a time
				+ After atlas and Z, runs on all textures (via atlas' per-frame texture coordinates)
			+ Perf before moving rotation into shader (2000 textures, @ 30s):
				+ With multiple batches:
					+ FPS: 16.5
					+ ShipRenderContext::RenderGenericTextures: 31.29% 
					+ TextureRenderManager::EmitRenderPolygon: 0.53%
						+ atan2f: 0.16%
						+ sin+cos: 0.09%
				+ With single batch:
					+ FPS: 12.24
					+ ShipRenderContext::RenderGenericTextures: 4.65%
					+ TextureRenderManager::EmitRenderPolygon: 0.83%
						+ atan2f: 0.28%
						+ sin+cos: 0.16%
			+ Move rotation et al into shader (without Z for now)
				+ TexturePolygon is modified to also contain orientation
			+ Perf after moving rotation into shader:
				+ With multiple batches:
					+ FPS: 16.4
					+ ShipRenderContext::RenderGenericTextures: 32.23% 
					+ ShipRenderContext::UploadGenericTexture...: 0.56%
						- atan2f: 0.14%
						- vector: 0.10%
				+ With single batch:
					+ FPS: 12.29
					+ ShipRenderContext::RenderGenericTextures: 6.88%
					+ ShipRenderContext::UploadGenericTexture...: 0.75%
						- atan2f: 0.21%
						- vector: 0.08%
			+ If OK:
				+ Nuke TextureRenderManager::EmitRenderPolygon and do all at ShipRenderContext::UploadGenericTextureRenderSpecification
				+ Move TextureRenderPolygonVertex out of RenderCore and make it private to ShipRenderContext

			+ Extra optimizations to test:
				+ vector (no test)
				+ Use a vec4 for the four lonely floats
					+ With multiple batches:
						+ FPS: 16.4
					+ With single batch:
						+ FPS: 12.29
				+ further packing: two vec2 as one vec4
					+ With multiple batches:
						+ FPS: 16.4
				+ Commit
				+ atan in shader - REJECTED
					+ requires two extra vec2 or a vec4
					+ With multiple batches:
						+ FPS: 16.2
						+ ShipRenderContext::RenderGenericTextures: 31.50% 
						+ ShipRenderContext::UploadGenericTexture...: 0.56%
							+ vector: 0.56%
			+ Final perf test:
				+ FPS: 16.4
			+ Text single texture rotating
			+ Cleanup:
				+ Ship's test upload
				+ reorder RenderCore::VertexAttributes
			+ Final test with game, real textures
	+ Fix issue with very fast rope sinking
		+ How's a wet rope different than iron hull? Test with test_ship.png
		+ It's because ropes get water (when broken) and gravity force is based off point_mass+water, while integration only uses point_mass
			+ In fact it also applies to all light hulls that are broken
		+ See if can apply buoyancy always, and thus get rid of Points::Buoyancy
			+ Nope: too many hull materials would float
		+ NOPE: Apply water mass at Integrate then? And what about springs - should use new mass there as well?
		+ Two possible fixes:
			+ Just don't consider water at gravity if buoyancy=0 (i.e. if hull)
				- i.e. revert the buoyancy fix
				- result is that wet hull points never feel water weight (and neither buoyancy)
			+ THIS ONE: Or, buoyancy=0 points (i.e. hull points) never take water, period
				+ i.e. they are never set leaking upon spring destruction
				+ First figure out how internal hull gets wet - if it does - IT DOES NOT!


	+ Move RenderContext et al into Render:: namespace and file group
			+ See if TextureTypes.h is still needed and whether it can be moved to GameTypes
				+ After all, ShipRenderMode is in GameTypes
				+ Polygon for now moves to that class that makes it

	+ ToolController rearc:
		+ ToolController has pointer to SoundController, and tells the latter when to play and stop tools' sounds 
		+ IGameEventHandler events then exist only for the world-generated noises (e.g. something really breaking), not
		  for the tools
		  + So Swirl, for example, should disappear from IGameEventHandler; some others as well
		  + Tools don't invoke IGameEventHandler->OnSwirl(), for example
		  + Removed:
			+ OnSaw
			+ OnDraw
			+ OnSwirl

	+ CMake:
		+ INSTALL target for release
		+ RelWithDebInfo: Inline any suitable (/Ob2)

	+ Replace ShipDefinitionFile's metadata with ShipDefinition

+ Ships:
	+ Titanic:
		+ Introduce weak metal
			+ Use it underneath funnels

+ Help:
	+ wxWidgets HTML help: http://docs.wxwidgets.org/3.0/group__group__class__help.html
		+ Also, just https://github.com/wxWidgets/wxWidgets/blob/WX_3_0_BRANCH/samples/html/about/about.cpp
	+ Use icons for keys

+ Fix bug: when you reload ship when paused, no clouds & no ship are visible until resumed
	+ World::Initialize():
		+ Calcs connected components for each ship
		+ Builds clouds
		+ Invoked by GameController after pair of world::Reset and world::AddShip()

+ Compare old (released) look with this one, and see if there are changes (in phys, render,...) to take in
	+ Also jellyfish fixed in 1.2.6? NO

+ Release:
	+ Do structure first (above)
	+ Check if less rope mass makes empress of britain not break
	+ Add all other ships 
		+ Remember: uppercase and spaces filenames
	+ Do new .shp's:
		+ Carnival
		+ Titanic
	+ Rerun perf profiling
	+ Lower volume of stress sounds, so that break sounds are louder
	+ @Release only: make Krafting.shp the default ship
	+ Screenshots @ github readme
	+ Tell art guy
	+ Send email to Luke
	1.3.0:
	+ Fix Ocean Depth
		+ Affects only textures, not land
	+ Make some ships
		+ Copy three balls
		+ Make ShipTools, -quantize verb
		+ Make some stiffer columns of steel, iron, titanium, etc.
			+ materials: also order rows based on mass
			+ Do last steel column stiff
			+ Iron and Wood
				+ Switch stiff wood with new one
					+ Switch also Titanic
						+ Test
			+ Add "f=..." to template or better "M:S:F"
			+ Test newest ship
		+ Copy, change, and fix from old:
			+ Ship5
			+ Ship6
		+ Cruise vessel
			+ Plan:
				1 + New layer, with thin hull and light interior
					+ Fix buoyancy
				2 + Introduce heavy metals - own row, just grey's
					+ Make strong structural beams
				3 + Adjust colors by peeking at lower layer
					+ Redo the layer with quantize
				4 + Detachable life raft 
					+ Make "Nails" material
	+ Call .shp parts ".png.dat"
		+ Rename via git
		+ Edit .shp files
	+ Build and release 1.2.0
	+ Post to forum
	+ Add to gamejolt

+ Lights
	+ need Optional()
	+ Material:
		+ use picojson
		+ Material.ElectricalProperties (optional)
			+ type (Material::ElectricalProperties::ElectricalElementType=lamp, cable, generator)
			+ flat list of all electrical properties, some apply some don't
	+ class Lamp()
		+ points to Point and Point points optionally to ElectricalElement (base abstract of Lamp, Cable, Generator)
			+ ElectricalElement::GetType(){return mType;}: non-virtual, it's optimized by compiler
	+ Move electrical components to ElectricalElements class, an ElementContainer but also like bombs, with update and state machines
	  (but no render)
		+ GameEventHandler and points members
		+ Buffers (type, connected electrical elements, etc.)
		+ AddCable/Lamp/...()		
		+ Destroy
			+ Removes self from connected
				+ OR NOT: If Ship::PointDestroyHandler deletes point's connected springs before point's electrical element,
				  then we can assert that electrical element has no connected points anymore already
		+ Getters ("subset" section) for Lamps and Generators
		+ Update()
			+ Invoked by Ship
			+ For each lamp: runs its state machine 
				+ Via RunLampStateMachine(LampState &)
				+ Outcome: AvailableCurrent
	+ Materials: self-powered lamp
		+ Just boolean property in JSON
			+ Current light material is self-powered
			+ New light material is not
		+ ElectricalElements: store boolean at LampState (const, passed via cctor)
	+ Point has ElectricalElementIndex (or None), passed at cctor
	+ ShipBuilder:
		+ Create ElectricalElements via ElectricalElements::Add
		+ Give point/elec element index to each other
		+ Add connected electrical elements to each other
			+ See how it's done for points, springs, etc.
	+ Nuke ElectricalElement, Cable, Generator, Lamp
	+ Nuke unused Material electrical properties
	+ Ship::PointDestroyHandler:
		+ Destroy point's ElectricalElement, if any
		+ Do this after deleting springs, so that ElectricalElement::Destroy does not have to remove self from connected elements (see above)
	+ Ship::SpringDestroyHandler:
		+ Remove each endpoint's ElectricalElement (if any - both must be elec elems) from each other's ElectricalElement
	+ Move StrToDuration and includes to GameTypes.cpp
	+ Move ElectricalElementIndex at Points to own buffer
	+ @Ship::Update():
		+ New "inline" electrical section:
			+ UpdateCurrentConnectivity():
				+ Invoke regardless of dirty elements, as generators might become wet
				+ From generators to all reachable points, just propagates visit seq num
			+ ElectricalElements::Update()
			+ DiffuseLight()
				+ For each ElectricalElement::Lamp: 
					+ Use its AvailableCurrent and set mLight 
	+ Implement full lamp state machine @ ElectricalElements::RunLampStateMachine
		+ EventHandler: OnLightFlicker(size, length, isUnderwater)
		+ Update() takes Points (for underwater)
		+ Implement
		+ SoundController
			+ Add new sound for electrical cable
				+ 2 X random, X 2 underwater
			+ Find 2 sounds ("electrical discharge" or "electric arc")
				+ And make them also underwater
				+ Lower volume of overwater ones
	+ Optimizations:		
		+ Take perf analysis of circuit test 1 (2 mins Circuit Test 1)
			- World::Update: 30.15%
				- UpdateElectricalConn: 0.06%
					- Deque::new: 0.01%
					- Deque::~: 0.01%
				- ElectricalElements::Update: 0.05%
				- DiffuseLight: 0.43%
		+ Ship::DiffuseLight: see inverting nested loops (for each lamp: for each point)
			+ Need test ship with many more lamps
			+ Before perf analysis: DiffuseLight: 35.83% == ~30,000 samples; fps=22.10
			+ Switch loops:
				+ Requires first point light zeroing!
				+ After perf analysis: DiffuseLight: 30.63%; fps=24.x
		+ Do perf analysis with complex graph
			+ Need circuit test 3
			+ Impact negligible: Ship::UpdateElectricalConnectivity: 0.21%
	+ Diffusion:
		+ Can test it by itself, by using light material and by cheating with current!
		+ After current propagation:
			+ Zero out mLight of each point (use generation sequence number? useful for other Point properties?)
				+ No, easier and probably faster to do it in same pass as LeakWater - LeakWaterAndZeroLight()
		+ Diffusion: propagate mLight to adjacent points (incl. other lamps),
		  inv. proportional to distance^2, with a graph flood stopping at max distance
		+ Point.GetColour() takes also into account mLight (from itself, not from lamp) 
                  and makes alpha blend just like water
		+ Need "off" color to use at lamp point when Lamp is off (different than structural color),
		  used when rendering point in springs/triangles/points
			+ Not used when using textures, of course
			+ Needs material's Color to split in StructuralColor and RenderColor (set to the same except for lamps)
	+ Diffusion improvement: see if can simply add light (rather than max'ing it)
		+ Need to ensure sum is always < 1.0
		+ Or just set to max(1.0, cur+new)
			+ Best when done in point->lamp loop: add up in inner loop, then assign to point as max
			+ Doesn't improve look considerably, and still requires an if

+ Bugs: 
	+ Ship::Render: when there are no changes to elements and we keep uploading stressed springs, we don't reset the count
	  in ShipRenderContext::mElementBufferSizes
		+ Fix simply by having Start and End for uploading stressed springs
		+ Done in FB branch
	+ No default args @ vec cctors
		+ Done in FB branch
	+ Fix mem leak
		+ Plan:
			+ Calc base rate of growth: 500K/sec
			+ Comment out ShipRenderContext::Render halves until find the one
				+ When nothing done in loop: 159K max
				+ Just PinnedPoints: grows fast
				+ No texture & no buffer: grows fast
				+ No parameters: grows extremely slow
				! No OrthoMatrix param, Yes AmbientLight param: grows fast
				+ Yes OrthoMatrix param, No AmbientLight param: grows extremely slow
			+ Undo all (dbl-check)
			+ Commit other work
			+ glHint(..._HINT) x 2 at Render::Start()
		+ Cut down on calls to glSetParameter:
			+ Before FPS: 27.4
			+ ShipRenderContext::SetXYZ (ortho, visible world coordinates, and light)
				+ Sets into all programs
				+ Nuke member references
			+ ShipRenderContext::cctor:
				+ Sets into all programs with value from cctor args (this time by val)
			+ RenderContext::UpdateXYZ
				+ Set into all ships
				+ Passes current values by val into new ships
			+ After FPS: 27.4
			+ Verify leak is slower
			+ Do also at RenderContext
	+ Fix issue with clouds and canvas size (wrong aspect ratio)
	
+ Roadmap:
	+ 1.7.0
		+ Magic spring optimization (*)
			+ Then decide whether to increase the number of basis iterations, and whether to adjust strength
				+ SQ: 2.0 => Basis = 24
				+ Strength to maintain Titanic auto-break: <= 0.397928
					+ Change max strength to 10 and see again value: 0.403352
				+ Tune bombs
				+ See pin				
				+ Change ocean floor bump - remove center chasm and move it right
				+ Fix sound quantity
				+ Adjust volume of those two high-pitched sounds
				+ Adjust container ship
				+ Bomb blast radius: 2.0
				+ Fix missing RC bomb pings 
					+ verify break & stress sounds are still good
		+ Test collisions with seafloor being less destructive
		+ Fix crash
			+ Springs and Triangles cctors: pass default-ccted FixedSizeBuffer() there, not {}
			+ Then revert floor collision
			+ Remove TODO's with checks at: 
				- Ship.cpp
			+ Clear super/sub buffers in destroy handlers

		+ Move inertia & ultra-violent mode
		+ Move tool extension: rotate
			+ Shift: up ccw, down cw
				+ Make it relative to prev pos
			+ Change icon
		+ Slider for water drag adjust
			+ Test with water drag depending on v^2
		+ Update help:
			+ Anti-Matter bombs
			+ Move tool

		+ See collisions' bug
			+ Move tools always update velocity
				+ Checl L'n'F'

		+ Strength adjust at 1.0

		+ Decide max water drag: 
			+ 100: OK,but not really "draggy"
			+ 10,000: awesome

		+ Extended status: take stats from RenderContext
			+ RenderContext::Stats:
				+ LastRenderedShipSprings
				+ LastRenderedShipTriangles
				+ LastRenderedGenericTextureTriangles
				+ LastRenderedConnectedComponents
				----
				+ Reset stats at each RenderContext::RenderStart()

		+ Redo full perf analysis

		+ Recheck L'n'F' for current collision handling
		+ Recheck L'n'F' for strength
	+ 1.7.5
		+ Test a density adjustment to make ships float more easily without affecting bending
			+ 0.55
			+ See real weight of steel H-beam: 151 Kg
			+ See old ships
			+ See Roma: work on it and see L'n'F'
			+ If OK:
				+ Fix ships:
					+ Base: a bit heavier (lower center of mass) - make it stiffer in the process
					+ Container ship: make it heavier, containers are too light and ship won't sink
						+ Rename .dat's
					+ Submarine
				+ Adjust materials.json
					+ Python script for materials
					+ except for double-bottom's
				+ Remove hack at Materials.cpp				
				+ Recheck all ships
					+ Fix Submarine
				+ Redo materials template
		+ See if can make Titanic not take water all up quickly
		+ See if now some TODO ships are buoyant
		+ .dat renames:
			+ Ship 0: PM_Oasis
		+ Try out auto-texture
			+ Awful
			+ See with nn_mipmap_linear
			+ See with custom upsize
		+ Figure out strength adjustment based off # of simulations
		+ Check structure/texture alignment issue
			+ Fix
			+ Fix Titanic
				+ Fix ropes: offset -1L, +1B
			+ Fix Queen of Unova
				+ Fix ropes: offset -1L, +1B
				+ Fix eaten things
		+ Reduce sparkles' angle
		+ Impact bomb (*)
	+ 1.8.0
		+ Multi-layer ships
		+ Initial GL canvas size issue
		+ Focus kill/tools issue
		+ Add cloth material (*)
		+ Improve light diffusion (*)
		+ Buoyancy rearc (*)
		+ Crazy ropes:
			+ Don't touch water retention
			+ Add new "water diffusion speed" - value=0.5
				+ Materials system
				+ Points buffer
				+ Use at UpdateWaterVelocities
				+ Rope: 0.015

			+ Make water quickness a "water quickness adjust", between 0.0 and 2.0, default = 1.0
				+ Also @ setting dialog
			+ Test:
				+ Ropes @ ATest
				+ Flags/Cloth
					+ Also with move
				+ Settings Dialog
				+ Perf (after optimization above)
		+ See if need to bump up again global damp
			+ Test: bomb on Titanic; splinter springs tend to dance a tad too much		
		+ Add Roma
			+ .dat renames
		+ Light:
			+ Add low/medium/high-dimmed lights and portholes (*)
		+ See if cloths should be lighter - to not break ropes
		+ Bubbles
		+ Flood tool
		+ Test if debris (and sparkles?) really fly out of water
		+ Redo Submarine - thicker to avoid bending
		+ Lights with different chances of turning off when wet
			+ Do test ship
			+ Do
		+ Trawler with cloth
		+ Ship loading: resize of texture must depend on actual image size (don't get huge)
		+ Make these ships more breakable:
			+ Titanic
			+ Krafting
		+ Porthole: "wet_failure_rate": 3.0
		+ Terrain adjust tool
			+ Managed by World via OceanFloor
			+ See if can get rid of extra sample
				+ Also at Water
			+ Fix zero-index
			+ Undo 500 samples
			+ Test multiple destruction sound w/delay being 50ms
			+ Sound (hammer)
			+ Changelist
		+ Wind and cloth (*)
		+ Do we still need render color in material?
			+ YES - For ephemeral particles
			+ Update guide
		+ SettingsDialog: advanced tab
		+ Bubble tool: 
			+ Hide menu, but ensure it is still reachable
			+ Do inverse visits at World anyway
		+ Log marker w/timestamp
			+ -------------------- 519558699552151
		+ Complete "How to Build a Ship" guide
		+ Move all guides to own folder "Docs"
			+ Also material_template's
		+ Air bubble randomization
		+ WiX Installer
			+ Rearc:
				+ Heat only used for:
					+ Data - ComponentGroup "Data", own wxs
					+ Ships - ComponentGroup "Ships", own wxs
				+ Then manual ComponentGroups:
					+ Binaries
						+ w/proper platform
						+ w/shortcuts
					+ license, readme, changes

			+ No upgrade/downgrade
				+ Version in product name
				+ New product guid each time
					+ Just use new variable
			+ Program files
			+ Desktop shortcut
				+ No working directory
				+ Check icon
			+ Start menu shortcut
				+ Check icon
			+ UI
				+ Initial screen
				+ Progress
				+ Final confirmation
				+ Canceled
				+ Already installed
			+ Icon of add/remove programs
			+ Version main binary:
				+ CMake: only include resources if MSVC
				+ Use version defines from Version.h
			+ Test repair
			+ Remove whole folder on uninstall, even with users' files
				+ https://helgeklein.com/blog/2014/09/real-world-example-wix-msi-application-installer/		
		+ Installer: add location picker
	+ 1.9.0
		+ Ship file dialog (*)
		+ Fix metres bug
			+ ShipPreview must carry original size, before resize
		+ Add new ships
		+ Installer does not install guides
		+ Change version
		+ ConnectedSprings/OtherEndpoint Optimization (*)
		+ Create "z_buffer" branch
		+ Zbuffer (*)
		+ See if can avoid freezing (so, deleting) springs to which we have bombs attached
			+ Don't destroy spring if it has a bomb attached, at:
				+ StressedSprings break 
			+ Test L'n'F':
				+ 3 Bombs
				+ Anti-Matter bomb (should fall at some point)
		+ ShipLoadDialog: make sure default Ships directory is always in recent dirs, first
			+ Test w/empty preferences
			+ Also add Home button
		+ Fix bug with cross-of-light spawning underwater		
		+ Fix sailing ship - cut sail in texture (but not in psd)
		+ Fix Titanic's jagged sides
		+ Tooltips (*)
		+ Update changes.txt with tooltips and z-buffer
		+ Fix SettingsDialog/RecentDirs bug: when new dir loaded, it doesn't appear in combo
		+ Make flood tool adjustable
			+ Two settings - radius and quantity of water
			+ Make sure ultra-violent mode applies to both
			+ SettingsDialog
				+ Use same sliders as DestroyRadius
			+ Test mins and maxs
		+ Make ropes less crazy when they get wet
			+ Test: base tall, slice rightmost tip
			+ Lower water intake adjust seems to help: add per-material
				+ StructuralMaterial: WaterIntake: 0.1 for Rope, default 1.0
					+ Also to guide; dimensionless
				+ Point buffer
				+ Use 
			+ Find good value:
				+ 0.05
			+ Perf:
				+ Pre: 29.1/29.2
				+ Post: 29.3/29.3
		+ Add more cloth colors
			+ Redo structural palette afterwards
		+ New render setting: Ocean Render Mode {Texture, Flat, Depth}
			+ One vertex attribute structure to rule them all 
				+ Texture
				+ Flat
				+ Depth
					+ restWaterHeight is sea depth, no need for: RenderContext need to be told of changing sea depth by GameController
					+ Rename as seaDepth
			+ 3 shaders
			+ VisibleWorld bounding box in viewmodel
				+ Test CrossOfLight
			+ SettingsDialog:
				+ RenderMode
				+ 3 colors
			+ Test all 3 with:
				+ Ambient light intensity
				+ Ocean transparency
			+ Find good default colors:
				+ Depth
				+ Flat
		+ New render setting: Ocean Floor Render Mode {Texture, Flat}
			+ One vertex attribute structure to rule them all 
				+ Texture
				+ Flat
			+ 2 shaders
			+ SettingsDialog:
				+ RenderMode
				+ 1 color
			+ Test all 2 with:
				+ Ambient light intensity
			+ Find good default flat color
		+ Initial help window (HTML) @ Startup
			+ UserPreferences tag to suppress
	+ 1.9.1:
		+ Fixed crash when attemping to load a ship from a directory containing an empty ship
		+ Fixed crash with air bubbles tool
		+ Spring Damp setting
			+ Test mass changes (now that coeffs are recalc'd on mass change)
				+ Bomb attaches
			+ SettingsDialog: advanced
			+ Play to see if can find value
			+ Try dividing by dtSquared
		+ Fix V offset of AM bomb cursor
		+ Slice-while-paused bug
	+ 1.10.0
		+ See if lights can make texture colors come out at night, rather than just yellow-izing it
			+ ShipTrianglesTexture shader: use local light as "additive" to ambient light (to draw colors)
			+ Split Points:: colorBuffer upload to own func
				+ RenderContext: range-based
			+ Remove logs and shader TODOs
			+ Check intensity at distance==0
			+ Change luminance to 1 rather than 2
				+ See first what difference it makes
				+ Change in materials.json
				+ Enforce in electrical material
				+ Verify fixes issue
				+ Constrain luminiscence adjust to max 1
					+ Or change how to apply adjustment
					+ Change tooltip and minimum
			+ If it works, also these shaders:
				+ TrianglesColor
				+ PointsColor
				+ Ropes
				+ SpringsColor
				+ SpringsTexture
			+ See if passing vec instead of floats among shaders helps with perf
		+ EventTickerPanel:
			+ Fix name of AM bomb @ placed (and @ al?)
		+ Bounded World
			+ GameParameters: MaxWorldWidth, Height
				+ Remove MaxZoom, MinZoom
				+ Use very small world for now
			+ Constrain view changes:
				+ ViewModel:
					+ float ClampXYZ() -> clamped value
					+ CanvasSize changes: make sure the largest visible world dimension stays the same
						+ i.e., adjust zoom so that the new visible world dimensions are contained within the old one
				+ Use at GameController:
					+ Zoom updates
						+ Get back value
					+ Camera updates
						+ Get back value
					+ CanvasSize update: pickup changes and reset smoothing
				+ Test
			+ Constrain physics:
				+ Ship::Update: at end of mech physics (after last integrate): 
					+ Destroy points (also with sounds, it's OK) that are outside of bounding box
					+ No destroy points, just do simple bounce w/bounded velocity
			+ Verify AM bomb issue is gone
			+ Test in Debug
			+ Make larger bounding world
				+ W: 10000
				+ H: MaxSeaDepth * 4
				+ w/static_assert for ocean depth
			+ Figure out where it is that the submarine disappears
			+ Fix water drag 
				+ Find coefficient for linear drag in "slow" range
				+ When done: see if bounds of water drag adjustment are still good
					+ Test at new max (1K) - do ship pieces go to a standstill?
			+ Verify AM bomb issue is gone
			+ Get current FPS
			+ Changes.txt		
			+ Merge to master			
		+ See move tool changing center
			+ Is it because of missing last step?
				+ Should finalize only after last step, making sure to clamp elapsed to Lag first
		+ Create dump upon crash
			+ https://stackoverflow.com/questions/9020353/create-a-dump-file-for-an-application-whenever-it-crashes
			+ In app folder, via StandardSystemPaths
				+ Under \CrashDumps
			+ Try with empty png and corrupted png
		+ VAO (*)
		+ Misc OpenGL Optimizations (*)
		+ Secondary PlaneIDAsFloat buffer
			+ We only pay the price sparingly, but reap the benefits at each frame
			+ Code
		+ Vertex buffer optimizations (*)
		+ Update FPS & perf analysis
		+ Water Contrast @ 0.875?
		+ UIPreferences		
		+ Decay (rust) (*)
		+ Ship descriptions (*)
		+ ShipRenderContext: make water color depend on ocean render mode color
			+ Get FPS before
			+ Water color in shader has to become parameter
			+ OceanRenderMode:
				+ Texture: waterColor=<constant matching now>
				+ Flat: waterColor=<that flat color>
				+ Gradient: waterColor=<mid color>
			+ Test x 3
			+ Get FPS after
		+ Ships
		+ Less stress sounds: use mIsStressed buffer, w/high and low watermarks
			+ Get FPS before
			+ Do
			+ Test
			+ See if can remove "negligible" check now
		+ Fix air bubble progress issue
			+ Confirm repro test
			+ Get FPS before at bubble tool:
			+ Do
			+ Test
		+ Send for testing
		+ New ships
		+ Check "Smash" bug
		+ Add other testers to About box
		+ Finalize descriptions
		+ Release
	+ 1.11.0:
		+ Orphaned points
		+ Increase # of ephemeral particles
			+ And thus lower water intake threshold for air bubbles
		+ Sea and Ocean Floor rearc(*)
		+ Change cover art to Logo2
			+ About box image
				+ And remove "Cover art" credit altogether
			+ Installer
		+ Try to build with Runtime Type Information disabled
		+ Add world end markers
		+ Repair tool
		+ Fix Linux build break
			+ Do specialization outside of class
			+ Set /permissive- for all projects
		+ Take Mathias' pull request
		+ Fix github's clouds bug
		+ Un-sinking (*)
		+ Floatsam: see if using (waterY + 0.1) at UpdateWaterIntake helps
		+ Are we really forced to set point colors to structural colors?
			+ Can we always use the (sampled) texture colors?
				+ After all, texture layer is now mandatory!
			+ Test look'n'feel
		+ Also dry points should rot (*)
		+ Pick tool (*)
		+ Add new materials: 
			+ Rubber
				+ SoundType=Rubber
				+ Hull, Non-hull
				+ 2x (hard and soft)
					+ 3 colors each
				+ Make repair sound (copy from one of the break)
				+ Make separate balls
			+ Test weight of new non-hull rubber
				+ ...and make sure hull rubber sinks
			+ Fiberglass
				+ SoundType=Plastic
				+ Hull, Non-Hull
					+ 3 colors each
				+ Make ball at "New Materials Balls"
				+ Make repair sound (copy from one of the break)
			+ Plastic (ABS)
				+ SoundType=Plastic
				+ Hull, non Hull 
					+ 3 colors each - LEGO colors
				+ Make ball at "New Materials Balls"
			+ Redo template
			+ Send to Michael
			+ Add to changes.txt
		+ Probabilistic Destroy
			+ Probability is zero at radius
			+ Cleanup:
				+ Also do fraction at other continuous tools
				+ Remove 1.0 at ModulateCursor
		+ Try to show tip window after first Render
			+ Undo hacky test changes
			+ mHasStartupTipBeenChecked = false
			+ OnGameStep:
				+ at beginning: only schedule timer if mHasStartupTipBeenChecked
				+ at end: 
					+ if !mHasStartupTipBeenChecked:
						+ Show startup tip dialog
						+ schedule timer
						+ mHasStartupTipBeenChecked = true
			+ Check refresh when moving tip window
		+ Dry points when repaired
			+ Halve moved points' water 
		+ Do perf analysis for many air bubbles
			+ ShipRenderContext::UploadGenericTexture: vector::emplace - 3.5
			+ ShipRenderContext::RenderGenericTextures: memcpy - 1.0
			+ Points::UpdateEphemeralParticles: sin - 1.0
			+ Try dedicated upload
				+ Take FPS pre: 20, UR=113-132 @ 4K GenTex's, 62/300 planes
				+ Do
					+ Use same VBO, two draw calls
						+ VBO first used for AirBubbles, size=MaxEphParticles
						+ Then re-allocated for GenTex's
							+ Allocate only if necessary, i.e. if new size > last (MaxEphParticles)
				+ Take FPS after: 22.3, UR=133
			+ changes.txt
			+ ParameterSmoothing: make it with sin (btwn pi/4 and pi/2)
		+ Shallow Water Equations (*)
		+ Try to change speed of particles at repair
			+ See big notebook
		+ See problem with too many bubbles
			+ See if water is constant after hole plugged
				+ Custom probe w/total water in ship
				+ Remove probe afterwards
			+ See if water is turbulent
				+ Temporarily change shader to draw pressure waves
			+ See if true: realistic sinking of ship is 3 water intake and 0.25 water diffusion speed
		+ Use precalc'd sin for bubble vortex 
			+ Pre FPS: 22.5, 125
			+ Make static precalc'd sin (lo-res: 512)
			+ Post FPS: 23.4, 136
			+ Do perf analysis
		+ Send for testing
		+ Do test with "the possible ships" broken
		+ Double-check latest rotting speed
		+ See frequency of wind ripples
		+ Font 2
		+ Perf:
			+ ExtractShaderParameters: regex::search
			+ Utils::ParseJSONFile::RemoveJSonComments
		+ Installer:
			+ Add repair when already installed
				+ Tests:
					+ Install codepath
						+ Verify registry keys
						+ Verify control panel
						+ Verify both shortcuts
						+ See why game does not start visible
					+ Repair codepath 
						+ Verify delete bin file re-added
						+ Verify desktop shortcut re-added
					+ Uninstall codepath
						+ Verify no registry keys left
						+ Verify orig files gone
						+ Verify added (ship) files gone
						+ Verify control panel gone
						+ Verify shortcuts gone
					+ Tooltips at install
					+ Repair and uninstall from control panel  
						+ Repair (w/real deleted)
						+ Uninstall (w/extra ship and delete verification)
				+ Make repair and remove buttons
			+ See if installer for current user removes need for admin consent
				+ Check app folder
				+ ShipLoadDialog does not show AppFolder
			+ Uninstall older versions except one
			+ Info URL
			+ Send installer for testing
		+ Change .shp names to match filenames
			+ Use python script to detect
		+ Bugs:
			+ Goliath crashing
			+ Mike's weird waves
			+ SamminAter unsupported OpenGL ext => crash
				+ Test error in Debug mode
				+ Give him a relwithdebinfo
				+ Check if dir is null
		+ Michael Bozarth's ships
			+ Check Carpathia differences
			+ Check OpenGL error with 3 queen mary's and titanic interior
				+ Check first why it crashes afterwards
				+ Then, do explicit texture size check
			+ Fixes to do:
				+ 1: Titanic in a bottle (leak): his don't leak - I fix it
					+ In final, verify
				+ 2: Ed Fitzgerald (ropes): I do it
					+ In final, verify
				+ 3: Cargo ship 2 (too heavy): asked
				+ 4: Lego Titanic (offset): done
				+ 5: RMS Britannic (ropes): I do it
					+ In final, verify
				+ 6: Queen Mary (ropes): I do it		
					+ Retaken
				+ 7: Take electrical of RMS Titanic with Lights				
					+ Can't see the difference; asked
					+ No changes
				+ 8a: 3 Queen Mary 2's (large texture): done
					+ Retaken
				+ 8b: Titanic Interior (large texture): done
					+ Retaken
			+ Run verifier on all ships
		+ Do movie
			+ Repair 
				+ With move and rotate
			+ Rubber ball
		+ Release
	+ 1.11.1:
		+ Fix crash
			+ Remove TODO logs and checks (discard all changes)
			+ Fix bug
			+ Test
		+ Change version
		+ Fix HMT Olympic b
		+ Update changelist
		+ Check if other bugs
		+ Release
			+ Git
			+ GameJolt
		+ Merge into 1.12
	+ 1.12.0:
		+ Fix latency of move tool
		+ Do perf analysis
			+ Usual sample-based one
		+ SFML fixing:
			+ Re-run FS cmake
			+ Redo FS release build 
				+ Verify static CRT in output
			+ Redo FS install build 
				+ Verify static CRT in output
				+ Verify guides in output
		+ Automatic updates checker via file placed on floatingsandbox.com
			+ UIPreferences::CheckForUpdatesAtStartup
			+ class UpdateChecker:
				+ Wraps separate thread and conveys result via UpdateCheckOutcome
				+ Getter for UpdateCheckOutcome:
					+ Returns null if not done yet
					+ Returns UpdateCheckOutcome when done
				+ Uses SFML::Network::Http
			+ At startup:
				+ MainFrame starts UpdateChecker at end of PostInitialize, and then polls it as long
				  as it's not null
				+ If poll OK && new version, displays popup, then nullifies it
					+ Uses NewVersionDisplayDialog
				+ Redo: kick-off is by timer after 10 secs, rather than at PostInitialize() - everything else stays
			+ Help->Check for Updates
				+ MainFrame: menu item
				+ CheckForUpdatesDialog (Modal Dialog)
				+ cctor starts UpdateChecker 
				+ Timer does progress (calling wxGauge::Pulse)
				+ On poll OK, displays with NewVersionDisplayDialog
			+ NewVersionDisplayDialog:
				+ If ccted with "atStartup", displays checkbox for turning off check on startup
			+ Preferences window:
				+ Check for updates at startup
					+ Toggling checkbox resets version blacklist
			+ Test:
				+ Does not notify for old version (Startup, Check)
				+ Notifies for new version (Startup, Check)
				+ Everything stays the same at next check (Startup, Check)
				+ Blacklist checkbox clicked and re-clicked does nothing (Startup)
				+ Blacklists version for next check (after checkbox) (Startup, Check)
				+ Does not check at next check (after checkbox) (Startup)
				+ Preferences
					+ Blacklist reset
				+ From http
			+ Cleanup:
				+ "Click here to download ...":
					+ Button
					+ Change text
				+ Cleanup changes.txt
				+ Trim changes.txt at www
				+ Timer: 10 sec
		+ Make sure sfml network is crt statically linked
		+ Bugs:
			+ Wavemaker sound when paused does not pause
			+ Emplace force fields at interactions
			+ Move tool now doesn't work when paused
				+ See why
				+ Fix
		+ Multiple textures for:
			+ Land
				+ Each has entry in texture DB
					+ Some new ones have 512 - decide one by one
				+ RenderContext::GetAvailableLandTextures()
				+ SettingsDialog: drop-down
				+ RenderContext::SetOceanFloorTexture(size_t)
				+ Test ShipPreviewControl (for zero-sized bitmap)
				+ Rename TextureRenderManager to UploadedTextureManager
			+ Ocean
			+ Changes.txt
		+ Shaders:
			+ Land texture:
				+ Texture compression on edge
					+ Try (4*x)^(0.2) / (3 * ((4*x)^2+1)) + x
				+ Add non-linear (same non-linearity as ocean) darkening (lightest at ocean surface)
			+ Ocean gradient: make non-linear
				+ Cleanup shader afterwards
			+ Ocean texture:
				+ texture compression on edge			
				+ add non-linear (same non-linearity) darkening
		+ Optimize GameOpenGL::UploadMipmappedTexture: alloc write buffer once and swap pointers
		+ Fix bug at bump-map interpolation at ocean floor: need to calc fractional part
		+ Settings dialog: 
			+ Merge Mechanics and Fluids and World into "Generic"
				+ Mechanics box
					+ Add decay
				+ Fluids box
					+ Move WaterLevelOfDetail to Rendering, next to WaterContrast
				+ Lights box
			+ Do spacers at Ocean+Sky and Wind+Waves as Mechanics and Rendering
			+ Interactions: add boxes (and make like Mechanics):
				+ Interactions
				+ Side Effects
				+ Make tools two rows and move side-effect to left
		+ Make slider for air bubble density
			+ SettingDialog: enable/disable based off checkbox
				+ Move checkbox
			+ Max=128
				+ Ensure cur value fits slider
			+ Fix issue with randomization of density
				+ Try with redoing randomization of all leaking points at each param change
		+ Ocean rendering: replace stencil with first rendering w/zero transparency
			+ Remove MatteOcean shader, now that it's not needed anymore
			+ Do pass on all ocean textures doing exactly what we did before (cornflower blending)
			+ Redo flat and gradient ocean colors

		+ Waves need to be further limited
			+ Make repro: tsunami on manually-created high wave field
			+ Tsunami and rogue wave: target H is absolute, not based on current H
			+ If ok:
				+ Update changes.txt
		+ Merge to master			 
		+ Send to testers
		+ Move tool: make sling easier
			+ 1) Merge Move tools
				+ Base templated class
				+ Derived only has virtual's for GameController calls
			+ 2) Improve
		+ Multi-music
		+ Sea and land shaders: use smoothstep's instead of complex stuff
			+ float increment = -10.0 * (1.0 - smoothstep(0.0, TODO.0, textureCoord.z))
		+ Repair tool improvement:
			+ RepairTool passes RepairSessionId, RepairSessionStepId
			+ Points has buffer of struct RepairSmoothing{RepairSessionId currentSessionId, RepairSessionStepId currentSessionStepId, float smoothing}
			+ Repair interaction when engaging "other endpoint":
				+ Zero's smoothing iff currentSessionId != this session ID
					+ And sets currentSessionId = this session ID
				+ Advances smoothing (smoothing += (1-smoothing)*alpha) iff currentSessionStepId != this session step ID
					+ And sets currentSessionStepId = this session step ID
			+ Test and fine-tune alpha
			+ Remove logging
			+ Fine-tune inertial velocity exponent
			+ See why points fly at weird angles
				+ See if due to (wrong) intertial: does it happen with no inertial? NO.
			+ See Moleskine for Attractor vs Attracted
			+ Deal with same conn comp ID
			+ Undo decay (halve it)
			+ See missing springs
			+ Play with tolerance
			+ See if conn comp logic:
				+ Is broken (think): NO
				+ Is useful: commented out for the time being (for AwesomeYorkie)
			+ Get AwesomeYorkie's second feedback
			+ Try with smoothing done only at attractors via step ID
			+ Ropes strength amplifier/reducer
			+ Try to put back attractor/attractee exclusion 
			+ Radius = 2.0
			+ Alpha = 0.0025f
			+ Find multiplier (play w/strength slider for the time being, make high max (for now))
			+ Commit
			+ See if can use the duration of the role
				+ A point shouldn't take the role of attracted if it was attractor in the immediately-previous step
				+ A point shouldn't take the role of attractor if it was attracted in the immediately-previous step
			+ See if may have slower startup of force
				+ Replace whole smoothing with:
					+ Attracted force is <MaxForce>*smoothstep(0.0f, 10*60, # of consecutive session steps as attracted)
						+ Need to track # of consecutive steps as attracted in this session
			+ Test repair strength adjustment as "repair speed adjustment"
				+ If ok, rename @ code & settings dialog
			+ Then see if can put radius back to something higher
			+ See if rope kindness is still granted
			+ Cleanup logs and code for Correct/Wrong counts
			+ Cleanup TODO
		+ Fix exponential slider core for negative edges
		+ Put back links
		+ Fire Extinguisher tool
			+ Action
				+ Cool, with heat subtraction
			+ Shader
				+ Radial noise + rotation
				+ Somewhat transparent, so that flames show through
				+ Full radius 
			+ Sound
				+ Volume
			+ Cursor
				+ HotSpot
		+ Add slider for repair tool radius
		+ Add slider for flamethrower tool radius
		+ Rotting:
			+ Fix bug: "Idk if this is a bug or not but the tiny particles that appear after something is destroyed start flickering like 
			  christmas lights with rot at 1000 when uderwater"
			     + Yes: W=112.826 T=288.003 Decay=3.93467e+06
			+ Bump up rot speed for dry stuff, takes 98 minutes now
				+ They all agree: a ship should rot in 30 minutes on the surface, and in 15 minutes when flooded
			+ Tests:
				+ Surface rots zero, submerged a bit more, flooded more, leaking a lot
				+ Christmas light bug: with acceler8r at 1000.0 when uderwater
				+ Stainless steel does not rot when acceler8r at 1000.0
				+ 15mins (@50fps) for flooded when acceler8r at 1.0
				+ 30mins (@50fps) for exposed when acceler8r at 1.0
				+ Doesn't rot when acceler8r at 0.0
		+ Thanos' Snap
			+ Tool managed by GameController
				+ Dedicated state machine (mThanosSnapStateMachine) stored in queue
					+ Additive, up to N (8), circular
					+ Move state machines to separate cpp: GameController_StateMachines.cpp
					+ At beginning (first insert): 
						+ Fire "StartSilence" event
							+ SoundController::OnSilenceStarted: stop sinking music
						+ Call Wind::SetSilence(float between 0.0 and 1.0)
							+ Wind stores it, and uses it at Update()
							+ Wind state machine progresses, but final result is multiplied by silence
								+ And rely on moving avg to smooth the step
					+ Throughout: call World::ApplyThanosSnap(centerPos, innerRadius, outerRadius) X 2
						+ Called for slices, advancing from mouse position at moment of application
						+ Ship::ApplyThanosSnap(centerPos, innerRadius, outerRadius)
							+ Only does between two outermost edges, so to catch moving things
							+ Deletes springs (and consequently triangles) (w/no noise)
							+ Imparts velocity on particles
						+ OceanSurface::ApplyThanosSnap(centerPos, innerRadius, outerRadius)
							+ Flattens surface that falls in crown to ~-1.0
					+ At end (last removal):
						+ Fire "LiftSilence" event
							+ SoundController: niks
						+ Call Wind::SetSilence(0.0)

			+ Cursors (up and down)
			+ Snap sound
		+ Heat and combustion
		+ ShipLoadDialog: search bar
		+ Check bugs:
			+ Scrolling past world end/black triangle
			+ Mike's rotting when water is inside: he's right			
		+ Add new materials: black cloth, black wood
		+ Take Mike's music
			+ Test flac versions
			+ About box: add Stuart's Piano World, https://stuartspianoworld.com/
	+ 1.13.0
		+ Refresh current perf
		+ Add those 2 Lava textures
			+ Need to remove blue overlay first, apply to textures directly making a second "Caraibic" version of them
				+ Color: 87cefa rgbColor(0x87, 0xce, 0xfa), // cornflower blue
				+ Transparency: 0.8125
				+ Make "Caraibic" version the default
			+ Add two lava
		+ Version overhaul
			! Goal: "beta" shows up in file details (product version, etc.) and in About Box
			+ Version class:
				+ No build number but beta instead, with beta=X always < beta=0
				+ Unit tests
			+ RC file
				+ Test with both FileVersion,ProductVersion having the same (w/"beta")
					+ Beta 1
					+ Beta 0
			+ Revert all changes:
				! We are happy to release 1.13.0.592
				+ No beta's needed, revert to 4 components, just rename them (patch, build)
		+ Windows installer: rethink strategy, go for upgrades
			+ Make UpgradeCode fixed value, that is, the one from 1.12.0
			+ ProductCode changes for each release
				+ It's the only one that changes
			+ Move back component GUIDs from vars to hardcoded attributes, using same as in 1.12.0
			+ Change HeatPerUser.xslt: "todo" comments for 1.12 fixed
				! Ideal would be to have version-agnostic reg key as keypath (a new one), but then 1.12.0 components would not seem
				  to be installed
			+ Do <MajorUpgrade> w/AllowSameVersionUpgrades=Yes
				+ See https://support.firegiant.com/hc/en-us/articles/230912187-Implement-major-upgrade-
			+ Try changing keypaths (folder & reg key)
				+ Rethink their values					
			+ Tests:
				! To verify:
					! Final result
					! Text of dialogs
				+ Clean install
				+ Upgrade
				+ Maintenance->Repair
				+ Maintenance->Uninstall
				+ Upgrade when Ships folder contains additional ship files
			+ Add to changes.txt
		+ ShipLoadDialog: Crack ShowModal() puzzle
			+ ShowModal()
			+ Try:
				+ PollQueue: consume 10 events at a time
				+ Pre-created ShipLoadDialog member
			+ Cleanup:
				+ GameController::Pause:
					+ Move GameWallClock pause here from MainFrame
				+ Make MainFrame::SetPaused(bool) with content of pause menu handler
					+ MainFrame has "stack" (counter)
					+ Invoked by:
						+ Pause menu handler
						+ ShipLoad cycle
				+ Remove "todo" Log's at ShipLoadDialog
		+ Run with AppVerifier to detect cause of crash at reload
		+ Make sure we don't copy Temperature buffer twice
			+ Make Buffer::swap(Buffer<T> & other)
			+ Pre: 28.1/28.8
			+ One copy only
			+ Post: 28.5/28.7
			+ Do also at Water
			+ Post: 28.9/29.1
		+ ShipLoadDialog:
			! Do own paint, no controls
			+ Replace paint with overriding OnDraw(), // https://docs.wxwidgets.org/3.0/classwx_scrolled.html
			  which provides scrolled coords
				+ But we have to deal with mouse events anyway
			+ See if we need the mem DC and/or double-buffering 
				+ Try with double-buffering off
			+ Mouse events
				+ Calc tile based off mouse coords, panel position, and vscroll
				+ Single-click
				+ Double-click
			+ Try making panel a wxWindow instead (as it doesn't have child controls)
			+ Nuke old code and rename ShipPreviewPanel 
			+ Fix empty bitmap/exception
			+ Search:
				+ Test adding author
				+ Button for "next"
					+ Do icon
					+ Functionality				
					+ Do enable state machine
			+ Remove TODO Log's
			+ Fix SS Arizona
			+ Test:
				+ Dir changes
					+ With tree
					+ With dropdown
					+ With Home
			+ Merge into 1.13
			+ Update changes.txt
		+ Lava textures
			+ Update changes.txt
		+ Benchmark vectorized spring lengths (see Moleskine)
			+ Move VectorNormalization_Vectorized_AndLength_Reciprocal_LibSimDpp to Algorithms
		+ Cache layout optimization for points and springs (*)
		+ Slider text box editable (*)
		+ Adjustable zoom and pan increments (*)
		+ Sparkles with shader
			+ Impl:
				+ ShipRenderContext
					+ VBO, VAO
					+ Shader
						+ Need sparkleSpace position
						+ Complete
							+ See perf (@ShaderToy) w/length instead of length2
					+ UploadSparkle: make vertices
						+ Quad size is 4x4
				+ Ship
					+ UploadStart/End
					+ Upload:
						+ Normalize velocity to (-1,-1) -> (1,1) and adjust sign
					+ Expire sparkle when underwater
					+ Simplify sparkle state machine, if there's stuff we don't need anymore
				+ Watch videos and adjust butterfly
					+ Use full quad
					+ Shader
					+ Butterfly: gaussian around direction opposite to movement
					+ Faster max (and min) speed: * 1.5
			+ Cleanup:
				+ Nuke sparkle texture(s)
				+ Shader:
					+ Get rid of velocityVectorAdj
				+ GameRandomEngine renames
			+ Try:
				+ More thick
		+ Lights perf improvement (*)	
		+ Settings Manager (*)
		+ Fix guy's name in Aurora:
			+ Need:
				+ Name: HummeL
				+ URL: https://www.youtube.com/c/HummeL_Prog
			+ Ship
			+ AboutBox
		+ Print speed (in m/s) after throwing objects with both move tools
		+ Move status text toggles to UIPreferences, so that they're save-able
			+ Leave menu entries, they now talk to UIPreferencesManager
				+ Refresh status after each change
		+ Music from Officer TimCan:
			+ Convert SleepingSun full and see if may fit in FS; if not, take the short version
			+ Add the three songs
			+ Add to about box
		+ Storm (*)
		+ Ocean darkening:
			+ See if may do exponential
			+ If so, fix marianas trench
		+ Ocean detail adjust:
			+ See if at zero there's no tool; if so: make minimum > 0
		+ Need to align Points' first ShipElementCount elements
			+ Check all references to mShipPointsCounts et al
			+ Run in debug
		+ Nuke unused water bubble texture
		+ Water bubbles: try with allowing CumulatedIntakenWater to go negative: NO CHANGE
		+ Text when repair completed: "Completely Repaired!"
			+ At iteration where at least one spring or one triangle has been repaired, and no more fixable springs
			  exists and no more destroyed triangles exist
				+ Maintain flags during visit
				+ Maintain per-ship counts of broken springs and triangles, updated at:
					+ SpringDestroyHandler and TriangleDestroyHandler
					+ Repair handlers		
		+ SpinCtrl at SliderControl?
			+ Range is slider's range, and SpinCtrl is coupled with slider
		+ Send for testing
		+ Bump up version
		+ Slider's edit box: enforce setting on focus away
		+ the [PAUSE] on the top left corner fails to show up; shows up for 1 second after unpaused, and then disappears after that second has passed
		+ loading up "last-modified settings," or any settings for that matter, remove the pin's ability to stay in one place, and the pin just falls with the object/vehicle/ship, not keeping anything in place
			+ Definitely repro's with Simulation Quality
			+ CalculateIntegrationFactorTimeCoefficient needs to take into account mIsPinned
				+ ...which becomes float
		+ "here is a bug that I found to where the game crashes. You zoom out, click adjust terrain, remove all terrain, then reset the map by hitting ctrl+r, the game freezes for a second and the crashes."
		+ "I feel that the waves on the 'storm' should be a bit smaller"
			X The titanic has a structural problem, In a storm the stern keeps breaking off	
		+ Improve app icon 
			+ First icon (AAA) has white bg
				+ Verify it's the app (exe) icon
			+ Second (AAB) is current, used by SetIcon
		+ Try Dario's cable suggestions
		+ Background Music
			+ Long Note Four by Kevin MacLeod: https://www.youtube.com/watch?v=mzmfxEcCeic
			+ Needs to fade out while sinking music is fading-in, and needs to fade-in once sinking music
			  is fading out
				+ All done by MusicController, as long as mPlayBackgroundMusic is on
				+ Default: off
			+ Add him to credits
			+ UIPreferencesManager: 
				+ Global mute
				+ Game music: volume, playSinkingMusic
				+ Background music: volume, playBackgroundMusic
				+ Center sliders and their checkboxes
			+ PreferencesDialog:
				+ Same as UIPreferencesManager
			+ SettingsDialog: remove music volume, music mute, playSinkingMusic
				+ Also from SettingsManager
				+ Merge Sounds w/Advanced: "Sounds and Advanced"
					+ And now add static boxes
			+ Global mute:
				+ Remove from both SoundController and MusicController
				+ AudioController:
					+ static void AudioController::SetGlobalMute(bool)
					+ static bool AudioController::GetGlobalMute()
						+ check whether sf::Listener volume is > 0.0f
				+ MainFrame
			+ Test playlist
			+ Remove all TODOTEST's
			+ Update changes.txt, also w/new location of global sound setting
			+ Make all music OGG/Vorbis
			+ Run in Debug
		+ Send for testing
		+ Bump up version: 1.13.0.7
		+ See more gradual wave height
		+ Clickable links in About box
		+ Installer:
			+ New icon for installer itself
		+ Video (see Marketing above)
		+ Release


