=================================================
Current perf:
=================================================
- fps: 30.5/30.5/30.7/30.85
=================================================
Before decay:
- fps: 30.7/30.7/30.8/30.9/32.0
- U/R: 193.x%
- RunGameIteration: TODO:86.62% (initialization time)
- World::Update: 60.25%
		- UpdateMechanicalDynamics: 49.32%
			- UpdateSpringForces: 37.99%
			- UpdatePointForces: 5.51%
			- HandleCollisionsWithSeafFloor: 3.38%
			- IntegrateAndResetPointForces: 2.30%
			- UpdateTotalMasses: 0.13%
		- UpdateWaterDynamics: 6.72%
			- UpdateWaterVelocities: 6.57%
			- UpdateWaterInflow: 0.08%
		- DiffuseLight: 2.94%
			- FastPow2: 1.44%
- World::Render: 22.54%
	- Ship::Render: 19.36%
	- RenderSkyEnd: 2.33%
	- RenderOcean: 0.70%
=================================================
Before Vertex Attribute Optimization:
- fps: 28.2/28.4 (miracle: 28.7/29.0/29.1)
- World::Update: 54.66%
		- UpdateMechanicalDynamics: 44.64%
			- UpdateSpringForces: 34.70%
			- UpdatePointForces: 4.88%
			- HandleCollisionsWithSeafFloor: 2.89%
			- IntegrateAndResetPointForces: 1.99%
			- UpdateTotalMasses: 0.15%
		- UpdateWaterDynamics: 6.29%
		- DiffuseLight: 2.62%
- World::Render: 28.24%
	- Ship::Render: 25.11%
	- RenderSkyEnd: 2.23%
	- RenderOcean: 0.77%
=================================================
Before VAO:
- fps: 28.1/28.3
=================================================
Before bound world and point light<->ambient light additiveness:
- fps: 29.0/29.2/29.4
=================================================
Before Z buffer:
- fps: 30.2/30.6/31.2
=================================================
Before wind:
- fps: 30.8/31.0/31.3
=================================================
Before exp optimization:
- fps: 30.8/31.0/31.3
- World::Update: 58.48%
		- UpdateMechanicalDynamics: 48.44%
			- UpdateSpringForces: 38.25%
			- UpdatePointForces: 4.47%
			- HandleCollisionsWithSeafFloor: 3.43%
			- IntegrateAndResetPointForces: 2.10%
			- UpdateTotalMasses: 0.19%
		- UpdateWaterDynamics: 7.79%
			- UpdateWaterVelocities: 7.64%
		- DiffuseLight: 1.31%
- World::Render: 28.15%
	- RenderContext::RenderCloudsEnd: 3.98%
=================================================
Before diffusion improvement:
- fps: 31.5/31.7
=================================================
Current perf (spring optimization + double spring iterations)
=================================================
- fps: 31.3 (Samsung: 20.3 (Krafting)) (Mattia's: 15.5 (Krafting))
- World::Update: 57.05%
	- Ship::Update: 56.89%
		- UpdateMechanicalDynamics: 47.56%
			- UpdateSpringForces: 37.08%
			- UpdatePointForces: 5.30%
			- HandleCollisionsWithSeafFloor: 2.92%
			- IntegrateAndResetPointForces: 2.26%
		- UpdateWaterDynamics: 7.83%
			- UpdateWaterVelocities: 7.72%
- World::Render: 28.15%
	- RenderContext::RenderCloudsEnd: 3.98%

=================================================
Past perf (ephemeral particles)
=================================================
- fps: 28.8/29.0
=================================================
1.7.0 perf from users
	- Titanic: 50
	- Titanic: 55
	- Titanic: 48.3

=================================================
1.6.0 perf
=================================================
- fps: 29.6 (Samsung: TBD:31.5 (Krafting)) (Mattia's: TBD:25.1 (Krafting))
- GameController::Update: 35.06%
	- Ship::Update: 34.33%
		- UpdateMechanicalDynamics: 25.70%
			- UpdateSpringForces: 18.80%
			- UpdatePointForces: 3.45%
			- HandleCollisionsWithSeafloor: 2.45%
			- IntegratePointForces: 1.00%
		- UpdateWaterDynamics: 7.83%
			- UpdateWaterVelocities: 7.73%
			- UpdateWaterInflow: 0.05%
		- UpdateStrains: 0.78%
	- DiffuseLight: 0.58%
	- WaterSurface::Update: 0.11%
- World::Render: 57.00%
	- ShipRenderContext::RenderEnd: 52.87%
	- RenderContext::RenderCloudsEnd: 1.49%
	- RenderContext::RenderStart: 0.50%
	- Ship::Render: 0.14%
		- UploadPoints: 0.12%
	- RenderContext::RenderWater: 0.05%
	- World::RenderClouds: 0.04%
		- fmodf: 0.02%
	- RenderContext::RenderLand: 0.01%
- RenderContext::RenderEnd: 0.35%
	- TextRenderContext::RenderEnd: 0.35%
- wxGLCanvas::SwapBuffers: 1.07%
=================================================
NoInline
- World::Render: 53.36%
	- ShipRenderContext::RenderEnd: 49.69%
		- ig4: 49.22%
		- RenderRopes: 0.43%
		- ...
	- RenderContext::RenderCloudsEnd: 1.37%
	- RenderContext::RenderStart: 0.46%
	- RenderContext::RenderWater: 0.04%
	- World::RenderClouds: 0.02%
		- fmodf: 0.01%
	- Ship::Render (with uploads): 0.15%
	- RenderContext::RenderLand: 0.01%
	- RenderContext::UploadLandAndWaterEnd: 0.04%
	- RenderContext::UploadLandAndWater: 0.03%
- RenderContext::RenderEnd: 0.30%
=================================================
Render:
	- No Ship::RenderEnd: 64fps
	- Only springs: 30fps
	- Only triangles: 42fps
=================================================
1.3.0 perf
=================================================
- fps: 27.3
- GameController::DoStep: 33.06%
	- Ship::Update: 32.07%
		- UpdateDynamics: 25.53%
			- UpdateSpringForces: 18.72%
			- UpdatePointForces: 3.55%
			- HandleCollisionsWithSeafloor: 2.27%
			- Integrate: 0.98%
		- GravitateWater: 4.60%
		- BalancePressure: 1.06%
		- UpdateStrains: 0.83%
		- LeakWater: 0.03%
	- DiffuseLight: 0.89%
	- WaterSurface::Update: 0.09%
		- sinf: 0.07%
- MainFrame::RenderGame: 60.47%
	- ShipRenderContext::Render: 53.52% (Incl) 0.00% (Excl)
		- ShipRenderContext::RenderSprings: 30.72%
		- ShipRenderContext::RenderTriangles: 22.29%
		- ShipRenderContext::RenderRopes: 0.45%
		- Points::Upload: 0.14%
	- RenderContext::RenderCloudsEnd: 2.87%

====================================================
====================================================
====================== Plan ========================
====================================================
====================================================

- Testers:
	- Maximord - "Maximord" (Parallels)
	- Pac0master - "<Same as now>" (Intel core i5-8600K, NVIDIA GeForce RTX 2070)
	- The_SamminAter - "<ask>" (Parallels)
	- DkuzTheFox: "Dkuz The Fox": (Intel core i7-5700HQ, Windows 10)

- Marketing:
	- GameJolt post w/screenshot with gradient, at night
	- Video of Titanic under Mariannes' Trench
		+ After water contrast

- Roadmap:
	= 1.10.0
		+ See if lights can make texture colors come out at night, rather than just yellow-izing it
			+ ShipTrianglesTexture shader: use local light as "additive" to ambient light (to draw colors)
			+ Split Points:: colorBuffer upload to own func
				+ RenderContext: range-based
			+ Remove logs and shader TODOs
			+ Check intensity at distance==0
			+ Change luminance to 1 rather than 2
				+ See first what difference it makes
				+ Change in materials.json
				+ Enforce in electrical material
				+ Verify fixes issue
				+ Constrain luminiscence adjust to max 1
					+ Or change how to apply adjustment
					+ Change tooltip and minimum
			+ If it works, also these shaders:
				+ TrianglesColor
				+ PointsColor
				+ Ropes
				+ SpringsColor
				+ SpringsTexture
			+ See if passing vec instead of floats among shaders helps with perf
		+ EventTickerPanel:
			+ Fix name of AM bomb @ placed (and @ al?)
		+ Bounded World
			+ GameParameters: MaxWorldWidth, Height
				+ Remove MaxZoom, MinZoom
				+ Use very small world for now
			+ Constrain view changes:
				+ ViewModel:
					+ float ClampXYZ() -> clamped value
					+ CanvasSize changes: make sure the largest visible world dimension stays the same
						+ i.e., adjust zoom so that the new visible world dimensions are contained within the old one
				+ Use at GameController:
					+ Zoom updates
						+ Get back value
					+ Camera updates
						+ Get back value
					+ CanvasSize update: pickup changes and reset smoothing
				+ Test
			+ Constrain physics:
				+ Ship::Update: at end of mech physics (after last integrate): 
					+ Destroy points (also with sounds, it's OK) that are outside of bounding box
					+ No destroy points, just do simple bounce w/bounded velocity
			+ Verify AM bomb issue is gone
			+ Test in Debug
			+ Make larger bounding world
				+ W: 10000
				+ H: MaxSeaDepth * 4
				+ w/static_assert for ocean depth
			+ Figure out where it is that the submarine disappears
			+ Fix water drag 
				+ Find coefficient for linear drag in "slow" range
				+ When done: see if bounds of water drag adjustment are still good
					+ Test at new max (1K) - do ship pieces go to a standstill?
			+ Verify AM bomb issue is gone
			+ Get current FPS
			+ Changes.txt		
			+ Merge to master			
		+ See move tool changing center
			+ Is it because of missing last step?
				+ Should finalize only after last step, making sure to clamp elapsed to Lag first
		+ Create dump upon crash
			+ https://stackoverflow.com/questions/9020353/create-a-dump-file-for-an-application-whenever-it-crashes
			+ In app folder, via StandardSystemPaths
				+ Under \CrashDumps
			+ Try with empty png and corrupted png
		+ VAO (*)
		+ Misc OpenGL Optimizations (*)
		+ Secondary PlaneIDAsFloat buffer
			+ We only pay the price sparingly, but reap the benefits at each frame
			+ Code
		+ Vertex buffer optimizations (*)
		+ Update FPS & perf analysis
		+ Water Contrast @ 0.875?
		+ UIPreferences		
		+ Decay (rust) (*)
		+ Ship descriptions (*)
		+ ShipRenderContext: make water color depend on ocean render mode color
			+ Get FPS before
			+ Water color in shader has to become parameter
			+ OceanRenderMode:
				+ Texture: waterColor=<constant matching now>
				+ Flat: waterColor=<that flat color>
				+ Gradient: waterColor=<mid color>
			+ Test x 3
			+ Get FPS after
		+ Ships
		+ Less stress sounds: use mIsStressed buffer, w/high and low watermarks
			+ Get FPS before
			+ Do
			+ Test
			+ See if can remove "negligible" check now
		+ Fix air bubble progress issue
			+ Confirm repro test
			+ Get FPS before at bubble tool:
			+ Do
			+ Test
		+ Send for testing
		+ New ships
		+ Check "Smash" bug
		+ Add other testers to About box
		+ Finalize descriptions
		- Release

	= 1.11.0:

		+ Orphaned points (*)
		+ Increase # of ephemeral particles
			+ And thus lower water intake threshold for air bubbles

		= Fix Linux build break
			+ Do specialization outside of class
			+ Set /permissive- for all projects

		= Change cover art to Logo2
			+ About box image
				+ And remove "Cover art" credit altogether
			- Installer

		- Try to build with Runtime Type Information disabled

		= Sea and Ocean Floor rearc(*)

		- Heat and combustion (*)

		- Instanced drawing for lights (*)

		- Pick tool (*)

		- Interior layer (*)

		- Electrical layer view (*)

		- Spring and NonSpring force separation optimization (*)

		- Batisphere with pumps and propulsion (*)
			- First need to add a new material property - "rust_susceptibility" - for tanks
				- Use at RotPoints()
				- Make "stainless" materials
			- Switches (*)
			- Flood doors (*)
			- Pumps (*)
			- Propulsion (*)
			- Batisphere ship

	- 1.12.0

		- Smoke (*)
		- Settings Manager (*)

		- Libsimdpp spring relaxation (*)
		- Frontier
		- Resource Packs (*)

- Ship making:
	# Credit names:
		# ShippyMcJerry: ShipBuilder1912 
		# Coolman115: CorbinPasta93
		# Ilovedumbphones: Dumbphones
		# SweetStrawberryBoy: TopHatLemons
	- New ships:
		- To adjust:
			- SS France (Awesomeyorkie):
				- Ropes
		- Asked:
			- Ed Fitzgerald (but needs to be fixed) (Kiko)
			- Aegir_Mark_III (coolman asks original designer)
	- Descriptions:
		+ Tell maximord about new ships - give him names
		= Copy all descriptions into their respective .shp files
			# From https://docs.google.com/document/d/1niiB9AaqMAzThTY-pGjU3-qxIywKR8-nw_JDiOWcj1o/edit?usp=sharing_eil&ts=5c929c19
			- Test:
				+ Lusitania
				+ HMHS britannic
				+ RMs queen mary
				+ balls
				+ Carnival
				+ Cruise Vessel
				+ Container
				+ Flagship
			+ Ask ship owners
				= mrpasta: wants to see them first
				+ kikotheshipbuilder: all except HMS Thunderchild
				+ Nomadavid: fine
				+ Pac0: will do own
			- Shippymcjerry does:
				- HMS Thunderchild
				+ Karaboudjan
			+ Add Maximord to About box

	+ Michael Bozarth
		+ https://drive.google.com/drive/u/0/folders/1k-A4SE8mMp2j_A3nH3gnl6SvYF9bnWoU		
		+ Add "Michael Bozarth" to About box (link: https://www.youtube.com/channel/UCaJkgYP6yNw64U3WUZ3t1sw)


- Suggestions to spec:
	- Once we have ships, make "Lock Ship in View" flag and move camera with ship's center of mass (representative point or real CoM)
	- Be able to place nukea nd AM bomb anywhere
	- Add new materials: plastic, rubber, fiberglass
	- Fishes
	- Different colored lights
	- Different backgrounds: use keys to switch between a dock, cliffs, open ocean, ice field, etc.
	- Different maps: maps that might even have islands and grass 
	- Black hole
	- Tool to increase or lower mass under the cursor
	- Can the bubble tool be used to remove water from the ship? that could be pretty cool
	- I wonder if that's possible to make the UI dark once the brightness of the game gets lower than a specific level just like your make the FPS counter white
	- I wonder if you can add the "Ground" material, which is a material that cannot move.
	  No physics calculation. Plus, you're using texture, so it would be neat if the same texture as the ground can be applied to it
	- Meteorites
	- Tsunami
	- Earthquake
	- Storm: rain and waves at ~4.4

======================================================================================================================
======================================================================================================================
======================================================================================================================
- Technical Debt:
	+ Global damp as game parameter
	+ Ships start from 1
	+ Do #include "foo.glsl" at ShaderManager
		+ After including redo
		+ Detect loops with unordered_set<std::string>
		+ Use for ship color and texture
	- Try 32-bit build
	- Sound controller: complain if find extraneous files (had issue with ".flc")

- Simulation Optimizations:

	- Try with SpringRelaxation updating only positions
		- Still runs N times, but only updates positions (does a local "integration" based on "forces")
		- After last step, update velocity adding last step's position minus initial position
			- Need to save velocity buffer first
			- Then add to it the resultant of the velocities generated by spring relaxation, i.e. the delta positions
		- Test:
			- See bounces from ocean floor
				- The back-sending should be fine as it's based off real initial velocity TODO: double-check

	= Sea and Ocean Floor: take advantage of bounded-width world (*)
		- Main concept:
			- OceanSurface and OceanFloor contain samples for the entire width
				- Have to find <#Samples==BufferWidth, MaxWorldWidth> pair that we are comfortable
				  with *and* which gives a good resolution
					- Water: 
						- Current dx = 20*pi/512 ~= 0.122m
						- Next dx = W/S @ W=10K => ~80k samples
			- Not anymore periodic, hence no mod anymore to get water height and ocean floor
			- Only the number of samples dictates final definition of surface and floor
			- Uploading is by sample
				- Loop uploads S(i0+ni), with i0=left start, n depending on zoom
					- Magnifying: n = 1, dx > 1; GPU fills-in
					- Minifying: n > 1, dx = n * resolution
						- n chosen so that number of slices kinda like now, i.e. ~= 500
		+ Initial FPS: 29.5/29.8
		+ Impl step 1: Ocean floor
			+ # of samples: try 2K first
			+ dx = MaxWorldWidth/NumberOfSamples
			+ Initialization:
				+ OceanBottom bitmap gets implicitly upsampled to 5000m if w < 5000
					+ If it looks bad, made it larger until definition is enough
				+ Then it gets cut/repeated to # of samples
					+ ImgX = (s * dx) % 5000
					+ Do interpolation
			+ Update:
				+ Sine/cosine is superimposed for each sample, like now
			+ AdjustTo:
				+ Fix
			+ Sampling:
				+ Just find sample index and interpolate in-between
				+ See issue with x==MaxWorldWidth
					+ Do extra sample with same val as previous
						+ Delta is zero though
					+ Remove change at Ship
				+ Test last ocean floor sample, again
			+ Since you're here, change AdjustTerrain tool to do trajectory
			+ Test:
				+ OceanFloor bitmap larger, not multiple (say, 700) - w/recongizable pattern
			
		= Impl step 2: Render upload: use same spatial frequency as samples, so to avoid interpolating altogether
			+ Need first to always render ocean up to visibleWorldBottom, in which case the two are fully independent
				+ Test afterwards
			+ Break World::UploadLandAndWater into OceanFloor::Upload(.) and WaterSurface::Upload(.)
			= Test ocean gradient				
			= OceanFloor::Upload(.)
				+ Find first sample == sample immediately to the left of visibleWorld.Left
				+ Magnifying: n = 1, dx > 1; GPU fills-in
				- Minifying: n > 1, dx = n * resolution
					- n chosen so that number of slices kinda like now, i.e. ~= 500
			+ WaterSurface::Upload(.)
				+ For now, like it was at World
			- Go back to 500 slides
				- Test seams

		- Impl step 3: WaterSurface
			- # of samples: try 4K first
			- dx = MaxWorldWidth/NumberOfSamples
			- TODOHERE
			- Test if # of samples good wrt waves' resolution

	= GPUCalc:
		+ 1: Simple OpenGLContext
		+ 2: Multiple OpenGLContextes
		+ 3: Integrate ShaderManager
		+ 4: Run fragment shader to fill-in with frag coords
		+ 5: RenderBuffer
		+ 6: Read pixels back 
			+ Nail down clamping
			+ Nail down viewport dimensions/renderbuffer dimensions
				+ Fragment shader runs according to window sizes
				+ Try glViewport to set dimensions (40x40)
		+ 7: Make OpenGL initialization once per thread, after first context creation
			+ Test first at FloatingSandbox: do init at MainFrame after context creation
				+ Export required OpenGL version from GameOpenGL
				+ If ok, move ctx creation et al at postinitialize trigger
					+ Test openGL failure
				+ Cleanup comments (3.3.) and TODOTEST's
			+ Do also at GPUCalcText, also at MainFrame after a first dummy context creation
			+ Commit
			+ MainFrame:
				+ Move OpenGL initialization at cctor, rethrow, and catch at MainApp
					+ Test failure
				+ Same identical at GPUCalcTest
				+ Commit
		+ Fix shaders: 120			
			+ Test with FloatingSandbox
			+ Send to guy
			+ Commit after confirmation

		+ 8: Redo Glad with 2.0 profile, and manual ARB's and EXT's for:
			+ Framebuffer
			+ Instanced Drawing
			+ VAOs
			+ Texture Float
			+ Restructure: 
				+ Each feature is a "min"
				+ Merge GladLib into GameOpenGLLib
					+ g_glad.h stays
				+ GameOpenGL_Ext stays
					+ h:
						+ global vars with API and enumerants
							+ validate all enumerants the same across core/arb/ext
					+ .cpp:
						+ Various Init():
							+ Load only one set based off version/ext, with LoadAndVerify
					+ LoadAndVerify
			+ Build all and commit and push

		+ 9: Restructure GPUCalcTest
			+ Log window, clear button
				+ RichText: green/red for TEST_PASS: .../TEST_FAIL: ...
			+ Testcase class:
				+ .h:
					+ Macros that call "this"->OnFail(__LINE__....)
				+ void Run() final;
					+ Inits state
					+ Logs start/end
					+ global pass/fail state
				+ virtual void InternalRun() = 0;
			+ Button for "Init OpenGL"
				+ Clears log first
				+ Own test
			+ Buttons for tests, button for "All tests"
				+ Each button clears log first
			+ Tests:
				+ (all tests create own calculator)
				+ PixelCoords
				+ Commit
		+ 9b: GPUCalcTest: independent from DevIL
			+ Verify GameCore and GameOpenGL are independent from DevIL
			+ ResourceLoader back to GameLib
				+ ShaderMgr takes absolute folder path
			+ CMake adjustments to not need DevIL
			+ Commit
		+ 10: Sum test:
			+ RenderBuffer and textures all have same dimensions
				+ FrameSize this time is calc'd based off min of the three limits
			+ Fragment shader gets texture coords from vertex shader
				+ Interpolation is fine
			+ Cleanup:
				+ See if need to replace ShaderMgr::SetTextureParams with new one
			+ Commit & push
		
		- Other tests:
			- Sum w/calculator reused twice
			- Sum size1 and Sum size2 (2 calculators), one after the other
				- Verify viewport is per-context

		+ x: Verify works with hidden wxFrame, and verify frame is not visible, neither on the taskbar
		- x: Test on two other laptops

		- Cleanup:
			- Set endianness same as platform (x86)
			- See how to force texture sizes to be POT

		- Follow-up's:
			- Optimize ReadPixels
				- Use correct format: query for GL_READ_PIXELS_FORMAT, GL_READ_PIXELS_TYPE
					- See https://www.khronos.org/opengl/wiki/Image_Format
				- Consider using pixel buffer objects to asynchronously read from render buffer
					- See https://stackoverflow.com/questions/12157646/how-to-render-offscreen-on-opengl

	+ Points::ConnectedSprings is of struct { SpringIndex, OtherEndpointIndex }
		+ No two separate buffers, as we seldom (if not neveer) need them separate
		+ Init's @ShipBuilder or at whoever populates it now
		+ Maintained at SpringDestroyHandler
		+ Used at:
			+ ConnectedComponentDetection
			+ UpdateWaterVelocities

	- Retry triangles cache optimization, now that layouts are different

	- Array merging:
		+ Springs: RestLength with Coefficients
			+ Pre:  31.7  32.03  31.5  31.6
			+ Post: 31.5  31.7   31.4  31.6
			* With pad:
			+ Pre:  31.1  31.5   31.6  31.7  32.0
			+ Post: 31.3  31.38  31.3  31.3  31.9
		- Points: Position with Velocity and Force
			- Affects Integrate and Rendering

	- Forces rearc (*):
		- Rationale: multiple spring iterations are really artificial; in reality, changes due to spring position changes in-between 
		  iterations shouldn't impact physical world (e.g. buoyancy/drag) yet
		- Points has two Force buffers: SpringForces and PointForces (or "NonSpringForces")
		- Assumption: no deletions take place during mech loop
		- UpdateMechanicalDynamics:
			- First resets PointForces (or not, may reorder the below to do a first "set" loop rather than "add")
			- Then populates PointForces with force fields
			- Then populates PointForces with gravity/buoyancy/water drag (this one might "set" rather than "add")
			- Then ...propulsion, etc..... all PointForces
			- Then does spring loop:
				- Spring forces
				- Integrate - and reset spring forces
				- HandleCollisionsWithSeaFloor
		- Test final L'n'F'

	= Do SSE with libsimdpp:
		- First check out alternative: https://xsimd.readthedocs.io/en/latest/
		- Prepare sources:
			- GameLib/LibSimdPp.h
				- Defines macro for SSE3 and includes simd.h
					- So that we have a single place for the macro
				- Then defines VECTORIZATION_FLOAT32_SIZE as SIMDPP_FAST_FLOAT32_SIZE, and VECTORIZATION_INT32_SIZE as ...INT32...
					- Allowing us to change it in one place to experiment with loop unrolling
				- SSE code will use VECTORIZATION_FLOAT32_SIZE as the batch size, via SysSpecifics.h (see below)

				- #define SIMDPP_NO_DISPATCHER
				- CMake:
					- register_external(libsimdpp x_libsimdpp) à libsimdpp_path = /../../../ x_libsimdpp
					= target_include_directories(common_models_lib SYSTEM PUBLIC ${libsimdpp_path})
			- Merge FloatingPoint.h into SysSpecifics.h and nuke FloatingPoint.h
			- SysSpecifics.h:
				- Includes LibSimdPp.h
				- make_aligned_element_count: local static constexpr for word size, choosing max of VECTORIZATION_FLOAT32_SIZE & VECTORIZATION_INT32_SIZE

		= UpdateSpringForces:
			+ Version 0/Optimization 1:
				UpdateSpringForces_Naive_mean                     566158909 ns  553803550 ns          1
				UpdateSpringForces_Naive_median                   564963849 ns  561603600 ns          1
				UpdateSpringForces_Naive_stddev                     4619531 ns   18596554 ns          1
				-
				UpdateSpringForces_LibSimdPpAndIntrinsics_mean    431502311 ns  409502625 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_median  415921334 ns  409502625 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_stddev   35247735 ns   18160977 ns          2
			+ Optimization 2 (SpringDir less divisions):
				UpdateSpringForces_LibSimdPpAndIntrinsics_mean    419323870 ns  408332618 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_median  418272468 ns  405602600 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_stddev    6254057 ns    7279802 ns          2
			+ First NaN avoidance:
				UpdateSpringForces_LibSimdPpAndIntrinsics_mean    424542593 ns  402872582 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_median  412086262 ns  401702575 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_stddev   39465568 ns   11672674 ns          2
					and
				UpdateSpringForces_LibSimdPpAndIntrinsics_mean    416146077 ns  398192553 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_median  410967797 ns  397802550 ns          2
				UpdateSpringForces_LibSimdPpAndIntrinsics_stddev    9809876 ns    9628195 ns          2
			- Try rearranging instructions for cache

		- Use at IntegratePointDynamics, to guarantee SSE2
			- Verify with asm
			- Add to credits

		- Use at Ship::MoveBy(), to guarantee SSE2
			- Verify with asm
			- Add to credits

		+ Avoiding if's for divisor==0
			+ No 0.0 checks for divisions, but + 0.00001
				+ Verify behavior of float::max/float::min
				+ Do benchmark: worse
				+ Conclusion: should be used only for SSE vectorization, and when dividend has same
				  magnitude as divisor (e.g. for normalized vector, len==0 <-> x==0 && y==0)
			+ Should investigate masking at the same time, might be faster
		+ Try with different cache optimization heuristics
			+ Starting point: Spring ACMR: original=0.516807, optimized=0.325156
			+ Choose springs with largest numbers of points in cache

	- UpdateWaterDynamics:
		- Test turning it around into (multiple) spring visits, rather than point visits
			- Multiple because of need to normalize outgoing for each point

	- See if can avoid other IsDeleted checks, via zero'ing of coefficients
		+ UpdateSpringForces()

	- UpdatePointForces:
		- Substitute "if(y<waterHeight)" branches with "float isUnderwater (1.f/0.f)"
			- Force compiler into not branching - "?" operator won't work
		- Precalculate things that do not depend on position nor velocity
			- Stored in buffers
				- When possible, via template/lambda tricks
			- Technically, would have to store separately effectiveMassMultiplier (*Mass) and effectiveBuoyancy (*Mass)
				- Test: but could cheat and use water height based on initial positions only, in which case
				  we store directly the result as FieldForce == Gravity + Buoyancy + Water Drag
				  - FieldForce used directly in Integrate(), added to Force (-> "SpringForce")
				  - This allows us to call UpdatePointForces only once
				  - Also need to reset StaticForce buffer before UpdatePointForces, so:
					- UpdatePointForces becomes CalculateFieldForces and take care of *filling* the buffer, overwriting it
	+ Water and Land interpolations:
		+ Prepare first test bench (noinline)
			+ GetWaterHeight: 2.23%
			+ GetFloorHeight: 1.66%
			+ Save assembly
		+ 1: see if it's better to store delta's and/or other pre-calculated things
		+ 2: see if can do semi-integer x-axis interpolation
			+ GetWaterHeight: 1.25%
			+ GetFloorHeight: 0.77%
		+ Cleanup test bench
		+ Final functional test
		+ Final FPS test

	- Cache sea depth from PointDynamics at first calculation (Points?), using lambda


- Gfx optimizations:
					
	- Lights on the GPU with instanced drawing (*)
		- We begin with doing light at vertex (Gouraud)
		- Lamp coords, spread, and luminiscence in uniform array
		- Loop as many times as necessary to avoid going beyond uniform limit of the GPU
			- Figure out max (for right shader: v or f) at OpenGLInit
		- Test 1: simply instance TrianglesTexture
		- Test 2: also instance others
		- At end:
			- Try with light at fragment (Phong)

	- Try using GL_SHORT for Ship texture coordinates
		- Passing NORMALIZE and 3 components to glVertexAttribPointer

	+ (Retry) Use CPU and GPU in parallel
		+ Finalize render (glFlush) before render step, not after
			+ Research glFlush()
			+ By invoking glFlush() and SwapBuffers() in MainFrame, before Render()


- Gfx:
	- Add world end
		- Add texture (square,repeatable in both directions)
		- RenderContext::init: 
			- Don't load in atlas
			- Make it repeated
		- Final step @ RenderContext::Render
			- Checks first which sides, if any, have to be drawn
			- Renders quad for each side

	+ Make font white inversely to ambient light

	- Add SkyRenderMode (Flat, Gradient)
		- The two endpoints of gradient dependent on ambient light
			- Interpolated between two pairs of endpoints
		- RenderContext:
			- If Flat:
				- When clearing buffers, clear also color buffer with flat color
			- If Gradient:
				- When clearing buffers, do not clear color buffer
				- Run program with quad immediately afterwards
					- Shader
						- No orthomatrix, all NDC
						- No ambient light param, no new params

		- SettingsDialog:
			- Gradient RadioButton: on the right has two rows with a gradient each

	- Make water texture scroll with wind speed

	- Electrical view:
		- Spec:
			- New flag (not in ShipRenderMode, standalone ~like StressedSprings)
				- Settable at SettingsDialog
					- Ideally, enabled only if there are electrical elements, but how to figure it out?
			- When enabled, draws "Connections" (lines - w/own endpoints) and "Devices" (points - w/own endpoints) 
			  on top of ship
				- One new layer after tri's, springs, and ropes
				- Connection, w/bool isPowered
					- Powered: 1D texture, animated (w/clock->offset), red
					- !Powered: 1D texture, still, grey matte
						- Both textures are segments in same texture
		- Impl:
			- (Ship)RenderContext::UploadElectricalConnection/Device/Start/End:
				- Conn: 
					- vec2 startPos, endPos
					- planeId
					- isPowered => texture coord
				- Device:
					- vec2 pos
					- planeId
					- vec4 color => color
			- Ship::Render: if flag set: invokes Ship::RenderElectricalElements()				
				- Do a sort of connectivity visit and upload as you go

	- AmbientLightIntensity:
		+ Use also in RenderContext::RenderStart() for clear (sky) color
		+ Phase 1: pgup/down
		- Phase 2: with clock / time-of-day
			- Sky should also have crepuscolar gradient
	- Magnifying glass
		- https://www.opengl.org/discussion_boards/showthread.php/154811-magnifying-glass-effect
		- https://www.shadertoy.com/view/4tdXDl

	+ Bug: bombs et al fade more rapidly than ship when ambient light goes away
	+ Stars at night
		+ Render:
			+ Need to be done at clouds, w/water stencil
		+ Physics::Stars
			+ Update(GameParams) -- recalcs if # changed
			+ Upload(RenderContext)
			+ Managed by world
		+ Test ambient light -> transparency curve
		+ Test customizability
		+ Compare with screenshot
		+ Check performance
			+ FPS: 28.4
			+ PerfAnalysis

- Dynamics:

	- Also dry points should rot, albeit very slowly
		- Could just add ~0.005 to p.water at RotPoints()
		- However this would also apply to overwater points, so we'd have to do it for underwater points only

	- Heat and Combustion (*)
		- Integration of Decay with Combustion:
			- Combustion also is a source of decay
			- Springs should get weak based off decay, independently from source
			- It is really 3 distinct processes:
				+ 1a: Point rotting:
					+ Low-frequency
					+ water + isLeaking => decay
				- 1b: Point combustion:
					- Any frequency (combustion state machine update frequency)
					- combustion y/n => decay
				+ 2: Spring decay
					+ Low-frequency
					+ p.decay => s.strength
						+ Use both endpoints' decay
					+ Impl:
						+ Springs::Decay(Points const &)
							+ For each spring: strength = material's strength * avg of two endpoints' decay
								+ float buffer: MaterialStrength
		- TO INTEGRATE: Materials have CombustionType==(Explosive, Burning?)
			- And "gunpowder" material
		- TODO: from Moleskine
		- TODO: HeatPropagation (and others?) may run sparingly

		- Flamethrower tool:
			- Need new layer - InteractionLayer - to do flamethrower's flames
				- Owned, like text layer, by GameController

	- Dynamite that may be thrown to the ship

	- New electrical material: clamp
		- When powered, destroys point (and of course its springs)
		- Make ship with lifeboats, using multiple clamps to keep it

	- Lights breaking under pressure
		- Idea:
			- All structural materials have max pressure delta after which they break, with some randomness
		- Impl:
			- All points visited and checked at some step in UpdateMechanicalDynamics(), before UpdateWaterIntake()
				- Pressure delta between current water at point and external Y
				- With probability growing in a band around max pressure delta

	- OceanFloor:
		- Make number of samples be bump map width
		- Still check width is power of two
		- Still calculate bit stuff for fast mod
		- Make default floor larger and check perf impact

	- Ocean floor breaking up upon impact
		- Layer on top of floor samples, with hash buckets and lists of heights per-bucket
		- Spec:
			- Ocean floor has "height overrides" for bumps, etc.
				- Addressed via "quantized X", i.e. buckets of X
					- BucketSize ~= "default/initial visible world width" divided by ~ number of slices (512)
						- Or dictated by will to re-use sample index @ sampling
				- Fast lookup of X:
					- Hash table w/hash=periodic bucketized X (same used for curve interpolation),
					  & value=list of actual "quantized X" with corresponding H
					- Hash table is array<vector<x, h>, # of buckets>
			- @ Ocean floor collision:
				- Upon point entering floor:
					- Points goes back by displacement * FloorHardness
					- Ocean floor's H goes back by displacement * (1 - FloorHardness)

	- Stop playing music when ship has "sunk"
		- Need to figure out easy way to detect "has sunk"


	- Auto-adjust zoom at ship load
		- Use preferred zoom from .shp file
		- Configured by GameController

	- Figure out what to do with connected components and ephemeral particles
		- Depending on the above:
			- See if can piggyback the fact that Points is already uploading all (well, now non-ephemeral) point element indices
			- ShipRenderContext: for each conn component, use a vector (w/reserve) rather than full MaxParticles
				- Can then get rid of MaxCount, CurrentCount
		- Possible solution # 1: wait for Z buffer; when it will be done everything will be for free:
			- Assign provoking point's Connected Component ID 
			- ConnectedComponent buffer is a proxy of points' Z, has no bearing to multiple buffers that need to be pre-allocated
			- Ephemeral particles in ShipRenderContext are then a single NOT-per-connected-component single buffer of indices,
			  exactly like normal points
				- May be at this moment we can unify normal point uploading

	- Ephemeral particle emitters
		- TODO: decide between the below (emitter is new object type in its own right) and having instead emitters as special
		  types of electricals
		- Implemented like electrical elements, i.e.:
			- EphemeralParticlesEmitters container, almost clone of ElectricalElements
				- Contains point index and IEphemeralParticleEmitter
					- IEphemeralParticleEmitter: 
						- void Update(clockNow, Points &, MaterialDatabase const &)
						- Impl knows its point index
				- Passed already populated by ship builder
		- Ship has EphemeralParticlesEmitters, passed already populated by ship builder
			- Registers DestroyHandler, all identical to ElectricalElements
		- Ship::UpdateEphemeralParticles: invokes EphemeralParticlesEmitters::Update(...)
			- Which invokes IEphemeralParticleEmitter::Update(clockNow, mPoints) for each emitter
		
	- Smoke:
		- New material: smoke emitter
			- Recognized by ship builder via "particle_emitter_properties" sub-object
		- New material: smoke
			- Lighter than air
		- UpdatePointForces: if any point is above water, apply air buoyancy
			- i.e. always end up applying one buoyancy, either water or air
		- IEphemeralParticleEmitter implementation: SmokeEphemeralParticleEmitter
		- Research particle motion - inject random walk in smoke and bubbles
			- https://core.ac.uk/download/pdf/337937.pdf !!!
			- http://orbit.dtu.dk/files/3706687/Visser6.pdf
			- @ Smoke
				- http://matthias-mueller-fischer.ch/publications/sca03.pdf

	- Fire
		- Materials have flammability
		- TBD: how to ignite?
		- Once ignited, it spreads
		- Water sets fire off, of course
		- After some time burning, a point breaks
		- While burning, changes material so that buoyancy goes down?

	- Fireworks
		- New emitter material, much like smoke emitters
		- Fires when wet for the first time

	- Switches:
		- New electrical material type
			- Color trick like ropes to have unique and deterministic IDs for switches
				- One material (base structural color) for initially on and another one for initially off
			- New electrical property: ConductsElectricity, bool - used at connectivity visit
				- Lights, Cables, Generators have it as true
				- Switches have is as true or false depending on whether switch material is on or off
		- GameTypes:
			+ ObjectId overhaul:
				+ ObjectId is unique only in the context in which it's used (e.g. bombs vs switches)
				+ ObjectId == <ShipId (new GameType alias, uint32_t w/ None), LocalObjectId (uint32_t)>
					+ LocalObjectId is provided by caller
					+ ObjectIdGenerator only provides helper for globally unique - with no guarantees - or should go
				+ All ship ID ints become ShipId
				+ All object ID ints become ObjectId
			- LocalSwitchId typedef (uint32_t)
			- ObjectId:
				- Templated on type of local ID
				- Also strong typedef (w/tag?) -> SwitchId (on LocalSwitchId)
		- Ship json adds optional names for each ID
			- as vector<pair<local switch ID, std::string>>>
				- local switch ID is ID from color code
		- ShipBuilder detects all switches as electrical elements
			- Initial ID is from color code
			- Checks for duplicate initial IDs
			- Initial ID is only used to match with ship's switch names
			- Then, generates an ObjectId using ship ID and local object ID
				- LocalObjectId is just element index of switch in ElectricalElements
			- Each switch gets name as part of Electrical Elements data communicated to ship
				- ObjectId is implicit (local ID is index in container of switches's ElementIndex within ElectricalElements)
		- Create and Destroy events:
			- Ship::cctor visits switches among ElectricalElements and fires AddSwitch(ID, name, state)
			- Ship::ElectricalElementDestroyHandler fires DeleteSwitch(ID) if deleting a switch
		- MainFrame gets switches via AddSwitch (and DeleteSwitch) event, with all metadata (ID, name, state)
			- From Ship::cctor, visiting switches among ElectricalElements
			- SwitchBoard panel (see below)
				- Registers as event listener at cctor
				- Uses GameController (own shared ptr) :: SetSwitch(ObjectId switchId, bool state) to control switches
		- MainFrame:
			- Also registers for AddSwitch and shows SwitchBoard on first add
				- As long as UIPreferences::AutoShowSwitchBoard is set (default=true)
					- Menu item to toggle AutoShowSwitchBoard; only changes UIPreferences
			- Hides it again only at Reset()
		- Electrical dynamics:
			- ElectricalElement: rename "ConnectivityVisit" (sequence number, etc.) as "ElectricalPropagationVisit" (...)
				- Ship::UpdateElectrical"Propagation"
			- ElectricalElement has new "conductsElectricity" bool buffer
				- Init'd with material's
				- Ship::UpdateElectricalConnectivity checks conductance first when deciding to follow a connected electrical element
			- Ship::SetSwitch(LocalSwitchId, bool):
				- Toggles electrical element's "conductsElectricity", via ElectricalElements::SetSwitch(switch index, bool)
		- SwitchboardPanel:
			- MainFrame menu pops it up and down (and MainFrame also pops it up automagically at first switch add, see above)
				- Menu items to toggle it, enabled iff there's at least one switch
			- Has control to hide it back (kinda like "close" button at top-right corner)
			- ShipSwitchControl: much like slider, button (w/two switch images) with label below
				- Switch event is via lambda
				- Media:
					- 2 images
					- 2 sounds
			- Panel: much like ProbePanel
				- Has:
					- ResourceLoader const & (used @ cctor only for button images)
					- GameController (see others for shared_ptr or &)
					- SoundController (see others for shared_ptr or &)
				- Registers as event listener
					- Processes IGameEventHandler::OnSwitchCreate/Delete
					- Processes Reset() to delete all
				- Has unordered_map<ObjectId, uq_ptr<SwitchControl>>
				- OnSwitchCreate:
					- Create uq_ptr<SwitchControl>
					- Add to map
					- Add to panel - left-aligned
				- OnSwitchDelete:
					- Remove from panel
					- Remove from map
				- Gets key events from MainFrame when MainFrame does not recognize
					- XYZKeyEvent: returns bool for processed/not processed, so MainFrame can chain
					- Shift and Alt do +10, +20
			- Switch event lambda:
				- GameController->SetSwitch(ObjectId switchId, bool state)
				- SoundController->PlaySwitchOn/OffSound()
		- Do not propagate switch characteristics through ropes
				

	- Pumps
		- Spec:
			- New electrical element
			- Two types: "in" or "out" (a bool electrical property)
			- Water is taken @ ElectricalElements::Update()
			- Point that pump is attached to may or may not be hull, and may or may not be leaking; regardless, when powered,
			  water is sucked in our out
			- Continuous sound when pumping
		- Impl:
			- ElectricalElements::Update():
				- For each pump element (own separate list, for perf):
					- If powered: // eventually have state machine for lead-in/lead-out
						- If type is "in" && y < waterLevel && point.water < external pressure:
							- Take in water - with quantity from GameParameters
						- Else if type is "out" && point.water > 0:
							- Take out water - same quantity from GameParameters
			- @ power state changes: emit event, for continuous sound - much like TimerBomb's fuse
				- Need object ID

	- Flood doors
		- Spec:		
			- New electrical element
			- Point that flood door is attached to may or may not be leaking
			- Plays one-shot sound @ when open or closed - much like TimerBomb's defuse
				+ No ObjectID needed thus
			- Power connectivity state changes cause modifications of water propagation coefficient of spring (i.e. WaterPermeability)
		- Impl:
			- ElectricalElements::Update():
				- For each flood door element (own separate list, for perf):
					- Run state machine (including eventual lead-in/lead-out's)
					- @ state changes:
						- For all connected springs: one of the following, depending on connectivity state:
							- Springs::SetWaterPermeability(idx, val) 
								- See if can use fractional values for half-open/half-closed
							- Springs::SetDefaultWaterPermeability(idx)
								- Uses private CalculateWaterPermeability(), also used by cctor
						- Anything else? See water momenta algo
			+ No real need to also change Point::Buoyancy
			+ No real need to also change Point::IsHull
				+ Points' hullness is only used to decide whether or not to make a point Leak when an attached spring breaks; we
				  leave this determined by underlying structural material
			+ Springs::IsHull should be gone by now



	- Propulsion
		- New electrical element - engine
			- Publicized like switch, and switchboard shows slider
				- Need custom-drawn ShipSliderControl control
		- Electrical current (0.0 vs !=0.0) and slider ("engine speed" buffer) control force
		- At ElectricalElements::Update(): if powered, apply force to point (4 materials for 4 directions)
			- Requires forces rearc, with separate "Mechanical" and "Other" force buffers
				- And smarter zeroing of Mechanical
			- Or can we piggyback on the "non-spring" force buffer that we talk about at "force rearc" above?

	- Test:
		- Self-adjustment of kSpring and kDamp based off paper's formula (H and L bounds)
		- Debug to see if bounds ever exceeded

	- Frontier:
		- Only for non-rope points - rope points never take part in frontier
		- Preliminaries:
			- Make sure endpoints in triangle are always in CW order
			- Problem with rendering frontier in "Render Frontier" mode:
				- In order to correctly draw dangling (i.e. same connected component) parts on top of all of the connected component's 
				  frontiers, we'd need to have the dangling parts disconnected from the connected component, which means that we should
				  not follow ropes _at_all_ (no matter the transition type) during connected component detection, and allow those 
				  ropes to belong to the next connected component
					- Still vulnerable to dangling parts not connected via ropes (e.g. masts) though: 
					  frontier would still be drawn on top of it
				- Might get away with drawing frontiers - *enlarged* - before all of the rest? What is left of the enlarged part 
				  would be the rendered frontier, as it would be visible only around external frontiers (and through holes)
		- Plan:
			- Structures
			- Initial frontier at ShipBuilder
			- Render frontier: 
				- New render setting 
				- New ship upload 
				- New shader (red with 0.5 alpha, thick line width)
		- Impl:
			- Jumpstart algo:
				-	5	6	7
					4	*	0
					3	2	1
				- For each scan line:
					- For each flip point (0->1 or 1->0) from left p0 such that p0 does not belong to any frontiers:
						- fId = new frontier ID
						- p = p0; k = 4|0 (depending on flip type)
						- do:
							- Find p' from k+1 to k-1 (CW, %8)
								- If not found: it's an isolated point, go to next flip
							- Lookup <p, p'> in edge map
								- edge map is a purpose-built map, with <p, p'> being a lexicographically ordered key
								- assert is found, unless this is a "pure spring"
							- Make edge belong to frontier fId
							- if p' == p0: break
						- continue to next flip point on same scan line
		- Conclusions:
			- Revisit need to have SuperTriangles and SubSprings, as we might now use edges
				- We would now only upload springs that have 0 or 1 edges
		- TODOOLD
		- Realize that a node can belong to up to 4 frontiers (center of 4 holes)
			- And a point deletion might cause a merge of the four
		- Frontier is set of points, marked as frontier, and connected to each other via 
		  nextInFrontier * and prevInFrontier * (in CW order) 
		- Algo:
			- There are multiple frontiers, 0 is external, N is internal, isolated
			- Calculate frontier at ship create, based off structural matrix, using geometry
			- At each point deletion:
				- 2 cases: OR: only later check if one of the connected points is already a frontier 
				  (a deleted frontier point is bound to be connected to two other points of the same frontier, for each frontier)
					- Point deleted is a frontier point:
						- TODO
					- Point deleted is NOT a frontier point:
						- All its connected points become a frontier
						- If one of the connected points is already a frontier, then the new frontier points
						  take that frontierId
						- TODO
	- Water drag 
		- The one already there assumes velocity always normal to surface, but we should consider surface normal instead
			- Requires frontier
		- The new directional drag could make parts of the ship break off

	- DestroyAt:
		- Test: Ship::SpringDestroyHandler() only destroys triangles that contain A-B
			- Should definitely make both A and B leak, as they both now have an adjacent hole
	
	- See if can use external water's pressure to inflict stress on springs
		- Have to visit frontier points and, if underwater, do force perpendicular towards interior

	- Stars with database
		- python script to generate binary maps for N and S emispheres

	- Random noise that lowers strength to inject "cracks" when the ship is under stress
		- Random walk across pairs of points on opposide sides of ships

	- Torpedoes
		- Requires collision detection
		- Might either have own propulsion or follow a vector specified with click-and-drag
		- Also other objects might be launched with click-and-drag

- Water:
	- If we don't have enough particles for air bubbles, test the following::
		- Air bubbles only at leaking that became so because they have been broken
			- "IsLeaking" -> "LeakingType": None, Leaking, LeakingDamaged
		- Increase # of ephemeral particles


	- OLD: Optimizations:
		- GravitateWater:
			- Calculate once and for all cos theta's at first iteration
				- !!! Actually, calculate WaterGravityFactorA = dt*0.6*(1+cos_theta)/2, WaterGravityFactorB = -dt*0.6*(1-cos_theta)/2
					float cos_theta_select = (1.0f + cos_theta) / 2.0f;
			                float correction = 0.60f * cos_theta_select * pointA->GetWater() - 0.60f * (1.0f - cos_theta_select) * pointB->GetWater();
			                correction *= GameParameters::SimulationStepTimeDuration<float>;
				- Test (check disassembly) with templated lambda (Spring const &)->void
					- First one calculates factors and stores them in Spring
					- All others empty
					- All iters take factors from Spring after calling lambda


	- New sinking detection:
		- Sinking detection is broken - it currently only considers total water that entered the ship, which comes proportionally to external
		  water pressure; all this water could be confined to a tiny volume, and yet we trigger sinking
		- Should be based off # of points underwater
			- Could be a very-lo-freq step that just checks y's against water height at that point
				- Use HighWatermark/LowWatermark
			- Make music class with FadeToStop()
				- Also call its ::Update(), which fades
					- Called only for music's that we know are to fade
				- Stop() stops immediately at any point


	+ Did original game propagate water also through hull springs? YES. How did hull thin dividers work? THEY DIDN'T WORK
	+ Add Point::Hull Characteristic, and don't leak/propagate(incl. gravitate) water if at least one of the two points is hull			
		+ Alternatively: just make a spring hull if one point is hull; test it

	- Make waves with Shallow Water Equations 
		- And if frontier works, change height when frontier touches water for the first time
		- Problem with extent of heightfield: needs to look good when zooming out; 3 alternatives:
			- 1: Find a way to stitch X segment to required world X
				- i.e. still "periodic"
				- Note that can't mirror segments or else waves would have different directions
			- 2: Upsample and downsample depending on zoom
				- But we lose details when we zoom out and then in again
			- 3: Just cap zoom to reasonable max
	- Rogue waves
		- After cracking periodic repetition puzzle
	- Breaking waves (Muller's paper)


- Game Interactions and Controls:

	- Setting for wave width 
		- Changing the width of the waves up to at least 10x the current size
		- Period: https://www.quora.com/How-can-I-determine-the-period-of-a-sum-of-sines-or-cosines-or-mixed
		- Option 1:
			- Requires re-calculation of period (if adjustment is x-multiplier N, then period is N times basic period?)
			- Resolution stays the same
		- Option 2:
			- Integral ticks to change frequencies so that period is always the same

	- Pick tool: ability to move individual connected components
		+ After connected component has been overhauled
		- Spec:
			- New tool gets point ID from GameController::Pick() and passes it to new MoveTo()
			- Move tool becomes this new one
			- Old move tool becomes "MoveAll" tool
		- Impl:		
			- Pick engagement returns ObjectId for point ID (or none)
				- Ship::Pick(vec2f position) -> opt<ElementIndex pointId>
				- World makes opt<ObjectId>
			- Ship::MoveTo(ElementIndex pointId, vec2f position, vec2f velocity) (new overload):
				- If point deleted => return false (to disengage)
				- Calc deltaPos for the point
				- Translate point's connected component by deltaPos, and add velocity
				- Test: if we get a tremolo:
					- Store Move args @ Move() and apply after UpdateMechanics()
			- Tool: new paradigm (no need to do rotation, so simpler)
				- Invoke MoveTo() continuously at Update() only
					- Disengage if it returns false
				- Pass velocity = current (synthetic) mousePos - last (synthetic) mousePos
			- Help

	- Ship definition: 
		- Interior layer:
			- New layer @ ShipDefinitionFile and ShipDefinition
			- New flag @
				- ShipRenderMode
				- SettingsDialog
			- RenderMode rearc:
				- ShipDefinition:
					- std::optional<ImageData> TextureImageData
					- std::optional<ImageData> InteriorImageData
					- ImageData StructureImageData
					- std::optional<ImageData> FallbackImageData
						- i.e. the 8X structural
				- RenderContext:
					- Exposes "HasShipTextureImages()" and "HasShipInteriorImages()"
						- Updated @ AddShip (via OR) and @ Reset()
				- SettingsDialog:
					- Enable options conditionally 
					- Refresh by MainFrame upon AddShip/Reset/...
				- New RenderMode: DrawPrimitives
					- Takes the place of the current "Draw Structure"
				- ShipRenderContext:
					- When not drawing primitives, texture used is:
						- If "Texture" -> Texture OR Fallback
						- If "Structure" -> Structure
						- If "Interior" -> Interior OR Fallback

- UI:
	+ PreferencesDialog:
		+ Nuke UISettings and move its setting in UIPreferences
			+ Also remove it from SettingsDialog altogether
		+ Plug into MainFrame
		+ Tooltip at ScreenshotsDir
		+ Tooltip at StartupDialog

	+ Ship Descriptions (*)
		+ ShipMetadata: description
			+ opt<string> member
			+ json load
		+ ShipDescriptionDialog
			+ Modal usage
			+ HTML control
			+ MakeHtml
			+ cctor takes bool ShipMetadata const &, isAutomatic, sh_ptr<UIPreferences>
				- If automatic, checkbox with "Don't show description when ships are loaded"
					- With tooltip about UIPreferences
		+ MainFrame: at LoadShip
			+ If gameController reports successful load, check UIPreferences and eventually create
			  ShipDescriptionDialog (automatic=true) and DoModal()
		+ Integrate in ShipLoadDialog
			+ 'i' button enabled when a ship with description is selected
			+ ShipLoadDialog needs to get ShipMetadata
		+ Checkbox at PreferencesDialog for auto-show
		+ Test:
			+ Select and later load .shp w/no description
			+ Select and later load .png w/no description
			+ Checkbox 
				+ @ ShipDescription window
				+ @ PreferencesDialog
				

	- SettingsDialog: save settings, defaults, and real-time changes
		- SettingsManager (@FloatingSandbox):
			- Has GameController, SoundController, UISettings, etc.
			- Defines struct with all customizable setting members
			- Maintains two copies of struct:
				- Defaults
				- Last
			- Currently-enforced settings live at their place, i.e. at GameController, SoundController, UISettings, etc.
			- Manages saving and loading customizable settings to and from json
			- Created by MainFrame on startup
				- Initializes here, loading settings if present
			- Exposes getters and setters for all customizable properties, used by SettingsDialog
				- get(): from their place
				- set(): to their place
			- cctor (actually, CreateInstance()->uq_ptr which MainFrame makes shared):
				- Makes defaults (in Defaults), asking member providers for their (compile-time default) values
				- Then if personal_settings.json exists:
					- Loads it to temp struct - via Load(filepath)->temp struct
					- Then applies temp struct - via ApplyToGame(temp struct)
			- CreateCheckpoint():
				- Makes Last by reading from GameController, SoundController, etc.
			- Load(filepath)
				- Loads from path into temp struct - via Load(filepath)->temp struct
				- Then applies temp struct via ApplyToGame(temp struct)
			- Save()
				- Save(path of personal_settings.json)
			- Save(filepath)
				- Reads current from their place into temp struct - via ReadFromGame()->temp struct
				- Saves temp struct to filepath
			- RevertToCheckpoint()
				- Applies Last
			- RestoreDefaults():
				- Applies Default
			- RestorePersonalSettings():
				- Load(path of personal_settings.json)
			- Internal helpers:
				- ApplyToGame(struct)
					- Applies struct to GameController, SoundController, etc.
				- ReadFromGame()->struct
					- Reads all from GameController, SoundController, etc. into struct
						- struct cctor has all vals
				- Save(struct, filepath)
				- Load(filepath) -> struct
		- Impl:
			- Standard paths: http://docs.wxwidgets.org/3.1/classwx_standard_paths.html#a4752213ef4d7bdc71170b9e5c3691f0f
				- Via StandardSystemPaths class
		- Dialog:
			- Control values are meant to always be in sync with real game params
				- Handlers write value directly to SettingsManager
				- Then mark dialog as dirty
					- Dirty means there have been changes, which might get wiped (by restoring Last) if Cancel is pressed
			- UI:
				- Remove Apply 
				- Buttons: OK, Revert Changes (iff dirty), Cancel (iff dirty)
				- File Menu: Save As Defaults, Save Preferences..., Load Preferences..., Restore Defaults, Restore Factory Defaults
			- OnShow():
				- Calls SettingsManager::CreateCheckpoint()
				- Reads all control values from SettingsManager
				- Does not mark self as dirty
			- SaveAsDefaults: saves current to personal_settings.json
				- Calls SettingsManager::Save()
				- Stays dirty if it was dirty
			- SavePreferences: saves with filename
				- Calls SettingsManager::Save(filepath)
				- Stays dirty if it was dirty
			- LoadPreferences: loads with filename, changes settings
				- Calls SettingsManager::Load(filepath)
				- Reads all control values from SettingsManager
				- Marks self as dirty
			- RestoreDefaults: we set everything to personal_settings, but don't commit - allow Revert
				- Calls SettingsManager::RestorePersonalSettings()
				- Reads all control values from SettingsManager
				- Sets dirty
			- RestoreFactoryDefaults: we set everything to default, but don't commit - allow Revert
				- Calls SettingsManager::RestoreDefaults()
				- Reads all control values from SettingsManager
				- Sets dirty
			- OK:
				- Close dialog
			- Revert Changes: 
				- Calls SettingsManager::RevertToCheckpoint()
				- Reads all control values from SettingsManager
				- Cleans dirty - via MarkAsDirty(bool)
			- Cancel (only shown if dirty)/Close
				- Calls SettingsManager::RevertToCheckpoint()
				- Close dialog
			- Helpers:
				- MarkAsDirty(bool)
					- Stores flag
					- Enables/Disabled buttons and menus

- Sounds:
	- Ship may come with custom sound(s) for horns
		- Figure out how to play them, may be like switchboard or *via* switchboard, or with just one horn sound
	- Morse code sound when it's about to sink (early sink detection)
		- Or at first drop of water
		- Morse code: text-to-morse encoder would be cool
			- Default "S.O.S.", also customizable via ship property
	- Volume of effects should depend on distance/zoom

-Probing:
	- IProbe:
		- World and Ship take shared_ptr<IProbe> and store it, exactly like IGameEventHandler
		- Single instance of IProbe is ProbePanel, which is given to GameController::cctor by Frame at initialization
		- Example IProbe methods:
			- void ProbeWaterSplashed(float waterSplashed)
				- One scalar, pass through to ScalarTimeSeriesProbeControl (iff IsActive)
			- void ProbePointForces(vec2f const *)
				- For other things at different steps in the simulation algorithm
				- IProbe knows whether it cares about a specific point and, if so, takes that and draw is
				- IProbe might also create stats
	= ProbePanel
		- Pre-created member of MainFrame
		+ Then exposes Update() invoked by MainFrame, always, after simulation step
		+ Update(): 
			+ if not visible, return;
			+ Draw current Statistics from current StatisticsProbe
		- TBD: mechanism to select point, etc. from ship, which will be used for probing afterwards
	- Histograms:
		- class Histogram
			- map<float, float in [0,1]>
		- class Statistics (various Histograms, etc.)
			- Histogram pointWaterHistogram
			- ...

- Resource Packs (*)

	- Resource pack contains:
		- Subset of textures
		- Subset of shaders
		- Subset of settings
		- Subset of materials, and new materials
	- Impl:
		- Data\Resources\{Default, <Pack name>}\
			- Textures\
			- Shaders\
			- settings.json
			- materials_structural.json
			- materials_electrical.json
			- metadata.json
				- author, description, name
			- Misc\
				- For ocean bumps
		- ResourceLoader:
			- Static methods only for default paths
				- e.g.: GetDefaultTextureDatabaseFilepath()
			- 1 static method to get list of non-default ResourcePackMetadata's 
			- cctor takes optional pack name
			- Instance methods for *optional* pack-override paths
				- e.g.: GetOverrideTextureDatabaseFilepath()
			- Each "DB"'s Create(...) takes a ResourceLoader const &
				- Own responsibility to check if override exists and, if so, to load override and reconciliate
			- No more methods that load DB's
		- Switching:
			- Ad-hoc MainFrame dialog showing ResourcePackMetadata's 
				- Chosen one goes to ApplicationSettings (see elsewhere in this roadmap)
				- Checkbox for "Set as default" => ApplicationSettings::Save()
				- At Save, before saving - notify that a reload is necessary

- Multiple ships:
	- Better done after collision detection
	- When ship loaded (added):
		- World adds it not to mShips, but as opt<Ship> mPendingShip
			- Not considered in Update(), but considered in Render()
		- MainFrame begins new PendingShipPlace tool
			- OnMouseMove: tell GameController (->World) mouse position as GameController::MovePendingShipTo(screen coords)
				- Ship::MoveTo(world x, y): 
					- Moves all Points by (x,y)-mCurrentRepresentativePosition
						- Ship::mCurrentRepresentativePosition (init'd as {0,0}) tracks current "center"
					- mCurrentRepresentativePosition = (x,y)
			- OnLDown:
				- Tell GameController (DropPendingShip(x, y)) which:
					- Tells World via World::DropPendingShip(x, y):
						- Final Ship::MoveTo()
						- Move ship from mPendingShip into mShips
					- Fires IGameEventHandler::OnPendingShipPlaced(shipId)
						- EventTicker: say this and other Reset/Load
						- SoundController: play sound
				- Stop PendingShipPlace tool

- Passengers:
	- Ship has number of passengers
		- "like how many people would be aboard & as the ship sinks it like shows how many people are alive, escaped via life boat or died"
		- Maybe a life count? like you have sorta a life count on the top right of the screen that says Alive: number. Dead: Number. 
		  And as the ship is sinking you press a button like say A (abandon) for example and people will start heading to the life boats 
		  to survive. The counter will stop once the ship is fully under the surface of the ocean or the entire boat deck is under water. 
		  The boat deck would be highlighted sorta like how the light system works.

	- Moving passengers
		- Separate layer provides floors, ladders, and obstacles
		- Can get away at beginning with pacman-like figures
		- For more realistic version:
			- Skeleton with 10 parts (8 limbs, body, head)
			- Need to make these actions:
				- Walk
				- Fall
				- Climb
				- Swim

- Collision detection - for multiple ships
	- Nearest neighbor: http://www.cs.umd.edu/~mount/ANN/

==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==== DONE
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================

+ Build glfw yourself
	+ clone from git
	+ build
	+ fix Ship's CMake
		+ C:\Users\Neurodancer\source\build\glfw\src\Release
+ move to source/build:
	+ ShipSandbox

IF WX:
+ build WX (Debug, Release)
+ add WX to CMakeFiles.txt
	C:\Users\Neurodancer\source\repos\wxWidgets\include
	C:\Users\Neurodancer\source\repos\wxWidgets\lib\vc_x64_lib
		names: wxmsw31u[d]_core.lib wxbase31u[d].lib
+ remove titanicapp.*, titanicmain.* from CMakeFiles.txt
+ do a simple main with wx
+ rebuild WX with C++ Runtime being statically linked
+ test
+ see getting rid of whole wx.h and only include wxwindow
+ get rid of GLFW in all source files
+ setup CMakeFiles.txt: Remove GLFW
+ resuscitate old code, merging it with new existing structure:
	+ mainApp - mainApp class, main #define
	+ mainFrame - entire frame
+ test	
+ remove titanicapp.*, titanicmain.*, main_old.cpp
+ one-shot timer
+ nuke GLFW from hard disk (repo, build)
+ add logger and fix missing ship

+ Get perf baseline and start Readme.md and Changes.txt

===========
+ cherry-pick that typo fix
+ logging window: try http://docs.wxwidgets.org/3.0/classwx_text_ctrl.html
+ rename members of Frame, cleanup code

+ Render/Game"Settings" -> "Parameters"
+ LoggingWindow -> "Dialog"

+ SettingsDialog:
	+ Add spacing
	+ Taller sliders
	+ Min and Max
	+ add textboxes 4 vals
	+ ApplySettings()
		+ GameController takes (& gives) absolute vals, & provides GetXMax/MinValue() (from YYYParameters)
		+ Helper funcs in SettingsDialog do conversions
	+ ReadSettings()
	+ Other controls for other settings
	+ rename members, cleanup code

+ MainFrame:
	+ LogWindow bug when minimizing and maximizing main frame
	+ Do we need mMainGLCanvas and context to be unique_ptr's?
	+ Render once @ beginning
		+ Check if OnPaint is the right one
	+ Maximize
	+ ReloadLastSelected
	+ See if canvas.setcontext is necessary
		+ Watch out for resize
	+ +/- for zoom *IN MENU*
		+ remove wxEVT_CHAR_HOOK at panel and use menu hotkey and event instead

+ Investigate dirty lines

+ Use own exception

+ Fix DestroyAt
	+ Add DestroyRadius to GameParameters (not in SettingsDialog yet)

+ Fix final destroyer

+ Setup UnitTests
	+ Build GTest Debug and Release
	+ Create UnitTests project in CMake
	+ First unit test: vectors

+ GameException: cctor with string
	+ Utils::Convert(string)->wstring

+ Rebuild Devil but make it a dll with static runtime
+ Move DevIL init to GameController
	+ No DevIL dep's in ShipSandbox
	+ DevIL_INCLUDEs from GameLib are not public

+ Move to picojson
	+ Nuke SDK
	+ Remove public-ness of JSonCPP

+ Settings: 
	+ Destroy Radius
	+ "World"XYZ if really it is world

+ Frustum? For 2D? Try Ortho?

+ Change MainFrame's build info
	+ separate Version.h

+ Mask with copyright at all source files (copy from XXmain)
	+ Already capitalized
	+ Those to be capitalized
		+ material
			+ Rename
			+ cctors:
				+ from picojson obj
			+ Create()->UQ_PTR
				+ private cctor
				+ all members const
			+ optional Material::ElectricalProperties
		+ Also Renderer becomes a namespace, not a class
		+ render
			+ Renderer
			+ move ScreenToWorld here
			+ All static methods, inline
		+ util
		+ phys: 
			+ Rename as Ship, World, Point, etc.
			+ TODO: see first if can split into separate files
				+ commit & push first
				+ cpp's in namespace
				+ Physics.h: includes all and each .h and .cpp includes Physics.h 
			+ Private vs Public attributes:
				+ No friends
				+ All members mPrivate
				+ All getters and setters (when needed)
		+ vec

+ Simulation Optimizations:
	+ Move back to baseline
	+ Take profile X 2
	+ set these flags and see impact (on Release)
		+ Ox
		+ fp:fast
	+ Flags for non-MSVC:
				<Compiler>
					<Add option="-O3" />
					<Add option="-ffast-math" />
					<Add option="-fno-math-errno" />
					<Add option="-funsafe-math-optimizations" />
					<Add option="-ffinite-math-only" />
					<Add option="-fno-trapping-math" />
				</Compiler>
	+ Make all render() const
	+ Make all render() inline
	+ Make all vector funcs inline in .h
	+ Take full baseline first
	+ FPS: 17.3/17.7
	+ We don't need redundant triangles
		+ Row visit: for each point *after* the very first of a streak, only do triangles up to 90 degrees
			+ But keep doing all springs
			+ use boolean isInShip, init=false, set to true at end of single-point processing if point exists and set to false otherwise
		+ Before: 5231 points, 19932 springs, 19569 triangles
		+ After: 5231 points, 19932 springs, 9819 triangles
	+ FPS: 19.2/19.3
	+ Fix division by zero
		+ Do fix
	+ FPS: 19.1
	+ SSE2:
		+ Test first: Integrate: 
			+ 1a: pack Pos, Vel, Force from 2 points into local vec4f
				+ For loop with two points at a time
			+ 1b: create buffers with all Pos, Vel, Forces, and call function with restricted pointers: IT USES PACKED SSE's!
		+ Undo
	+ Vertex cache optimizations with Forsyth's algo:
		+ Break out ShipBuilder, friend
		+ Use own LRU cache and calculate current ACMR for triangles and springs
			+ Spring ACMR: 0.516807
			+ Triangle ACMR: 1.01986
		+ Do triangle vertex cache optimization
			+ New ACMR: 0.68174
			+ FPS improvement: 19.1 -> 19.0
			+ Check if self-covering within same connected component now looks weird
			+ Test on samsung: 18.5/18.8 -> 18.5/18.6/18.8/19.0
			+ REVERT, IT'S (MARGINALLY) WORSE!
		+ Do spring vertex cache optimization
			+ New ACMR: 0.325156
			+ New FPS: 19.4/19.7
	+ FPS: 19.3/19.5
	+ ShipRendering: upload triangles, ropes, springs only when they change
		+ Have VBOs per connected component
	+ FPS: 19.0/19.4/19.7/19.9
	+ Point & Spring Destructuring:
		+ Starting FPS: 19.0/19.4/19.7/19.9
		+ Main goal: improve cache locality
		+ Secondary goal: make vectorization-friendly
		+ Replace Point, Spring, Triangle with Points, Springs, Triangles
			+ Base is ElementContainer
				+ Defines aliases (ElementCount, ElementIndex) - uint32
				+ ElementCount GetCount() const
					- Number of elements
					- passed at cctor
			+ They contain N buffers:
				+ Points: Position, Velocity, Force, MassFactor, Color, Water, IsDeleted ...
					+ All scalars of a point that are only used for both x and y (e.g. MassFactor) are stored 
					 (and updated, if any) twice, as vec2f (only MassFactor?)
					+ All scalars of a point that are used as scalars (e.g. Buoyancy) are stored once
					+ Test first to see if N buffers make a difference vs 1 larger buffer: 
						+ 1: Do Position, Velocity, Force, and MassFactors first in single Newtonz buffer
							+ Get baseline 1:
								- DoStep: 39.99%
									- Ship::Update: 39.05%
										- UpdateDynamics: 27.42%
											- SpringForces: 20.18%
											- PointForces: 3.77%
											- CollisionsWithSeaFloor: 2.19%
											- Integrate: 1.27%
										- GravitateWater: 5.70%
										- BalancePressure: 4.58%
										- UpdateStrain: 1.03%
								- Render: 51.69%
							+ FPS=24.0/24.2/24.4
						+ 2: Do separate Position, Velocity, Force, and MassFactors 
							+ Get baseline 2:
								- DoStep: 39.01%
									- Ship::Update: 38.01%
										- UpdateDynamics: 27.44%
											- SpringForces: 19.97%
											- PointForces: 3.65%
											- CollisionsWithSeaFloor: 2.24%
											- Integrate: 1.57%
										- GravitateWater: 4.87%
										- BalancePressure: 4.51%
										- UpdateStrain: 0.90%
								- Render: 52.69%
							+ FPS=24.1/24.3/24.7/25.0
							+ Make buffer __restrict
							+ FPS=24.8/24.9/25.1
					+ If makes sense to explode:
						+ Also explode ConnectedComponent
				+ Phase 2: Springs: Points, dynamics coefficients, water coefficients, ...					
				+ Phase 2: Triangles: Points, Network
				+ Phase 2: Change all ElementContainer::ElementIndex into ElementIndex
				+ Structure of buffers:
					+ For SSE2, need to be simple floats
					+ For handling, need to be structured
				+ Buffers are class Buffer
					+ Need to be mem-aligned
					+ cctor(size)
					+ data()/size()/emplace_back()
					+ uq_ptr
			+ They expose buffer getters for each buffer (as the structured type, e.g. vec2f *, or PointNetwork *, or float * for lonely scalars)
				+ e.g. vec2f* GetPositionBuffer()
				+ When needed also exposed as floats as well (e.g. Position, for Integrate())
					+ e.g. float* GetPositionBufferAsFloat()
					+ size math left to caller
			+ When needed, they expose getters and generally operations on single elements, via 32-bit index argument (aliased as ElementIndex)
				+ e.g. void Destroy(ElementIndex)
				+ e.g. float GetMass(ElementIndex)
			+ Destroy(ElementIndex) takes care of telling ship that element count is dirty
				+ Phase 3: set directly in Ship at initiation of Destroy chain, whenever we know we destroy something
					+ Do at Spring::UpdateStrain: returns bool, true if destroyed
					+ Do at tool's Destroy
					+ Then get rid of two-phase ship cctor - plain cctor with moved ElementRepo's
						+ So can also remove move assignment at Points
			+ Pointers to points are replaced by 32-bit indices
				+ Funcs that need to follow pointers (e.g. Destroy() and SpringDynamics()) also must take whole containers 
				+ Phase 2: also pointers to Springs & Triangles
			+ ShipBuilder creates Points & moves into ship
				+ Points' ConnectedXYZ are updated at ShipBuilder time
					+ Remove code from Spring and Triangle and ElectricalElement-Cable-etc. cctors
			+ Do Ship
				+ Loop over indices, invoking Points::GetWhatever(index)
			+ End of Phase 1: FPS=22.0/22.3/22.6
			+ Phase 1.5: check assembly for:
				+ 1: loop over indices, invoking Points::GetWhatever(index)
				+ 2: loop over indices, taking buffers first and then dereferencing buffer with index
				+ RESULT: IDENTICAL
				+ Decide whether to keep bunch of GetWhatever(index) (both R and W) vs buffers
				+ Check also disassembly of index iterator
			+ End of Phase 1.5: FPS=23.2/23.3/23.4
			+ To check:
				+ UpdateDrawForces: see assembly difference for displacement.length() optimization
					+ NO, actually compiler autonomously saves length for later, and explicit
					  code looks a bit different
				+ UpdateSpringForces(): see assembly to check whether point.Force's are updated twice
					+ YES
					+ Update force once with sum of forces
				+ HandleCollisionsWithSeaFloor(): see assembly to check for twice GetPosition()
					+ YES, read once into xmm4 and re-used later
			+ End of checks after Phase 1.5: FPS=24.0/24.2/24.4
			+ Containers expose own Upload(RenderContext &)
				+ Phase 3: direct upload of buffers into GPU via RenderContext
					+ Nuke ShipRenderContext::mPointBuffer & friends
				+ Phase 3: move texture coordinates and colors into Points, which uploads
				  at Upload() via own mAreImmutablePropertiesUploaded state
					+ Nuke Ship::mIsPointCountDirty
					+ Nuke ElementRepository, as at this moment no one should be using it anymore
			+ Phase 3: Nuke PointerContainer
			+ Phase 3: Nuke ShipElement, if it's now only implemented by ElectricalElement
				+ See if managed to not need to tell Ship as well, see above
			+ Phase 3:
				+ Fix power-of-2 calculation at Buffer::cctor()
				+ Fix World::GetNearestPointIndexAt, by making use of Ship::GetPointPosition(idx)
					+ See square root optimization, here and @ Destroy()
				+ Also fix its use at MainFrame, by making use of Ship::GetStuff()
				+ Fix all warnings
		+ Phase 2: Integrate():
			+ After NewtonzBuffer exploded
			+ Test 1: use Points.GetWhatever(idx)
			+ FPS=24.7/24.8/25.0
			+ Test 2: use __restrict pointers
				+ Just simple 1-Point-Component loop, compiler makes times four
				+ Pointers are locally declared as __restrict, and adjusts count (i.e. times 2) and uses
				  indices in pointers
				+ Verify assembly
			+ FPS=24.9/25.1/25.2
		+ Phase 1:
			+ Beginning FPS=19.0/19.4/19.7/19.9
			+ Ending FPS=22.0/22.3/22.6
		+ Phase 1.5:
			+ Beginning FPS=22.0/22.3/22.6
			+ Ending FPS=24.0/24.2/24.4
		+ Phase 2:
			+ Beginning FPS=24.0/24.2/24.4
			+ After exploded Newtonz FPS=24.8/24.9/25.1
			+ Ending FPS=26.3/26.5
		+ Phase 3:
			+ Beginning FPS=26.3/26.5
			+ Ending FPS=26.6/26.8/26.9/27.0
	+ BufferAllocator<Type:vec2f or float>
		+ cctor takes ElementCount
		+ Allocate() returns std::unique_ptr<Buffer<Type>>, with deleter invoking mAllocator->Release(Buffer<type>*)
		+ Points::CheckoutWaterBufferTmp (as "AllocateWaterBufferCopy()") borrows one, copies it in, and returns it as std::unique_ptr<Buffer<float>>
		+ Opposite for Commit() (as "UpdateWaterBuffer")

	+ See if reordering springs according to small tiles helps, instead of according to cache heuristics
		+ Visit point matrix as 2X2 blocks
		+ Add all springs connected to any of the included points (0..4 points), except for already-added ones
			+ Use vector<bool> to remember indices of springs already added
			+ Need un_map<point index->[spring index]>
				+ See if [spring index] could be member of PointInfo
			+ Done like this, it favors springs extending to the right and down


+ Fix 4 BPP images
	+ Need ilCopyPixels to convert to standard format (BPP:3, Format: RGB, Type: U_BYTE)

+ Material::"Electrical" (and "Sound")
+ See if destroy's lack of point allows for water to flow in
+ FileDialog: filters based off image formats that are supported
+ Jelly ball: see orig code for doubles
+ Less ocean depth max	
+ Data/
	+ InitialShip.png [also change @ code]
	+ Materials
+ see if it makes sense that ship::points is set<x, set<y, points>>
+ nuke wxSmith
	+ Verify all is fine afterwards
+ set icon
+ Debug builds: 
	+ Enable /Fp:strict and set fpcontrol via /DFLOATING_POINT_CHECKS	
	+ See if SEH needed (/EHa)

+ Mouse pointer based off current tool
	+ Only on Canvas, normal outside
+ Move IsPaused member out of game controller & parameters; handled by MainFrame via status of mPauseMenuItem
+ DrawAt: the longer it's pressed, the stronger it gets
	+ Requires TimerTick to also update force and invoke DrawTo when l is down and current tool is Draw
	+ Also radius of Smash, same thing
+ Tool strength modulation:
	+ Also modulate cursor (red bar rising)
		+ Build 10 images (and then cursors) off the base image
		+ @ tool application, also call SetCursorStrength(strength, minStrength, maxStrength)
			+ Calculated which one of the (xyzCursors.size()-1) to set, of current tool's cursor

+ Phys rearc:
	+ Confirmed: destroy breaks due to iterator invalidation
	+ In order to allow for ship building unit tests:
		+ static unique_ptr<Ship> Ship::Create(unsigned char const * structureImageData, un_map<vec3f, Material*>)
		+ void World::AddShip(unique_ptr<Ship> && newShip)
		+ Game::LoadShip(filename) still loads the image, and then Ship::Create and World::AddShip
	+ Ship_BuildsFromStructureImage_XXX unit test:
		+ Make structureImageData and verify points, springs, triangles, etc., also indexes & relationships
			+ Might actually want Material::cctor to be public
	+ Destroy unit tests:
		+ Make structureImageData
		+ DestroyAt
		+ Verify points, springs, triangles, etc., also indexes & relationships
		+ Verify crashes in Debug!
	+ Do phys renames and file split above
	+ Verify unit tests (1) & runs normally & no fps regression
	+ Commit & push
	+ Take new perf baseline (FPS and percentages): 8/9
	+ Repository rearc:
		+ PointerContainer:
			+ Flag is via getter (IsDeleted())
				+ Also rename other GetIsXYZ() -> IsXYD() and SetXYD()
			+ RegisterDeletion(): increments counter
			+ ShrinkToFit: 
				+ Only if deletion counter != 0
				+ Allocate new and copy pointer by pointer that's not deleted
					+ assert counts at the end
				+ Fix unit tests (need to register deletion, and add case with no registration but deletion)		
		+ Replace parentWorld with parentShip at all elements
			+ See also if can get rid of accessing World altogether, in lieu of GameParameters or specific parameter(s) of it (e.g. gravity)
			+ Spring
			+ Triangle
			+ Point
		+ Physics::ShipElement<TElement>
			+ Provides IsDeleted()
			+ Has mParentShip * const (set via cctor) and getter
			+ public Destroy()
				+ mIsDeleted = true
				+ mParentShip->RegisterDestruction<TElement>((TElement *)this)
			+ Everything derives from it, publicly
		+ Ship maintains lifetime of points, springs, and triangles in backbones 
			+ Springs: PointerContainer
			+ Others: depends, if fast iterator access in arbitrary order is needed => PointerContainer,
				  else use set (even if never iterated, makes faster deletion)
			+ RegisterDestruction<TElement>(TElement *element): 
				+ For things in PointerContainer: invokes PointerContainer::RegisterDeletion()
				+ For things in sets, maps: invokes set/map.erase(element) // it's a shortcut!
					+ In these cases, mIsDeleted setting is redundant, but heh...
		+ Fix crash at Destroy
			+ Remove all TODOs
		+ Rethink pointer container: it should iterate Element* rather than Element&
		+ New FPS: 11/11/12
		+ Fix disappearing ship
			+ Make PointerContainer Log a Debug afterwards, instead of Info
			+ Nuke all the other TODO's
			+ Run with strict floating point
				+ Disable exc with overflow & verify that's how we get to NaN
		+ Commit & push
		+ See if chunk splitting reprocesses same point twice
		+ See if connected triangles (at point) should also be vector instead of set	
			+ Requires Triangle.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
		+ Test mAllTriangles in PointerContainer
			+ Should make faster render:
				+ Before: FPS with pause=18/19
				+ After: FPS with pause=19
			+ If not good, undo - KEPT!

		+ Try Adjancency rearc:
			+ Commit and push first
    			+ Each adjacency arc exists for each non-hull spring, and lives as long as the spring lives;
			  we might then get rid of these and just visit the non-hull springs,
			  provided that we adjust GravitateWater and BalancePressure for the fact that each arc 
			  would now be visited only once
			+ However, for electrical elements we still want to visit the spring-connected graph,
			  regardless of hull-ness this time;
			  we then want each point to know its N attached springs (arcs), which
			  we maintain as a vector<Spring *> (there's max 8)
				+ Actually: FixedSizeVector<TElement, Size>, w/erase that shifts and returns bool
				+ Remove: use vector::erase(std::remove(val)), or self-done for just one
				+ Adjust GravitateWater and BalancePressure for the fact that each arc 
			  		is now visited only once
					+ GravitateWater: change to visit springs, and do realize that one of the points 
					  always has cos > and the other cos <
					+ BalancePressure: for each pair in which one has water > 1.0, do delta
					+ Don't take shortcuts, and add comments about this
				+ Point: expose same API as triangles
				+ Spring:
					+ cctor adds itself to its endpoints
					+ dctor removes itself from its endpoints
					+ Make sure it's the same code as triangles
					+ Then remove code from Ship construction
				+ Replace adjacencymap visit with spring visit (of non-hull only)
				+ Remove ship.adjacencymap
				+ Requires Spring.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
			+ Then see if Point->Destroy() can avoid enumerating all springs to find the ones affected
				- Check speedup
		+ x::Destroy()  // Removes all references to self that are found in counterparties
				// Invokes Destroy() on counterparties it "owns" (e.g. Point->Spring)
				// Basically: replaces dctors (which now have to go away)
				// Then, calls base ShipElement::Destroy()
		+ At the end of each Update(), Ship calls shrink_to_fit on owned pointer container(s)
			+ Also removes points et al that were deleted on previous DestroyAt()
		+ Remember to exclude IsDeleted() things during enumerations!
			+ And assert(!IsDeleted()) when it's impossible the're deleted (e.g. if accessed via relationship that should
			  have been cut if that element was deleted)

	+ Remove TODO's from unit test and verify (2) & runs normally & no fps regression
	+ Complete unit tests with all new relationships
	+ Commit & push
	+ Take new perf baseline (FPS)

	+ Final refactor physics:
		+ No friends
		+ Clear all warnings
		+ Args by ref - no vector copies!
		+ phys getters (e.g. point.GetColour()) inline
		+ Make other inlines
		+ Fix include files	
		+ Formulas optimizations
			+ Point forces: gravity may be applied twice with different magnitude but same vector
		+ gameparams/world::(waterpressure, strength, ): are these "factors" or "global" really?
		+ See if FP:fast really makes a difference (Release only)
		+ All TODO's
	+ Commit & push
	+ Verify unit tests & runs normally & no fps regression
+ Menu entry to reset pan and zoom
+ Get rid of unicode
	+ Can, really?
+ Add splash screen


+ UI:
	+ Smooth pan and zoom
		+ Takes 1 sec to get to final value (which is stored immediately as real value)
	+ Zoom: inverse
		+ 0 - 1000
		+ Renderer::ZoomToWorldY(zoom) == 70/(zoom + 0.001)
		+ Also called by GameController's Screen2World 
			+ also move GameController's Screen2World implementation to Renderer
		+ See if needs to be exponentially-slider'ed as well
	+ Settings:
		+ Strength Adjustment must be settable exponentially (slider=>exp)
			+ Formula done by gamecontroller at AdjustStrengthAdjustment(), or by SettingsDialog directly
	+ Page up and page down in menu
	+ Ship name in title
		+ MainFrame implements OnShipLoaded() and OnGameReset(), populates mShipNames vector with ship names, and calls SetTitle()
		+ SetTitle appends Utils::Join(vec<str>, ' + ') to current title
	+ Radio: draw points, springs, structure, texture
		+ (Bit) Flag @ GameController->RenderContext->Ship
			+ Inspected as bit glag by Ship as well @ Render() to avoid useless uploads
		+ Larger points
		+ SettingsDialog
			+ Better grouping, see RadioBox?
	+ Space bar for pause
		+ When pause, also pause sounds and music
	+ MainFrame: AboutDialog is member & shown on demand
	+ Make stiffness adjustment
		+ Points::SetStiffnessAdjustment(stiffnessAdjustment):
			+ Called by Ship at each Update()
			+ If != last, recalc coefficient/s
	+ Set max and min zoom (or monsters awaken when you zoom out too much)
	+ Reset view (ESC) should also reset camera pan
	+ SettingsDialog: bomb blast radius
	+ SettingsDialog: 
		+ Break into N Liner/ExponentialSliderControl
			+ Init'd with:
				+ CurrentValue
				+ Max and Min
				+ std::function for OnValueChanged(float newValue)
		+ Find solution to ugly slider value rounding
			+ Calc tick_size == (Max-Min)/100, floored to round float increment ... see doc'n on floats
			+ Then calc # ticks == floor((Max-Min)/tick_size)
		+ Re-set default values to round values
	+ Tool cursors: cursor should change when mouse down
		+ Remove up and down from hierarchy - no cursors in hierarchy (other than mCurrent), and ModulateCursor()
		  takes vector
		+ Do own up and down at:
			+ Smash
			+ Grab (times 2: positive and negative)
		+ Pin, instead, does not change
			+ Undo its dual cursors
		+ ToolController class, called directly by MainFrame
			+ Has GameController shared_ptr
			+ SetTool(tool enum from ToolController)
			+ OnMouseDown/Up/etc.()
			+ RC Bomb detection via events is still left to MainFrame
			+ Tool class:
				+ ToolController has pointer to the current tool; might be null
				+ ShowCurrentCursor(): shows the current cursor; invoked by ToolController at end of initialization
				  to show the first cursor, and might be invoked via ToolController by MainFrame in the future
				  to re-show cursor after having stolen it
			+ Test:
				+ Shift up and down detection
	+ View control smoothing: test with restart from last target for faster convergence
	+ Up MaxStrength
	+ See why waves change when settings dialog is opened and closed
		+ Problem with ocean depth: value on exit looks like current - min == 180
		+ First of all, need to set slider ticks based on current values upon opening of dialog
		+ Then, see if floor at linear control should be round
	+ Fix ambient light increments
	+ When wind is zero waves don't move - need to change wave height and phase separately	
	+ Changing the height of the bumps of the ground
		+ Allow the minimum seabed height to be 0
	+ Being able to drop the sea floor much further down than 500m or so too, like 10km
	+ World settings: number of clouds, wind
	+ SettingsDialog: also sound options
		+ Turn on/off sinking music
		+ Stress sounds on/off
		+ Break sounds on/off
		+ Two volume controls for music and sounds (all but music)
	+ ShipLoadDialog: revised FileDialog for loading ships showing previews of ships (*)
		+ ShipPreview
			+ <scaled ImageData, ShipMetadata>
			+ Loaded like ShipDefinition, taking width (from dialog)
		+ ShipPreviewPanel
			+ Now empty
			+ SetDirectory(std::filesystem::path)
				+ Just log for now			
		+ ShipLoadDialog
			+ Directory tree on the left
				+ https://docs.wxwidgets.org/3.0/classwx_generic_dir_ctrl.html
			+ PreviewPanel in main area
				+ Figure out size math and number of cols
			+ void Open()
				+ Load vals from UIPreferences
				+ Call ShipPreviewPanel::Open()
					+ Start thread
				+ Then, call ShipPreviewPanel::Close()
					+ Stop thread
			+ Resize:
				+ Set min size for dir tree and for preview panel
			+ Combo:
				+ Last N from UIPreferences
				+ OnSelection:
					+ Tell DirCtrl
						+ See if it generates DirSelected event
						+ If not, tell also PreviewPanel
				+ Nothing to do with current dir
			+ When dir tree chooses, call ShipPreviewPanel::SetDirectory
			+ When ship is loaded, call UIPreferences::AddShipLoadDirectory
			+ No use as modal, do with Open() which returns opt<path>
			+ Hitting OK with preview just selected
		+ UIPreferences
			+ Created by main frame and passed around as shared_ptr
			+ Loads and Saves to uncustomizable file path
			+ Also has defaults, as initialization values set at cctor
			+ cctor:
				+ Set defaults
				+ Load
					+ No exceptions, if anything broken => keep defaults
					+ Filter and keep only existing paths
			+ dctor:
				+ Save
					+ No exceptions, if anything broken => silent
			+ AddShipLoadDirectory:
				+ Check if already there
					+ If yes: move first
					+ If not: add first
		+ ShipPreviewPanel
			+ Thread
				+ Figure out how to hook Show()
			+ Redo with custom events for thread-to-panel
			+ Other thread messages
		+ ShipPreviewControl
			+ Catch double-click event and fire ShipFileSelectedEvent
				+ ShipFileSelectedEvent registered to by ShipFileDialog, which uses it as "Ok"
			+ Trim at load
			+ Show:
				+ Name
				+ Dimensions: 
					+ Metres: "160 m"
				+ Year
					+ Fill-in years @ ships
				+ Author
			+ Border when selected
				+ See wxPanel border
				+ If doesn't work, try DC
				+ If doesn't work, try Matrioska
		+ Cleanup source/Ships directory (make .dat's)
		+ Test:
			+ Super-minimize
			+ Image preview hits selection border? No
			+ ShipLoadDialog does not catch ShipFileChosen event
			+ Closing dialog when still loading images does not resume loading upon open
				+ ...and now test changing dir back to orig one while thread is loading
			+ Ugly flickering at re-open
				+ See if can avoid refreshing when not visible
				+ Due to Yield? No
			+ Run under debugger to see if there are assert's
		+ Test on two other Windows'
	+ SettingsDialog: tooltips at Simulation Quality (tradeoff) and Stiffness (instability)
		+ Use "Attention" icon
		+ wxToolTip
		+ SQ: Higher values improve the rigidity of simulated structures, at the expense of longer computation times
		+ S:  Higher values cause physical instability but provide for a nice effect!
		+ See if global settings are really needed
	+ Menu entries for "Home Page (GameJolt)/Code Page (GitHub)"
		+ wxLaunchDefaultBrowser
	+ SettingsDialog: add tooltips at each setting (*)
		+ Explanations and units
		+ Do on panel, slider, label, and textbox
			+ Or remove tooltip from icon altogether, do just standalone panel tooltip & standalone icon w/no tooltip
		+ Do also on various checkboxes in SettingsDialog

+ Gfx:
	+ Do ropes with two endpoints (000xxx)
		+ Throw exception if doesn't find two endpoints
		+ Algo: 
			+ Step 1: build vector<PointInfo> & Matrix<opt<pointIndex>> & vector<RopeInfo>
			+ Step 2: visit RopeInfos and add to PointInfo's and SpringInfo's
			+ Step 3: visit PointMatrix & ...
		+ Starting perf:
			+ Default ship: 14.1/14.3
			+ Ropes test: 12.2/12.3
		+ Need to always use color when rendering springs:
			+ Spring::Type (Hull, Rope)
				+ No exposed, just IsHull() & IsRope()
				+ Make it a bit flag
			+ Separate RenderContext method for Ropes, stored in separate Element (RopeElement, structurally == SpringElement)
				+ Upper bound for # of spring ropes given # of points in connected component:
					+ N
					+ Upper bound of 'normal' springs doesn't change
			+ Render: draw ropes after springs and triangles (we want them on top of triangles!), still by connected component
				+ Use own program
		+ Ending perf:
			+ Default ship: 14.2
			+ Ropes test: 12.3
		+ Don't make triangles of 3 rope points if at least one is connected to ropes only
			+ Fix Base III?
		+ Flip order of rendering when structure: triangles first, then ropes
			+ Need private subparts of Render()
		+ Ending perf:
			+ Default ship: 14.5
			+ Ropes test: 12.3
		+ Add ropes to Titanic
			+ Make wood non-hull
		+ Fix unit tests
		+ Make max(fixedSizeVector) == 9
			+ Not for triangles - generated rope points will never participate in triangles
		+ Material/Rope rearc:
			+ MaterialDatabase
				+ Loads itself from json
					+ From ResourceLoader invoked by GameController at init'n
				+ Guarantees:
					+ Exactly one material with isRope=true
					+ Color is #000000
					+ No colors clash, and no colors fall within rope range
				+ Replace in GameController, ResourceLoader
				+ Remove ropeMaterial kung-fu @ Ship::Create and use material->IsRope
				+ GameController also gives rope renderColour to RenderContext at cctor
					+ Which sets shader's hardcoded parameter
	+ Try light diffusion rearc:
		+ No more at C++, but rather in OpenGL as in the following example (written for ShipTriangles only but valid also for springs 
		  and points):
			+ Prerequisite: draw ship triangles by connected component (see above)
			+ Turn off diffusion
			+ For each component: pass array of all lamps in that component; each lamp has {x, y, intensity};
			+ Draw each connected component N times (use additive blending), once for each lamp, 
			  each time passing the single lamp properties as uniform to shaders, 
			  which calculate distance and do final light blending
				+ Check right way of doing blending
		+ REJECTED: perf was awful; this multiple-pass way of doing it hurts too much

	+ Texture mapping:
		+ UploadLandAndWaterStart()/./End()
			+ Just specify land y and water y
			+ Impl:
				+ y:
					+ To LandBuffer
					+ To WaterBuffer
			+ RenderLand()
			+ RenderWater()
		+ Land (sand)
			+ bottom is not anymore a param but it's filled by RenderLadn(.) with +/- mWorldHeight/2
				+ only param is x and y (world y)
			+ texture coordinates are world coordinates
			+ Magic number is based on desired tile world size
		+ Water
			+ Use "water transparency" uniform in shader that sets alpha value in result of texture
			+ Make texture stretch wrt vertical height of water strip
			+ Change map, this one's ugly
		+ Clouds
			+ Use N textures, each has own rectangular size
			+ RenderContext loads all available textures and uses them for the clouds, modulo
				+ ResourceLoader::LoadTexturesRgba(prefix)
					+ initProgressSink lambda 
			+ GameParameters.NumberOfClouds (constants)
			+ World takes numberOfClouds and allocates clouds buffer with random values
			+ Then, RenderContext::RenderCloudsStart()/./End()
				+ Buffer contains virtualX and virtualY, and scale
				+ RenderContext::RenderCloud() makes rectangles (in world coords) based off formula
			+ Clouds stencil: 
				+ Draw waterbuffer without texture, but reverse stencil op
		+ Ship, using second image
			+ Load ship == image or .shp (JSON)
			+ First, try naively with just point colors
				+ Doesn't work, as structural image has too little resolution
			+ RenderContext is given optional texture image (by GameController) via
			  RenderContext::AddShip(iShip, opt<ImageData>)
			  + Requires RenderContext::ResetWorld()
				+ Simply clears vector of ShipRenderContext()
					+ ShipRenderContext contains everything ship-related
						+ Rename springs and triangles to "Elements"
						+ Touch points with outside world:
							+ Parameters (booleans, render factors)
							+ OrthoMatrix
							+ Helpers
				+ No need to reset others (land, water, clouds) as their numbers, positions, and data will be given
				  at the next Render() from scratch
					+ But it could easily by re-creating uq_ptr<XYZRenderContext()>
				+ Call from GameController
			  + Adds ship with opt<ImageData> in arg
				+ If specd, cctor creates <OpenGLTexture mElementTexture> and uploads immediately
				+ mShipTextureCoordinatesVBO and other texture machinery is created at startup anyway (if any)
				+ No need for std::optional<ImageData> TextureImageData
			  + Remembers if ship has texture via mElementTexture
			  + Catch exceptions at all interactions of MainFrame with GameController, and display DialogBox
			  + ResourceLoader::LoadShipDefinition: need to make paths abs wrt .shp path
			  + Refactor to World::CreateShip() -> ID -> Ship::Create()
			  + Land and Water texture names: do own, not from array
			  + Always unbind texture2d after a render
			+ Also, later, RenderContext is also given textureCoords,
			  i.e. a buffer of texture X's and Y's (i.e. initial points' coords) for
			  each of the ship points (i.e. aligned with the point buffer which will be continuosly uploaded)
			  + TextureCoords created by Ship::Create (always), stored into Ship, and given to RenderContext
			    (which uploads it, always) once and for all at the same time as colors (i.e. when IsPointCountDirty)
			+ If a texture is associated with the ship, RenderContext uses a different shader for ShipTriangles
			+ Krafting:
				+ Y offset for initial drop
				+ Remove one layer of hull from bottom, but see how much it bends afterwards

	+ Draw stressed springs with their own hardcoded texture (1D, 3 pixels: red, red/white, red) of a reddish line with "hot" centre
		+ https://stackoverflow.com/questions/17866308/texture-a-line-in-opengl
		+ Make it a 2D with semicircle around T,L corner
			+ textureCoords are inputPos
	+ Fix springs showing up around texture from structure
		+ Make test .shp with three masses and a rope
	+ Draw points:
		+ Ship uses RenderContext::UploadPoint(elementIndex), only for !deleted points
		+ Then, glDrawElements(GL_POINT)
		+ Nuke PointProgram as it's dupe now
	+ RenderContext:
		+ Get rid of pre-generated texture names and create on-demand
			+ Test!
		+ See if can describe point, color, and texture VBOs at init
	+ Should draw each connected component at once
	+ ShipTexture: Experiment with different min/mag filters
		+ Try mipmaps, should help make the Titanic artifacts disappear
			+ OpenGLGame::UploadMipmappedTexture(imageData) -> void
				+ Does base and all the dimensions down to 1x1, using floored extents
				+ Algo: take avg of each square of points, including alpha
			+ Use GL_LINEAR_MIPMAP_LINEAR
			+ See https://www.khronos.org/opengl/wiki/Texture
			+ Then nuke ImageData stored in RenderContext's
			+ Use at:
				+ Ship
				+ Remove from Land? Test w/out and see if border
			+ Test perf
	+ VectorField rendering
		+ Final cleanups:
			+ Check all vector fields wrt deleted points
			+ RenderContext: initialize vector render mode to None
			+ Make vector field render mode changeable in SettingsDialog, Render tab
			+ Add length adjustment as render parameter, multiplied by RenderContext before passing to ship
				+ No dialog adjustment needed yet
	+ ShaderManager
		+ WetColor, LightColor: make them static hardcoded params
		+ Use in and out, and 130
		+ Replace all shaders
			+ RenderContext
				+ Use "in" as prefix of inputs
				+ glEnableVertexArrays: all at top, as they have nothing to do with VBOs
					+ ShaderMgr enables all the used ones
					+ Ship/RenderContext Code only disables zero when it's not used
			+ ShipContext
				+ Ship/RenderContext code only disables zero when it's not used
				+ Remove unnecessary bind's for VBO's that source dedicated attributes
		+ Get rid of vector_arrows shader, use matte
			+ Will need to re-bind attribute (GenericPosition or VectorPosition=0) to vectors VBO
			+ Deep cleanup
				+ enums
				+ shader
		+ Replace glBufferData with glBufferSubData when size does not change; at Ship only:
			+ Point positions, color, water
			+ Check perf before and after:
				+ Pre: 26.6
				+ Post: 27.3
	+ Fullscreen:
		+ ESC to go out, menu option/F11 to fullscreen again
		+ Add to changes
		+ Text at RenderContext
			+ Do Render:: move
			+ Render::Font
				+ Loads itself like TextureDatabase, with IProgress
				+ Owned by Render::TextRenderContext, created at cctor
					+ Render::TextRenderContext owned by Render::RenderContext, which fw's all calls to it
				+ Has method to calc pixel size given char* and size_t
				+ Has method to append vertices given char* and size_t
					+ Returns # of vertices appended
			+ TextRenderContext
			+ TextLayer:
				+ Owned by GameController, which FW's to it
				+ SetEnabled(bool)
			+ Debug:
				+ glCheckError macro at GameOpenGL.h
					+ Make it inline
					+ Use it at RenderContext and ShipRenderContext setup and rendering, instead of various checks
			+ Cleanup Font.h
			+ Add & change StatusText font
			+ See response to Toggle Status Text
			+ Do better initial text (invoke at MainFrame cctor)
			+ Update AboutBox and tell guy
			+ Check perf
			+ Perf optimizations:
				+ Precalcd stuff in FontMetadata, indexed by char
	+ Option to enable drawing of force vectors for each point
		+ Ship::Update() takes also RenderContext const &, so can check if need to save force buffer
			+ Points::SaveForceBufferForVectorRender()
		+ Copied right before integration
	+ Orphaned points (*)
		+ Idea: always draw orphaned points - those that come after destruction
		+ Orphaned point == points with 0 connected springs
		+ We unify ephemeral points uploading and rendering with ship points (either debug or orphan) uploading and rendering
			+ Plane ID is enough to keep them on separate planes
		+ Verify first that connectivity visit really assigns plane IDs also to orphaned points 
		+ Impl:
			+ We must first stop deleting points just because springs are deleted
				+ Though should still delete them at Destroy() and Bomb(), for example
			+ Unify non-ephemeral and ephemeral points in element VBO
				+ Need hint from Points on whether or not ephemerals will follow
			+ ShipRenderContext:
				+ Nuke RenderEphemeralPoints and its structs and members
				+ Have just one single RenderPoints
					+ Always invoked, except when DebugShipRenderMode is not None and not Points
					  (i.e. when it's Springs, EdgeSprings, etc. but not Points)
		+ Test L'n'F'
		+ Cleanup:
			+ Ship: generation of air bubbles: atm we don't generate air bubbles for orphaned points; see if this should change instead

+ Gfx Optimizations:

	+ Try without buffer population: 			
		+ Point has vec2f * const mPosition and vec2f * const mColour, pointing into two fixed buffers
			+ vectors are packed (static_assert on contiguous 2 or 3)
			+ Point does not live in PointerContainer but in std::uq_ptr<Point>[]
				+ Delete does nothing (Destroy does relationships though), just marks it
		+ Point also has mElementIndex, queried by springs and triangles when rendering themselves
			+ Can make Ship::Render const again, then
		+ Pointers to fixed buffers (as arrays of vectors) are owned by Ship and
		  are given by Ship to RenderContext at each Render via 
		  RenderContext::UploadVertices(vec2f*, vec3f*, count)
		+ RenderContext usage of two buffers at each DrawElements:
			glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
			glVertexAttribPointer(vertexPositionAttribute, 3,  GL_FLOAT, false, 0, 0);
			glEnableVertexAttribArray(vertexPositionAttribute);
			glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);
			glVertexAttribPointer(vertexColorAttribute, 4, GL_FLOAT, false, 0, 0);
			glEnableVertexAttribArray(vertexColorAttribute);
		+ Point's vector pointers are populated by Point::Rebase(buf1, buf2),
		  invoked by Ship at construction
			+ Rebase() uses mPointIndex (rename of mElementIndex) to calc pointers
		+ Try: could also use buffer with mLight and mWater (uploaded each time to GPU as well) to be used by V->F shader 
		  to blend fragColor with two fixed colors (water blended before ambient light, light after)
			+ F shader needs to start doing ambient light now, rather than point
			+ Need Point::CalculateWaterColorIntensity() (clamps and copies mWater to buffer), 
			  and a dummy Point::FinalizeLightColorIntensity() (dummy because mLight is already finalized)
			  + or do clamp in shader, so use mWater and mLight straight from buffer, no CalculateX() needed
			+ If we put light and water in shader, then we don't need to reupload color buffer each time
		+ Bonus: also test GPU interpolation of mLight and mWater by emitting them at vertex
	+ Plan:
		+ 0: Test with additional mLight and mWater uploaded to RenderContext (same Point struct), and fragment shader doing math
			+ F Shader needs params: ambientLightIntensity; constants: waterColor, lightColor
			+ Remove point color calculation
			+ Check perf:
				+ Before: 16
				+ After: 14.1
				+ Keep in mind that we're adding to the buffer, while later we'll remove the colors
			+ Also test bonus: GPU interpolation of mLight and mWater by emitting them at vertex				
		+ 1: if OK: PointCore struct (@GameLib) with {position, light, water}, based into Point
			+ Separate color buffer: 
				+ Color struct (vec3f) has static_assert's for alignments
				+ Created by Ship::Create(), moved into Ship member (ElementRepository<vec3f>)
				+ Uploaded one-shot at first Ship::Render()
					+ via RenderContext::UploadShipPointColors(vec3f *, size_t elementCount):
						+ Uploads to GPU right away, with GL_STATIC_DRAW
						+ Stores size (mShipElementCount) for later assert
			+ Check perf: 14.2
			+ Commit 
			+ Separate PointCore buffer:
				+ PointCore struct has static_assert's for alignments
				+ Created by Ship::Create(), moved into Ship member (ElementRepository)
					+ Points have already been based, at cctor by Ship::Create()
				+ Uploaded at each Ship::Render()
					+ via RenderContext::UploadShipPoints(PointCore *, size_t elementCount):
						+ Asserts size same as color buffer (mShipElementCount)
						+ Then uploads to GPU right away, with GL_STREAMING_DRAW
		+ Final:
			+ Nuke Point::CalculateColour
			+ Also do light/water color blending at ship *point* fragment shader
	+ Only keep separate color buffer and water/light done in F shader; point disembodiment was not a good idea

	+ Pack vertex attributes @ other shaders:
		+ clouds
		+ text_ndc
		+ FPS: 28.2/28.4

	+ Reduce # of bind VBO calls by delaying upload of buffers we own until we bind the VBO for drawing
		+ Land at RenderContext::UploadLandAndWaterEnd/RenderLand
		+ Also disable vertex attribute index zero once
		+ Test all ship shaders with 2 connected components
		+ FPS: 28.5

	+ Use MapBuffer when we know the sizes in advance, eventually re-allocating GPU buffer when the size changes
		+ Clouds
			+ Rename middle "RenderCloud" as "UploadCloud"
			+ Rename SharedAttribute1 as SharedAttribute0, et al
		+ Land, Water
			+ Also make clouds, land, and water use disjoint vertex attributes, so can bind once at each XYZStart()
			  before mapping buffer (and subsequently describe, when needed)
			  + Water, matte_water: use vec3 WaterAttribute
				+ Shaders
				+ RenderCore
				+ Description, once at initialization
				+ Disable 0 before running program
			  + Clouds: use vec4 SharedAttribute0
				+ Shaders
				+ Bind, allocate, and map at RenderStart()
				+ Description at Render() after unmapping buffer
				+ Enable 0 before running program, after description as usual
			  + Land: use vec2 SharedAttribute1
				+ Shaders
				+ Bind, allocate, and map at RenderStart()
				+ Description of SharedAttribute1 at Render() after unmapping buffer
				+ Disable 0 before running program
		+ FPS: 28.1/28.3/28.4
	+ Now, compare with replacing MapBuffer with BufferSubData
		+ Copy exe first
		+ Just this:
			+ Replace mXYZMappedBuffer with std::unique_ptr<XYZ[]>
			+ (Re)allocate buffer whenever we (re)allocated GPU buffer
			+ Remove MapBuffer call
			+ Replace UnmapBuffer call with BufferSubData
		+ FPS: 28.2/28.3/28.4
	+ Get full perf, including other laptops
	+ Texture atlas:
		+ Spec:
			+ Atlas is built on-the-fly, completely independently from texture DB, via a separate
			  component (TextureAtlasBuilder) that is given multiple TextureFrame's and eventually spits out TextureAtlas
			+ TextureAtlas:
				+ Contains:
					+ image: consumed by GameOpenGL helper for mipmapping
					+ metadata: used by GameOpenGL helper for mipmapping, owned by RenderContext (for clouds, land, and water) 
					  and (by reference) by ShipRenderContext (for GenericTextures)
				+ Structure:
					+ ImageData Texture
					+ TextureAtlasMetadata Metadata:
						+ TextureAtlasFrameMetadata:
							+ box in atlas (i.e. texture coords, as 2xvec2f)
							+ TextureFrameMetadata
						+ vector<TextureAtlasFrameMetadata> / anything else addressable via TextureFrameId (see above)
			+ Separate mipmapper helper in GameOpenGL takes ImageData (by move) and TextureAtlasMetadata
		+ Impl:
			+ Phase 1: Clouds
				+ TextureAtlas
				+ ResourceLoader::SaveImage
				+ Resize all clouds to powers of two
					+ Test look & feel
				+ RenderContext: 
					+ Cctor: create atlas and add just Clouds
					+ Upload texture - w/no mipmap for the time being
					+ Store Metadata (by value) and handle
					+ Use Atlas metadata at UploadClouds()
				+ Test 1
				+ Get rid of need to use TextureRenderManager at RenderContext for clouds
				+ Draw all clouds together at once
					+ Need triangles
				+ RenderContext:
					+ Call GameOpenGL mipmap helper moving Texture and passing Metadata
				+ Test 2
					+ FPS: 28.5/28.6/28.7
			+ Phase 2: Generic Textures
				+ Resize all generic textures to powers of two
					+ Pin
					+ RC Bomb
					+ RC Bomb Ping
					+ Timer Bomb
					+ Timer Bomb Defuse
					+ Timer Bomb Explosion
					+ Timer Bomb Fuse
					+ RC Bomb Explosion
					+ Timer Bomb Explosion
					+ Test look & feel
					+ Fix timer bomb issue
				+ Fix texture coordinates in atlas to be between 0.5/dim and 1-0.5/dim
					+ Test it first simply at current generic texture upload
					+ See Moleskine
					+ Do in atlas UV coordinate generation
				+ RenderContext:
					+ Cctor: add entire database to atlas minus land and water
						+ Make builder stateful
					+ Pass Metadata and texture handle to ShipRenderContext
					+ Bind:
						+ Atlas before clouds
						+ Land, Water before land and water
				+ ShipRenderContext must take from RenderContext:
					+ Atlas texture handle (&), for binding it at GenericTextures
						+ At least until we do Z and GenericTextures moves up to RenderContext
					+ metadata (&)
				+ ShipRenderContext:
					+ Bind atlas at GenericTextures
					+ Use box in atlas at Generic Textures upload
					+ Modify GenericTexture to run once for all textures (still for each connected component until Z)
						+ Populate quads directly in connected component GenTexElement vector
							+ Make room as needed (emplace_back)
							+ Store max size among all connected components in SRC member
						+ Upload connected component GenTexElement vector at RenderGenericTextures()
							+ Realloc buffer if new max size != m allocated max size
							+ Then always BufferSubData
						+ Test with multiple connected components
					+ Nuke TextureRenderManager member and cctor arg
					+ Cleanup RenderContext's upload of textures				
			+ Remove test saving of atlas
	+ Figure out what's most expensive with perf analysis and noinline
		+ Only triangles: 42fps
		+ Triangles and ropes: 42fps
		+ Only springs: 32fps
		+ Is it stenciling, flushed at Ship::RenderEnd()?
			+ With no stenciling: FPS: 29.4/29.5
	+ Enable stenciling only when needed
		+ FPS: 29.0
	+ Try Render1/Update1/Render2/Update2
		+ @ GameController and down
		+ No improvements
	+ All textures: test changing GL_LINEAR_MIPMAP_LINEAR to:
		+ GL_LINEAR_MIPMAP_NEAREST
		+ At:
			+ Land and Water
			+ Atlas
	+ In texture or structure mode, draw only springs that are visible
		+ i.e. springs with # of triangles < 2
		+ Impl:
			+ Springs:
				+ New buffer: SuperTrianglesCount - type: ElementCount
					+ Publicly exposed
					+ Populated via argument at Springs:Add
						+ Calc'd by ShipBuilder via Triangles below, during component springs discovery
					+ Decremented via Springs::RemoveSuperTriangle() // no args
			+ Triangles:
				+ New buffer: ComponentSprings - type: std::array<ElementIndex, 3>
					+ Publicly exposed
					+ Populated via argument (of type std::array<ElementIndex, 3>) at Triangles:Add
						+ Calc'd by ShipBuilder
					+ Never changed
					+ Used by Ship::TrianglesDestroyHandler() to decrement count for each component spring
			+ Triangle destroy: remove self from springs
			+ Springs destroy: remove self from super triangles
			+ ShipBuilder:
				+ Adjust to new
				+ Also take care of traverse springs
			+ New ShipRenderMode: EdgeSprings only
				+ ShipRenderContext: treated exactly like SpringsOnly
				+ Springs::Render: used to decide what to upload
			+ Springs::UploadElements: in all modes except SpringsOnly, upload only springs with # of super triangles < 2
				+ Re-enable TODOTEST code
			+ Ship::Render() has to remember what ShipRenderMode was used last time, so to consider elements dirty
			  also when ShipRenderMode has changed

	+ See if can use multiple texture units
		+ Bind once atlas, land, and water at cctor, to each unit
		+ Change shaders to have one single texture sampler param, and set uniform locations to texture unit
		+ Do only for clouds, generic texture, land, and water
			+ Revert RenderContext.cpp, ShipRenderContext.cpp, TextRenderContext.cpp
			+ Fonts and ship stay as before, they use texture unit 0 - SharedTexture
			+ Shaders
			+ Remember to activate texture unit 0 before binding, at:
				+ Ship texture, stressed spring texture, font
		+ Fix: land, generic
		+ : test
		+ Replace calls to glActiveTexture with ShaderManager::ActivateTexture(parameter)
		+ Fix/Recheck progress bar
		+ Redo perf FPS measurement
	+ Z buffer:
		+ Rationale: more connected components => slower (multiple batches); try to draw one single batch then, using Z buffer and depth test 
		+ Spec:
			+ Assign Z based on cousin of connected component ID (named "Plane ID", uint32_t)
				+ All points have PlaneId
					+ Can we revert ShipId and ConnectedComponentId to start from zero and having None=max? 
						+ Yes, no one used NoneConnectedComponentId
						+ When we need stuff on top we can always use member variable with max plane ID and/or the total 
						  count of ships 
						+ If so, Plane ID starts from zero
					+ Own buffer (it'll have to be uploaded to GPU)
				+ Points that belong to a connected component also have ConnectedComponentId
					+ What doesn't have a ConnectedComponentId?
						+ ConnectedComponentId is used for:
							+ Frontier (possibly?)
								+ In this case we don't want to assign them to "cables" (0-triangle edges a.k.a. 
								  0-SuperTriangle springs), nor to standalone points
							+ ForceFields that spring from a point
								+ But we can get rid of this and just explode all over the place, after all
								  explosions travel through air
							+ Not by light diffusion algo, see below
					+ We keep ConnectedComponentIds for future use, but do the frontier-type propagation, i.e.
					  we don't propagate them through "cables" nor assign them to standalone points; all of these 
					  won't have a ConnectedComponentId at all
					+ So, what doesn't have a ConnectedComponentId?
						- "strings"
						- standalone points
				+ Assignment of PlaneId is done via the same connectivity visit used for assigning ConnectedComponentId's,
				  but we assign "single-spring paths" to the origin's PlaneId and don't propagate to solid body again
					+ So we draw as separate two pieces that are connected solely by a "cable" (**)
					+ Also rope triangles must be assigned to the origin's PlaneId
					+ Propagation algo: don't propagate if coming from a spring with zero SuperTriangles to a spring
					  with >0 SuperTriangles, unless these are all rope triangles
						+ New "IsRope" property of Triangle, pop'd by ShipBuilder; new buffer
				+ Light diffusion algo follows PlaneId's, instead of ConnectedComponentId's, as it's really about planes
				+ We assign Z after orthomatrix - in NDC - and thus positive is near
			+ We only enable Z test and writing to Z buffer at RenderContext before doing ships
				+ And later, if we move GenericTexture to RenderContext, also when we do generic textures
		+ Figure out range of Z:
			+ World: -1000 -> -1  ==> NDC: +1 -> -1
			+ We assign Z after orthomatrix - in NDC - and thus positive is near
			+ After matrix it's NDC: [-1, +1] (far, near)
			+ When given to fragment shader it's [0,+1], but we don't care anymore at this moment, as we calc Z in vertex shader!
		+ Mapping of <ShipId, PlaneId> to Z in NDC:
			+ Normal: ShipId=0 and PlaneId=0 are furthest
		+ Plan:
			+ Branch
			+ Preliminaries:
				+ Test explosions without connected component ID constraint; if ok, eradicate connected component IDs
				  from ForceFields
				+ Test perspective with hardcoded z=-1 at triangle shaders and z=-999 at springs, and see if it makes any difference
					+ Undo afterwards
				+ Do test images:
					+ Get problematic # of CC's first, with AM bomb on Titanic: 6,000
					+ ConnectedComponentsTestShip1: 8192 CC's, 33280 points, 49152 springs
					+ ConnectedComponentsTestShip2: 1 CC, 36588 points, 47882 springs
				+ Get initial perf:
					+ Default: 30.8
					+ ConnectedComponentsTestShip1: 3.10
					+ ConnectedComponentsTestShip2: 11.6
			+ Step 1:
				+ Add "PlaneID"
					+ GameType
						+ Same integral type as ConnectedComponentId
						+ Change ShipId, ConnectedComponentId, PlaneId to start from zero and have None=max (see @Spec above)
					+ Points: new buffer
				+ Points: add connected springs' "other endpoint"
					+ As part of Network
					+ Test fixed_size_vector::erase_first with/lambda
						+ Check assembly with unit tests
					+ Populated by whatever populates ConnSprings now (ShipBuilder or Points::Add)
					+ Nuke Springs::GetOtherEndpointIndex
					+ Write off work item from elsewhere in this file
				+ Run in debug and validate
					+ Revert to Render::uploading ConnCompId's 
					+ Test crash w/Goliath
				+ Check perf
			+ Step 2:
				+ Connectivity visit:
					+ New PlaneId propagation (see @Spec above and Moleskine)
					+ Change ConnectedComponentId propagation to match frontier style (i.e. not on strings)
				+ Light diffusion algo now follows PlaneIds (see @Spec above and Moleskine)
				+ All the other things that currently require a ConnectedComponentId for rendering purposes:
					+ Bombs: substitute ConnCompId with PlaneId
					+ PinnedPoints: substitute ConnCompId with PlaneId
					+ Triangles: no ConnCompId nor PlaneId
					+ Spring: no ConnCompId, just PlaneId
					+ Ephemeral particles (check all Points::CreateXYZEphemeralParticle(...))
				+ Render: upload PlaneId instead of ConnectedComponentId
				+ Do ad-hoc tests to validate assignment of plane IDs and connected component IDs
				+ Run in debug and validate
				+ Commit
			+ Step 3:
				+ Ship/RenderContext: UploadPlaneIds(..., maxMaxPlaneId)
					+ Send to GPU right away, in buffer mapped to shared vertex attribute
				+ Test
				+ Commit
			+ Step 4:
				+ Enable Z test and writing to Z buffer:
					+ At RenderContext before doing ships, and disable afterwards
						+ Need World to invoke RenderShipsStart()/End() before going through individual ships
					+ Also clear Z buffer at canvas clear
					+ glEnable(GL_DEPTH_TEST);
					+ glDepthMask(GL_TRUE); // This at initialization
					+ glDepthFunc(GL_LESS); // This at initialization
				+ Test
					+ Also FPS: 32.0 - MIRACLE?!?!?
				+ Commit
			+ Step 5:
				+ Ship/RenderContext: PlaneID->Z calculations
					+ OrthoMatrix:
						+ Rename RenderContext's as "GlobalOrthoMatrix"
						+ Ship has own per-layer, calc'd (and set as uniform) at:
							+ private ShipRenderContext::OnViewModelUpdated()
								+ Invoked at:
									+ UpdateCanvas/Zoom/Cam (use struct - @ parent - with all params)
										+ What about visible world w/h?
									+ Changed nShips at RenderContext::RenderShipsStart()
										+ via ShipRenderContext::UpdateNumberOfShips(nShips)
									+ Changed MaxMaxPlaneId at UploadPlaneIds(...) call
				+ RenderContext ans ShipRenderContext: change OnXYZUpdated/UpdateXYX pattern: no args
				+ Test
				+ Commit
			+ Step 6:
				+ ShipRenderContext:
					+ See if can get rid of optionality of ship's texture
					+ Make dedicated shaders for each layer:
						+ Current => New:
							- Ropes: ShipRopes => ShipRopes
							- Triangles:
								- ShipTrianglesTexture: if !debug && RenderMode==Texture
								- ShipTrianglesColor: otherwise
								=> ShipTrianglesTexture, ShipTrianglesColor
							  & Springs:
								- ShipTrianglesTexture: if !debug && RenderMode==Texture
								- ShipTrianglesColor: otherwise
								=> ShipTrianglesTexture, ShipTrianglesColor
							- StressedSprings: ShipStressedSprings => ShipStressedSprings
							- Points: ShipTrianglesColor => ShipPointsColor (copy)
							- GenTex: GenericTextures => ShipGenericTextures (rename)
							- Vectors: Matte => ShipMatte (copy)
					+ Complete: assign per-layer ortho matrices
					+ Test & commit
			+ Step 7:
				+ Do actual ship ortho matrix calculation at ViewModel::CalculateShipOrthoMatrix
					+ See Moleskine for calc'ns
				+ All ship shaders take new vertex attribute and calc Z via OrthoMatrix
					+ Test first with triangles layer
					+ Do all other layers and shaders next
				+ Test all layers
				+ ShipRenderContext::UploadXYZElement() do not take anymore connected component ID
					+ Dismantle ShipRenderContext connected component tracking; store everything in buffers and/or upload directly
						+ cctor:
							+ // Elements:
								+ Reserve vectors w/maxes from old func
								+ Create VBO's 
					+ Ship: nuke mConnectedComponentSizes
					+ Ship::Render: 
						+ Nuke connected component empty check
						+ if mIsStructureDirty or debug mode changed:
							+ Upload parts individually
				+ Do ship triangles correct sorting
					+ Store bool owned_by_point in Points::ConnectedTriangles (see MOLESKINE)
						+ Store it sorted
					+ Replace Triangles::UploadElements() with Triangles::UploadElements<TIndices>(TIndices const &, ...)
					+ Ship:
						+ Populate std::vector<ElementIndex> at ConnectivityVisit with owned triangle indices only
							+ vector reserved at cctor
						+ ::Render(): still when mIsStructureDirty: Triangles::UploadElements(mIndices)
				+ Verify old behavior (ship triangles in texture mode are drawn incorrectly): 
					+ With Titanic's back flag
					+ Temp triangles upload in old order
					+ Temp no springs draw 
				+ Verify new behavior: OK
				+ Put back ShipRenderContext's Springs rendering
				+ Commit
			+ Step 8:
				+ Issues:
					+ Ropes jumping ahead (when new connected components come up)
						+ Due to incorrect planeID direction on Z axis: higher plane ID (recipient of string
						  assigned to previous (lower) plane ID) must be nearer (than string and its solid body)
					+ (Edge) springs countoured with background
						+ Testable with Titanic funnel
						+ Solution: draw triangles before all
					+ Ropes and anti-aliasing issue:
						+ Option 1: draw ropes *after* triangles and springs, but still in current layer (farther)
						- Option 2: see https://stackoverflow.com/questions/30426178/lines-appear-segmented-after-enabling-depth-testing:
							- Draw ropes first (in invoke order) with Z write off (Z test is irrelevant, as it'd be the first)
								- BUT: if there's no Z write then there's no Z test among ropes, hence
								  they'd cover each other wrongly
							- Draw everything else with Z write (and Z test) on
					+ Piece of rope appears to belong to higher connected component
						+ Was to be expected - after all last segment of rope is between two points that have
						  two different plane IDs, hence a part of the last segment will be visible
						+ Possible solution is to stop doing the "smart" string plane propagation altogether
					+ When pieces belong to same plane, (edge) springs are drawn in disagreement with triangles
					  (e.g. triangles invisible but their edge springs visible)
						+ Option 1: springs are drawn in layer Z-behind
						- Option 2: depth-sort springs as well
					+ After we start drawing ropes temporally after triangles (because of anti-aliasing issue):
						+ Ropes are now occluded by transparent (texture) triangles from same plane
							+ This is because ropes layer is Z-behind triangles layer
							+ Option 1: alpha test in shader
					+ Same plane: covering is now more random
						+ Analyze visit pattern
						+ Try with deque
						+ Try with old-style visit (step 9 below)
						+ Try following raster visit using per-plane indices in final vector
							+ 1: ConnectivityVisit: populate N+1 vector with # of triangles per plane
							+ 2: Triangles::Upload: take it and send endpoints to ShipRenderContext
							+ Test
							+ If ok:
								+ Add # of owned triangles to each point (new buffer)
									+ Init to 0 at Points::Add
									+ Update count at Points::Add/RemoveConnectedTriangles
									+ Use it @ ConnectivityVisit instead of counting triangles
				+ Undefine flood rendering
				+ See if need to and can make alpha threshold higher, to eliminate artifacts around ropes close to their endpoints on 
				  Titanic's funnels
				+ Test texture mode
				+ Test structure mode
					+ See if loss of ropes over structure is ugly; if we can live without it, remove conditions and dual 
					  rope rendering
				+ Test full RenderMode x DebugRenderMode matrix:
					+ Texture, ...
					+ Structure, ...
				+ Test stressed springs
				+ Commit
			+ Step 9: cleanup:
				+ ConnectivityVisit: redo visit from L to R and thus simplify ortho matrix
				+ Remove commented-out connectivity visit
				+ Commit
			+ Step 10: generic textures
				+ GenericTextures: is now own pass that uses own plane IDs as input for Z's in shader
					+ Upload plane IDs instead of conn comp IDs
						+ Fix at all calls from:
							+ Bombs
							+ Points::UploadEphemeralPoints
								+ The texture ones can now pass real plane ID, fix call chain up to caller
							+ PinnedPoint
					+ Fix grow problem at ShipRenderContext
					+ For now keep doing per-plane partitioning of textures for depth-sorting; we'll try alternatives later
					+ Pass PlaneID into gen tex shader (which must NOT take point's vertex attrib)
					+ Try without padding?
					+ That TODO for moving allocation of vertex buffer
						+ And rename of member: mGenericTextureRenderPolygonVertexAllocatedSize
				+ Test
					+ Gen textures are correctly covered by things (ropes, triangles, gen textures) in nearer plane, 
					  and correctly cover things (ropes, triangles, gen textures) in further plane
					+ Test bombs - different planes
					+ Test pinned points - different planes
					+ Test eph particles - different planes
				+ Commit
			+ Step 11: vectors
				+ Add PlaneID to vectors
				+ Test & commit
			+ Step 12: ephemeral points
				+ EphemeralPoints: is now own pass that uses plane IDs as input for Z's in shader
				+ When eph particles are created (e.g. at Points::CreateEphemeralParticleDebris()), we write to the planeId buffer but
				  don't re-upload it; should mark plane ID buffer as dirty, but at two different segments, and then blindly
				  invoke UploadPlaneIdsIfDirty() from ship
				+ Test: eph points from multiple parts
				+ Commit							
		+ Tests:
			+ Do perf analysis to catch low-hanging fruit
			+ Run in Debug
			+ Post perf test
				+ Benchmark:
					+ Orig:
						+ Default: 30.8
						+ ConnectedComponentsTestShip1: 3.10
						+ ConnectedComponentsTestShip2: 11.6
					+ New:
						+ Default: 29.1/29.5
						+ ConnectedComponentsTestShip1: 10.4/10.6
						+ ConnectedComponentsTestShip2: 10.8/11.1

				+ Gradual reduction to smithereens (anti-matter bomb w/Titanic)
					+ Check whether slowness during gradual decomposition - due to conn visit - is acceptable
		+ Cleanups:
			+ Points: order connected triangles so that owned are first
				+ Might be best done @ insert
				+ ConnectivityVisit::population of triangle indices: cut short connected triangles' visit as soon
				  as isAtOwner==false
			+ Light spread on surface changes abruptly when piece is cut; see if it makes sense for diffuse
			  to only light points whose plane ID is behind lamp (thus planeID<=lampPlaneID)
		+ Optimizations to try:
			+ PlaneID's being float's to start with
				+ ...as long as we don't need bucketization for GenericTextures' depth-sorting
			
		+ See if drawing springs & triangles at separate depths also helps generally with render speed, even for one single
		  connected component (for springs' fragment shader - may be it takes shortcuts if it knows it's behind)
	+ Use VAO's (*)
		+ Branch
		+ New OpenGLObject w/deleter
		+ Stars
			+ ShaderManager: allow for reusing numeric values
				+ UTs
			+ BoundedVector
				+ UTs			
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test			
		+ Clouds
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test			
		+ Land
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test			
		+ Move vertex attribute enabling out of shader manager and, for now, to where it is described
		+ Ocean and rest of RenderContext
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute names)
			+ Test			
		+ Verify asm for Upload->emplace_back
			+ @ Stars::Upload
		+ TextLayer
			+ Test
			+ Then, move upload to VBO right after creating vertices
			+ Test
		+ Ship:
			+ GenericTextures
				+ Code
				+ Shaders
				+ Test 
					+ Different planes
				+ Commit
			+ Vectors
				+ Code
				+ Shaders
				+ Test 
				+ Commit
			+ Ship:
				+ One per "input configuration" + vertex element array 
					+ Make sure to bind element array indices to the VAOs
				+ Have to repeat descriptions
				= Code
					+ Do explicit element array binding :-(
					+ Reduce VAOs
						+ To 1; nuke DescribePointVBOs()
					+ Reduce other calls
						+ LineWidth
						+ Texture activation and binding
				+ Shaders
				+ Test
				+ Commit
			+ Cleanup:
				+ RenderCore.h/cpp: remove unused attributes and other TODOs
		+ Get new FPS
		+ Merge
	+ Misc OpenGL Optimizations (*)
		+ Try all of these in isolation, or building on the previous one if the previous one is a clear winner
		+ Try STREAM with ship VBO buffers (apparently should do it without even testing!)
			+ RenderContext:
				+ Water, Land, Clouds
			+ ShipRenderContext:
				+ Mutable point attributes (pos, light, water)
		+ Try orphaning VBO
			+ RenderContext:
				= Water, Land, Clouds
			+ ShipRenderContext:
				= Mutable point attributes (pos, light, water)
			+ Figure out if should do null+subdata vs data
			+ Verdict: no detectable improvement
		+ Try with single VBO for elements, appending stuff to it
			+ Test:
				+ Dynamics between structureDirty changes and debugShipModeRender changes
			+ See if can cleanup enforced order between triangles and others
		+ ShipRenderEnd(): see if using the same shader for triangles and springs buys us anything
			+ Not really
	+ Vertex Buffer Optimization (*): reduce number of vertex attributes for ship shaders 
		+ We've already confirmed that one less attribute vertex sends FPS frpom 29 to 30
		+ At this moment, all Ship shaders - except for stressed springs - have the following inputs:
			in vec2 inShipPointPosition;
			in float inShipPointLight;   *
			in float inShipPointWater;
			in vec4 inShipPointColor;    *
			in float inShipPointPlaneId; *
		+ Test 1: Light + PlaneId
			+ Requires "float planeID" work item first
			+ Code
				+ Points: make struct, with comment on "rendering performance"
			+ Shaders
			+ Test 
			+ See FPS: 29.3/29.7/29.9/30.8
			+ If good:
				+ Commit
		+ Undo V->F shader in/out packing which we did at TrianglesTexture 
			+ And move wetness calculation into vertex shader for all
			+ See if there are other shaders as well
			+ See if want to keep it:
				+ FPS: 29.8/29.9/
		+ Test 2: += Water + Pad
			+ Code
				+ Note: includes workBuffer copy @ WaterDynamics!
				+ GameTypes:Add to PointAttributeGroup1
				+ Points:
					+ Remove buffer
					+ Change getter & setter
					+ Wo workbuffer copy (replace water one)
				+ Ship::WaterDynamics
					+ Use PointAttributeGroup1.Water instead of Water
				+ RenderContext:
					+ Nuke upload water vector
				+ ShipRenderContext:
					+ Nuke upload water vector
					+ Describe new vertex attribute
					+ Nuke RenderCore::AttributeType
					+ Shaders
			+ Test
			+ Get FPS
				- Make sure laptop is quiet
			+ New Perf Analysis
			+ Commit if good
		+ Test 3: other shaders
			+ None
		+ Test 4: Bas' idea
			+ Revert to before Test 1
				+ ...but keep shaders
			+ Do interleaving just at ShipRenderContext
			+ Test:
				+ Light
				+ Water
				+ Vectors
			+ Check assembly
			+ Unbind VBO
			+ Check FPS:
				+ 30.0/30.4/31.1/31.2 (supercharged)/31.7
			+ Commit			
		+ Test 5:
			+ ShipRenderContext: use MappedBuffer
				+ GameOpenGLMappedBuffer<TElement, WRITE_ONLY>
					+ Map(size)
					+ emplace_back(...)
						- w/assert that is mapped
					+ Unmap()
					+ ~()
						+ Unmap if mapped
					+ Remove that ugly GameOpenGLObject()
				+ Use where we upload temporarily to local buffer:
					+ Clouds
					+ Land and Ocean
				+ Check if good and, if so, commit
					+ 30.25/30.3/30.4/31.0/31.15
		+ Test 6:
			+ See if can also interleave Position and TextureCoordinates
				+ Name the other "AttributeGroup2"
					+ Fix all
				+ Make new "AttributeGroup1"
					+ Uploaded straight at ShipRenderContext::UploadPointMutableAttributes()
				+ Shaders
			+ Check perf:
				+ FPS: 30.7/30.7/30.8/30.9/32.0
				+ U/R: 193%
			+ Commit
		+ Do perf analysis

+ Dynamics
	+ Try half of the relaxation iterations
		+ Might need to adjust stiffness
	+ Adjust springs stiffness
		+ Test other values:
			+ 0.1 => should break faster : YES
			+ 1.7: explodes
		+ Test with same strain also for compression	
			+ And force at 0.0058
		+ Test with slightly higher stiffness - see if less bending but same breaking
	+ Realistification:
		+ Ship::Damp: damping 3 times at end should have the same effect
		+ Exploding ship:
			+ Check if higher damp factor helps: was 0.5, now 0.8
		+ Spring equilibrium: 
			+ Find right overshooting factor (may be slightly smaller)
			+ Compare behavior with old game
				+ Steel Ball and broken default ship in old game: explodes? yes
	+ Test completely force-driven dynamics:
		+ Create branch
		+ Each iteration (test initially with 1 iteration per step; then see with more, but scale dt)
			+ Apply forces: 
				+ For each spring:
					+ Spring force (Stooke's law - need k, try fixed at first)
					+ Damping (try along spring first - like now)
					+ see https://www.scss.tcd.ie/Michael.Manzke/CS7057/cs7057-1516-14-MassSpringSystems-mm.pdf for equations
			+ For each point:
				+ Gravity (with buoyance)
				+ Drag
			+ Apply verlet integration
			+ Zero force
			+ ...do tension strain check...
			+ ...electrical and water...
		+ Improve:
			+ Masses				
			+ Gamma - from original (NOT from original, doesn't work)
			+ Better grab force:
				+ Have optional<float force, vec2f position>; at each iteration, if not none:
					- Do force spreading with force/NumIterations
				+ Also, all non-static GameParameters initialized at cctor in cpp				
				+ Check ropes afterwards
			+ Collision with sea floor and (original) "bounce"
				+ v += adjusted Pos - pre-adjusted Pos
				+ Double-check new V
			+ Make SimulationStep a templated constant (double and float)
			+ Clean up code
		+ Perf:
			+ Get baseline:
				+ FPS: 15.8
				+ GameController::DoStep: 44.98%
					- UpdateDynamics: 32.96%
						- UpdateSpringForces: 15.33%
						- UpdatePointForces: 8.51%
							- GetWaterHeight: 5.24%
							- fminf: 1.23%
						- SeaFloorCollisions: 5.40%
							- GetOceanFloorHeight: 3.69%
						- Integrate: 3.71%
					- BalancePressure: 5.70%
					- GravitateWater: 4.30%
				+ MainFrame::Render: 46.67%
			+ Do constants
				+ FPS: 16.15
			+ Do Spring.XYZFactor/s
				+ See if can get rid of dt parameter in funcs
				+ FPS: 16.25
			+ Do Point.MassFactor
				+ const calc'd at cctor via GameParameters::dt and GameParameters::numIterations
				+ See if can get rid of dt parameter in funcs
				+ FPS: 16.50
			+ Do cached WaterHeight and ocean floor height
				+ Also useful for LeakWater()
				+ If period chosen wisely (< expected ship world width), saves on calculations
				+ Physics::WaterSurface class, only visible by World, which exposes own getters
					+ cctor(): allocate buffer
					+ Update(currentTime, gameParameters): populate buffer
					+ GetWaterHeight(x): 
						+ Convert x to absolute sample index, via dx and taking floor
						+ Interpolate height between asi%buffer_size and (asi+1)%buffer_size
				+ At end:
					+ Remove gameParameters from World::GetWaterHeight and cleanup World.h
				+ Optimize
			+ Get baseline:
				+ FPS: 17.0/17.2
				+ GameController::DoStep: 41.85%
					- UpdateDynamics: 28.10%
						- UpdateSpringForces: 13.90%
						- UpdatePointForces: 5.87%
						- HandleCollisionsWithSeaFloor: 4.27%
						- Integrate: 4.24%
					- BalancePressure: 6.47%
					- GravitateWater: 4.88%
					- LeakWater: 0.22%
				+ MainFrame::Render: 48.99%
			+ Test fma in Integrate()
				+ check assembly: REJECTED, it's function call!
			+ UpdateSpringForces:
				+ Don't check for IsDeleted, but just set coeff's to zero for deleted springs
				+ FPS: 17.4/17.5
			+ Spring::WaterPermeability
				+ Set to 0.0 if hull spring or deleted, else 1.0f
					+ Set at cctor
					+ Set to 0.0 at Destroy() ("...avoid draining water to destroyed points...")
				+ Remove two if's at BalancePressure and GravitateWater
				+ FPS: 17.3/17.5
	+ Set springs' K in material
		+ Multiplies with C (0.8) in Spring::CalculateStiffnessCoefficient()
		+ Fix Titanic masts
			+ See if need to increase iterations
			+ Testing wood: 1.10 to 1.15
		+ Fix ropes (they don't move as fluid and continuous as before)
			+ Test with own K for ropes (start with half K)
		+ Change exponential of StrengthAdjustment, for expanded small values
			+ 0.001+((exp(x/70)-1)/2.3)^3.4
			+ Verify inverted formula
			+ finalize default StrengthAdjustment: 0.03421?
	+ Pin points
		+ Point::TogglePin():
			+ If pinning: set MassFactor to zero, and set velocity to zero
			+ If unpinning: recalc MassFactor (using same helper used at cctor)
		+ The entire search is implemented by Points
			+ Together with isPinned (used at search to avoid pinning pinned point), also maintains
			  stack of pinned point indices
				+ Toggle: find topmost point in stack merely within radius; if found -> toggle it & remove from stack 
				  & mark as dirty for re-upload and return true; 
				  + else: find closest non-pinned point; 
					+ if found: toggle it & add to stack & mark as dirty for re-upload & return true
					+ else: return false
				+ Destroy: also remove from stack, if there
					+ And if there, mark as dirty for re-upload
		+ Given that connected component changes affect rendering of pinned points:
			+ Move stack and mArePinnedPointsDirty back into ship, together with search logic
				+ Points gets back Pin() and Unpin()
				+ Ship::Destroy as well
			+ Pinned points are uploaded by decision of Ship
				+ Decision: if mAreElementsDirty || mArePinnedPointsDirty
				+ Ship does start & end & points
		+ ShipRenderContext: draw pinned points using texture (centered)
			+ Ship uploads coordinates and ConnectedComponentID of point
			+ ShipRenderContext: behave exactly as with StressedSprings (i.e. reset at ElementsStart()), as 
			  we're sure we'll re-upload pinned points when elements are dirty
				+ Rename as "Elements"
				+ Do with buffer
				+ Calc bounding box, centered over point, like clouds
			+ Render(): draw at very end of each connected component render, after stressed springs
			+ Redo cursor and move to \textures
		+ Tool just toggles:
			+ Ship checks if exists pinned point in radius: if yes, unpin; else, pin
			+ Returns true if points belongs to ship, so to stop search by World
			+ Cursor is a pin
		+ ShipRenderContext::UploadPinnedPoint(): do pinned point insertion at end of own connected component
		+ Texture: 
			+ lighter
			+ plug hole
		+ Fix crash when loading Titanic
		+ Max 64 pins
			+ CircularList
				+ Add() is templated on OnRemoved() handler
					+ When over, older are removed
				+ Unit tests
			+ Constant at GameParameters
		+ Spring deletion at stress: also unpin endpoint if the endpoint has no more springs attached to it
			+ Requires global destroy handler above
			+ Do at Ship::SpringDestroyHandler
		+ SoundController reacts to IGameHandler event (true/false) with two sounds (Pin/Unpin)
			+ Random choices, Over/Underwater - NO material
				+ Update sink event
			+ Do sounds:
				+ 4 pin
				+ 4 pin underwater
				+ 4 unpin
				+ 4 unpin underwater
	+ Find sweet spot of stiffness and strength between bending and more strength for pinning
		+ stiff: 0.500750
		+ strength: 0.006200
			    0.005376
		+ pinning: fine (can't pin when it's very fast)
		+ wood: 2.0 (titanic masts like before)
		+ new titanic structure
	+ Cosmetics:
		+ Explain Spring's coefficients (in terms of fractionXYZ* of return-to-rest-length, etc.)
		+ Rename Points::MassFactor as IntegrationFactor and explain
	+ Is Verlet implemented right?
	+ Review parallel calculation, it suffers from races
		+ Also See if can continue queueing tasks without waiting for all blocks of chunks
	+ Bombs:
		+ Spec:
			+ Placed and removed with similar tool as Point Pinning
			+ Two types of bombs: timer and remote controlled
			+ A bomb explodes when:
				+ Its timer times out or the remote control is triggered
				+ The point it's attached to is destroyed 
				+ A point or spring in the "neighborhood" (a separate, small radius) is destroyed (includes nearby explosion)
			+ When one or more bombs are detonated, ship needs to know only position, connected component ID, and blast radius, 
			  not even point index
				+ Thus (exploded) bombs are independent from lifetime of point that they were attached to,
				  allowing ship to destroy point immediately at first step of detonation, for example
				  if we have multiple-step detonations
				+ By not using point index we allow explosions to affect multiple connected components (of same ship though)
			+ Bomb decides for itself when it's to be deleted, and Bombs consequently removes it from
			  collection (and from point indirectly via Bomb::Destroy which, if attached to point, calls Points::Detach)
				 
		+ Impl:
			+ Final test
			+ TEST: bombs are attached to springs instead of points
				+ Move isAttached buffer from Points to Springs
				+ Move mass trick to springs
				+ Bomb position becomes positionA and positionB (bomb attached across)
					+ Also BlastHandler argument is positionA and positionB
					+ Blast calculated's by ship from middle point
				+ inline Springs::GetPointA/BPosition(Points const &)
				+ Points::SetMassToMaterial(float ~offset)
				+ Restructure positionA and positionB:
					+ Freeze position and rotation offset, not positionA and positionB
				+ Fix calculation of alpha - check just zero
			+ TEST: lead-in: continuate ping counter, just different velocity and different translation to frame index
			+ TEST: 360 rotation
			+ Fix mass augmentation
				+ Also update springs' coefficients
			+ Fix blast flipping
			+ TEST: run in debug
			+ FIX: first blast handler is so small that it doesn't find point in radius
				+ Go linearly from 0.6 to BlastRadius
				+ At end, re-enable texture frame for explosions
			+ FIX: ContinuousSound start while paused issue
				+ DesiredState
			+ FIX: TimerBomb x,y offsets
				+ Restore cursor hotspot
				+ Add temporarily fixed world offset at ShipRenderContext
					+ Desired center: 147, 228 off 300, 300 => +3, -78 over 12.0, 12.0 makes 0.12, -3.12
				
			+ Bomb base class, w/type enum
				+ Update(OnBombExplosionStep(position, radius)) -> bool = 0: 
					+ Runs state machine with local clock
						+ Advances animations (textures of bombs, sounds via events)
					+ Invokes handler for each explosion step
					+ Returns false when needs to be deleted
				+ GetRenderFrameIndex() -> size_t
					+ Specialized for state machines
				+ NeighborhoodDisturbed() = 0
					+ Invoked when needs to explode because own or near point is disturbed
			+ Two subclasses - TimerBomb and RCBomb
				+ RCBomb:
					+ RCBomb::Detonate(): input to state machine
					+ Update():
						+ Basics
						+ Explosion
					+ Finalize GetArea(): decide if new enlarged explosion looks good
					+ NeighborhoodDisturbed()
						+ Equivalent to RCDetonate()
				+ TimerBomb:
					+ Update(): state machine
						+ Sparkles: sort frames by distance on fuse and do random choice on sliding window
						+ Add a base frame of bomb with no fuse
							+ Rename all frames
							+ Fix calculation of base frame count at Update()
						+ Smoke:
							+ 3 sequential frames
					+ NeighborhoodDisturbed()
						+ Explodes only if state machine duration < own time left
			+ Bombs class
				+ Not ElementContainer, just manager
				+ cctor takes shared_ptr<IGameEventHandler>, ExplosionHandler, Points &
				+ Update(OnBombExplosion(position, radius)) -> void
					+ Runs through all bombs and invokes ::Update() on each
					+ Removes a bomb if its Update() returns false
						+ Detach it if attached
				+ ToggleTimer/RCBombAt(position) 
					+ same logic as pinned points
					+ returns boolean
				+ DetonateRCBombs()
					+ Calls Detonate() at each RCBomb
				+ Upload(RenderContext)
					+ Always upload all bombs, each w/current render frame index
				+ OnPointDestroyed(idx)
					+ For each bomb:
						+ If bomb is attached to this point:
							+ Detach bomb from point
						+ If bomb within (new, smaller) radius from point:
							+ Call bomb->NeighborhoodDisturbed()
				+ OnSpringDestroyed(idx)
					+ Bombs also takes Springs
					+ For each bomb:
						+ If bomb within radius (new GameParameters parameter, smaller) from spring mid-point:
							+ Call bomb->NeighborhoodDisturbed()

			+ Points also has bool HasBombAttached buffer for interactions & lookups, just like pinned points 
				+ Also changes mass (just at point, for gravity only...)				
				+ Flag and mass change is done at Points::AttachBomb()/Points::DetachBomb() 

			+ Events:
				+ OnRCBombPlaced/Removed(size, underwater): used by MainFrame to enable/disable detonation menu item
					+ Also invoked when explodes
				+ OnTimerBombPlaced/Removed(size, underwater): used by SoundController to start/stop and set volume
				  of timer bomb sound
					+ Also invoked when explodes
				+ OnBombDetonated(size): used by SoundController 
				+ OnRCBombPing(size): used by SoundController 

			+ Ship implements:
				+ ToggleTimer/RCBombAt(position)
					+ FW to Bombs
				+ DetonateRCBombs()
					+ FW to Bombs
				+ @Update(): invokes Bombs::Update() w/handler
					+ After spring stress check, so explosion is visible before it breaks things up
				+ @Render(): invokes Bombs::Upload(RenderContext)				
				+ Ship::PointDestroyHandler: 
					+ Bombs::OnPointDestroyed(idx)
				+ Ship::SpringDestroyHandler: 
					+ Bombs::OnSpringDestroyed(idx)

			+ RenderContext:
				+ RenderContext:
					+ Load textures
						+ RC bomb
						+ Timer bomb
						+ Make sure textures are sorted by index
							+ First index for multi-frame is 0 in filename as well
					+ Forward calls
				+ ShipRenderContext
					+ Buffers just like pinned points
					+ Render
			+ MainFrame/Tool:
				+ Register for events and process OnRCBombPlaced/Removed() to enable
				  Detonate menu item
				+ Load 2 cursors
					+ Set hotspot
			+ SoundController:
				+ Event handlers

			+ Media:
				+ TimerBomb cursor
				+ RCBomb cursor
				+ TimerBomb textures:
					+ Bases w/different fuse lengths
						+ With fuse burning, separate unlighted frames
					+ Explosion frames
				+ RCBomb textures:
					+ Base
					+ Pings
					+ Center
					+ Explosion frames
				+ Bomb explosion sounds
					+ N1 normal, N2 underwater
				+ RCBomb ping sounds
					+ 1 normal, 1 underwater
				+ TimerBomb fuse sound
					+ 1 fast, 1 slow
				+ Timerbomb defused sound ("sizzle")
				+ Bomb placed sounds
					+ N1 normal, N2 underwater
				+ Bomb removed sounds
					+ N1 normal, N2 underwater

		+ Bomb explosions: see if better done with force fields
			+ At each explosion frame: radial forces, centered at center, strongest at radius=f(expl frame)

		+ 3rd type of bomb: anti-matter bomb
			+ [Do after texture json]
			+ When it explodes: first sucks everything in, then evertyhing out
				+ Controllable also via ultra-violent mode
				+ Uses "ForceFields" (rename of "ToolForces": applied at each iteration of UpdateMechanicalDynamics and then cleared)
				  for suck-in
					+ ForceFields.cpp/h
					+ Move swirl, grab, bomb explosion to this one
			+ Requires ExplosionType argument at Ship::BlastHandler, or new BlastHandler altogether
				+ Or see if easy to move BombBlaster inside bomb (i.e. explosion code is in bomb's state machine)
				+ Or another way
			+ Plan:
				+ Media:
					+ Sound: continuous (3 choir tones)
					+ Sound: implosion_one (FM)
					+ Sound: implosion_two (whirring, up)
					+ Sound: explosion
						+ Choir with delayed repetitions
						+ First choir is mixed with electronic thud
						+ More emphasys on initial explosion
						+ Redo eventually, with long LFO
					+ Texture: armor
						+ Diagonal arms as well?
					+ Texture: ball, empty
					+ Texture: ball, cloud content
					+ Cursor
				+ Texture DB:
					+ Textures.js
					+ New groups in enum
				+ Sound controller:
					+ New additive continuous sound (like fuse) with random choices and volumes for each
					+ Others
				+ Bomb::IPhysicsHandler
					+ Implemented by Ship
					+ Passed to Bombs and stored as GameEventHandler (i.e. *)
					+ Test 2 old bombs
					+ Create force fields
				+ ForceFields
					+ Move DrawTo and Swirl
						+ Test
						+ Clear ToolForce's
					+ Commit
					+ PreImplosion
					+ Implosion
						+ Trim sound and shorten state machine interval to match
						+ Test coriolis - angular F depending on V of point
						+ Test with angular F being stronger when closer to center
						+ Test with mass-independent accelerations (divide forces by mass)
						+ Test with progress moving along 1/(x-a)
						+ Multiplier for ultra-violent mode
						+ Cleanup force field
					+ Explosion
						+ Add to centrifugal

			+ Lower volume of all breaking/stress (passive) sounds
				+ class GameSound : sf::Sound
					+ setVolume
					+ setMasterVolume
					+ setMuted
						+ each sets volume immediately, no checks
					+ Test:
						+ master volume changes only affects currently-playing category
						+ master volume changes affect future sounds
						+ play farewell sound affects currently playing
						+ play farewell sound affects future music
				+ Find another version of volume sum
				+ Then test again break and stress sounds for volumne
				+ Need to mark CurrentlyPlayingSounds as expendable or not			

			+ Animation:
				+ Cloud rotation slows down during pre-implosion, down to a halt					
				+ Then starts slowly again from the other way around, with v=square of progress
				+ Cross of light
			+ Misc:
				+ Can get rid of deletion checks in force fields?
				+ Test fuse's (slow and fast) sounds for new ContinuousSound architecture
				+ Prevent removal if not in containment (i.e. if detonated already)
					+ Bomb::MayBeRemoved()
					+ Test with all 3

	+ Swirl tool
		+ Force applied is r * AngularForce; AngularForce==m*AngularAcceleration
			+ CW; if Shift -> CCW
		+ Cursors
		+ Need own sound - replicate Draw infrastructure and use different drill
	+ Fix power bar room at all cursors
		+ Try: MakeCursors: make non-transparent pixels green or red, multiplying
	+ Saw
		+ Spec:
			+ Deletes springs (and affected triangles) that cross the *path* of the tool
			+ Continuous sound, overwater and underwater, depending on where x,y is
		+ Impl:
			+ Media:
				+ Cursor up and down
				+ Sound
			+ Events:
				+ Need boolean true/false for sawing
			+ Tool:
				+ L-Down: 
					+ prevMousePos = mouse X, Y
					+ Fire event (asking GameController for game event handler)
					+ Set new cursor
				+ L-Up: 
					+ Reset prevMousePos
					+ Fire event (asking GameController for game event handler)
					+ Set new cursor
				+ Move: if l-down:
					+ if has prevMousePos:
						+ GameController->Saw(prevMousePos, current)
					+ prevMousePos = current
			+ Ship:
				+ Do EnumFlags class in EnumFlags.h
					+ Use it 2 X in Springs
				+ Make sure Spring::Destroy only deletes triangles that share one edge with the spring
					= Nuke Point::Breach and do everything instead in Ship's destroy handler, driven off
					  Springs::DestroyOptions
				+ Test whether should fire the Break event even if only springs are deleted 
					+ For points we fire the event in the ship's PointDestroyHandler; if we
					  want to fire now from ship's SpringDestroyHandler, we must be told whether 
					  the spring destruction comes from a point destruction or not: FromPointDestroy vs FromSpringDestroy
					  + If we do this, we can now also remove firing of break from within Springs::UpdateStrains,
					    as the ship's SpringDestroyHandler would be invoked with FromSpringDestroy
				+ Use Geometry::Segment::TestIntersect()
					+ Also add to it GetAngle...
						+ Move from Texture Rotation
					+ Move also AABB to Geometry
			+ SoundController: new continuous sound
				+ Also underwater

	+ Ultra-violent flag: very strong Draw and Swirl forces

	+ Buoyancy redesign:
		+ test with hack what would happen if all non-hull materials were 1/nth of the mass
		+ python script: allow empty cells (skip cols if != index)
			+ Make template more compact
		+ Regenerate template
		+ Re-check bomb weight
		+ Regenerate template
		+ If ok:
			+ Before unhack: fix ships:
				+ Do Masts and investigate mass effect on breakage
				+ Fix Titanic:
					+ Lighter rudder
					+ Also generally Lighter?
					+ Stronger under funnels (make tin stronger?)
					+ Make it break
						+ Study tension based off mass
							+ Solve integral manually
							+ Do tests
						+ Softer again under funnels
					+ Fix mast
					+ Glass breaks immediately
				+ Fix Base III: make it float
					+ Larger base, boat-shaped
					+ See if it's cooler if it floats more (another floating level)
					+ See with thicker columns (make a new one and call it Base II)
				+ Fix default ship: just lighter
				+ Fix cargo ship
					+ Y offset
				+ Fix Carnival - lighter
				+ Fix Krafting - no sudden stress
			+ Rewrite buoyancy code - use WaterMass
			+ Change materials
				+ No Mass but object with:
					+ nominalMass
					+ density
				+ Springs: get mass from points, not from material
				+ Add density = [copy from current hack] 1/6th for hull, 1/(6*10or4)
				+ Material loading: just store mass*density at mass
			+ Redo Materials Template
			+ Watch out for strength: it was (/ mass * 1000)
			+ Fix strength adjust
				+ Fix max, min
					+ Rethink exponential slider: takes also midpoint (1.0 for us) and then it's two exp curves
		+ Add to change list
	+ Fix buoyancy
		+ Maintain trick with which hull points don't feel buoyancy (or else wood hull would never sink)
		+ Adjust gravity force though
		+ See perf (orig was 3.36%)
		+ Cleanup old
		+ Commit
	+ Make collisions with sea floor more dramatic
		+ Bounce velocity with specular vector
	+ Ephemeral Particles:
		+ Spec:
			+ Carve out fixed-size room at tail of Points for ephemeral particles				
				+ Each has own lifetime
			+ Ephemeral particles cannot be deleted
			+ Rendering: via:
				+ ShipRenderContext::UploadEphemeralParticlePoints (e.g. for points)
					+ Just indexes
					+ Color/alpha portion of buffer has to be uploaded first
				+ ShipRenderContext::UploadGenericTexture (e.g. for bubbles)
					+ Need to also support alphaTransparency
			+ Ephemeral particles are drawn with own color, including alpha going to transparent as lifetime increases
				+ Test first perf impact of using vec4f for point colors
					+ If sucks a lot, will need new extra buffer just for points' alpha
						+ Also this buffer is segmented
				+ Ephemeral portion of entire points color buffer needs to be reloaded at each Upload() 
				  or UploadEphemeralParticles() (2*)
					+ Use glSubBufferData
					+ If we go for separate alpha buffer: also do for ephemeral portion of alpha buffer
		+ Impl:
			+ Test vec4f for colors
				+ Points
				+ ShipBuilder
				+ RenderContext/ShipRenderContext
				+ Shaders
			+ Set max eph particles to 1024
			+ Points allocs extra room
				+ Also stores ship point count and start index
			+ Points has new buffers:
				+ EphemeralType (uint8 enum)
					+ None (set at non-ephemeral and at dead ephemerals)
					+ Debris
					+ Sparkle
					+ AirBubble
					+ Smoke
				+ EphemeralStartTime (clock point)
				+ EphemeralMaxLifetime (std::chrono::milliseconds)
				+ private: 
					+ EphemeralState: union of public structs (much like ElectricalElements::ElementState)
						+ Debris: {}
						+ Sparkle: {}
						+ AirBubble: {}
						+ Smoke: {}
					+ Buffer<EphemeralState> mEphemeralStateBuffer;

			+ Ship: limit point range:
				+ @ destroy tool, @ bombs explosions, and @ anything else that destroys point: do not destroy ephemeral points
				+ @ toggle bombs: do not attach to ephemeral points
				+ For all of these: use Points::NonEphemeralPoints iterator, or check EphemeralType != None, depending on the case
						
			+ Points::CreateEphemeralParticleDebris: 
				+ Args:
					+ Position, Velocity
					+ MaxLifetime
					+ Material *
						+ Requires MaterialDatabase to be handy at invoker of CreateEphemeralParticleDebris
							+ Ship must take a DB by value at cctor
						+ Though Debris uses spring's material
				+ Impl:
					+ Find first expired particle; if not found, pick the oldest
						+ Requires mFreeEphemeralParticleSearchStartIndex
						+ In private ElementIndex FindFreeEphemeralParticle()
							+ sets mFreeEphemeralParticleSearchStartIndex
					+ Store Color, Position, Velocity
					+ Store Mass
					+ Do any other initializations that we do at Points::Add(...)
					+ Store MaxLifetime, and zero lifetime
					+ Set mAreEphemeralParticlesDirty = true

			+ Points::UpdateEphemeralParticles(clockNow):
				+ For each point, check lifetime vs max lifetime
				+ If time has expired (now):
					+ No need to mark as deleted to hide them, EphemeralType==None suffices to prevent them from being rendered
					+ Reset velocity and integration factor of expired particles to avoid drifting
						+ Rename Points::Pin/Unpin() to Freeze/Thaw()
					+ Set EphemeralType to None
					+ Set mAreEphemeralParticlesDirty = true
				+ Else: do per-type state machine, with dispatch coded in method depending on type, invoking 
				  per-type state machine method; for example:
					+ Those that are points:
						+ Calc remaining life
						+ Update alpha either in (portion of) color buffer or in (portion of) alpha buffer
					+ Those that are textures:
						+ Calc remaining life

			+ Points::UploadEphemeralParticles():
				+ 1) Upload portion of color buffer/alpha buffer specific to ephemeral particles
				+ 2) If mAreEphemeralParticlesDirty:
					+ RenderContext::EphemeralPointUploadStart()
				+ 3) For all ephemeral points with EphemeralType != None: use dispatch coded in method depending on type, invoking 
				     per-type upload method; for example:
					+ Those that are points:
						+ Add point index to a buffer
					+ Those that are textures:
						+ Call directly ShipRenderContext::UploadGenericTexture(...)
				+ 4) If mAreEphemeralParticlesDirty:
					+ RenderContext::EphemeralPointUploadEnd()
					+ Set mAreEphemeralParticlesDirty = false

			+ Ship::UpdateEphemeralParticles(clockNow):
				+ Calls Points::UpdateEphemeralParticles(clockNow)
				+ Emits ephemeral particles from emitters (e.g. smoke)
					+ For now empty
		+ Cleanup:
			+ See if can control debris generation via GameParameters, which must be made available at 
			  Ship::SpringDestroyHandler
		+ Tests:
			+ Pin ephemeral particle
			+ Many connected components
	+ Do debris each time a spring breaks
		+ Look'n'feel: 
			+ Points of the color of the spring's material
				+ Actually, points of the spring's material
		+ At Ship::SpringDestroyHandler()
			+ Choose 0, 1, or 2 debris // Experiment
			+ For each:
				+ Material = spring's material
				+ Position = midpoint of spring
				+ Velocity = point on circle as:
					+ Radius: random in [1, 5] // Experiment
					+ Angle: random in [0, 2PI]
				+ MaxLifetime = from GameParameters static const, plus random factor in [0.5-1.0]
		+ Debris:
			+ Update: 
				+ Update color's alpha based off remaining lifetime, linear
			+ Upload: 
				+ Just store index in buffer

		+ Test look'n'feel and finalize constants
	+ Ocean depth bitmaps
		+ OceanFloor cctor takes ResourceLoader
		+ ResourceLoader used by ocean floor to load image
		+ OceanFloor translates image into float[] with raw pixel y's
		+ At update, raw pixel y's are normalized/enhanced with new GameParameters constant
		+ Test	
	+ Slider for "simulation quality", affecting num of mechanical simulation iterations
		+ Update GameParameters - Points and Springs might have to recalc things on changes
			+ Ship
			+ Points
			+ Springs
		+ Fix: invoke points.updategameparams
		+ SettingsDialog: under mechanics tab
		+ Requires extended status text w/measurements
		+ See what to do with stiffness setting: max 1.0f? Leave it
	+ Fix ephemeral particles
		+ Pass also "now" all over the place
			+ End put back UpdateEphemeralParticles where it was
		+ Just single vector of PointIndex, no connected components
		+ Make ephemeral particles' update based on simulation clock, not wall clock
			+ "now" passed everywhere really has to become a "simulationNow" float
		+ Test
		+ Finalize constants
	+ Do chainsaw sparkles with Ephemeral Particles
		+ At Ship::Chainsaw for each broken spring
		+ Initial particle dynamics:
			+ Position: midpoint of spring
			+ Velocity: radial vector:
				+ Butterfly perpendicular to *direction of sawing*, not spring
				+ Magnitude: uniformly random in range
			+ Number: per Update step: uniform random centered around SparkleDensity (ratio over 10, initially) (from GameParameters, adjustable)
			+ Color:
				+ Metal: brightest red to bright red
				+ Else: base material's render color
			+ Finalize parameters
			+ Final test
	+ Add cloth material
		+ Test, basically rope-like but no rope
			+ Low stiffness, hight strength
		+ If fine:
			+ Make it for all basic colors
			+ Structural Template:
				+ Cloth and Rope on same row
				- Redo
			+ Cloth sound			
			+ Make ship with Dutch and Italian flags
	+ Buoyancy rearc
		+ Double-fix for rope/buoyancy/hull unhack and fast-falling wet rope/cloth
		+ First of all, test with Integrate taking into account max(water, 1.0) for mass
			+ At integrate
			+ At spring relaxation, for spring masses
				+ NOPE: here it hurts; wet springs really don't break at all
			+ Check reality-ness
				+ Problem: ship sinks very slowly
					+ Due to: mp>>Mw: v=g*dt; mp<<Mw: v=0
		+ Introduce volumetric fill: fraction of 1m3 that is filled by material
			+ Also: fraction of 1m3 that may be filled with water
			+ Also: volume of displaced water
			+ Default: 1.0
			+ Explicitly set to low value at:
				+ Rope, Cloth
				+ All Hull's (zero)
			+ Remove Points::Buoyancy
			+ Use volumetric fill at:
				+ UpdatePointForces()
				+ Integrate() (temporarily - becomes IntegrationFactor again, but re-calc'd explicitly at each step)

		+ Reintroduce water absorption
			+ High absorption at ropes and cloth
			+ Points buffer
			+ Use it at UpdateWaterIntake

		+ Test look'n'feel
			+ Test for less bouncy crashes: springs using wet mass, again
				+ No, worse
			+ Existing ships
				+ Pay attention to crashes onto sea floor
			+ Rope
				+ WaterRestitution
				+ Fast-falling-when-wet bug
				+ Buoyancy/sinking
			+ Cloth
				+ WaterRestitution
				+ Fast-falling-when-wet bug
				+ Buoyancy/sinking

		+ Now, optimize:
			+ Points::UpdateTotalMass(): calculates:
				+ (New) IntegrationFactor (vec2)
				+ TotalMass (for UpdatePointForces())
			+ Invoke at Ship::UpdateMechanicalDynamics before all
			+ Then, undo changes at Integrate()
			+ Then, use new quantities at UpdatePointForces()
			+ Test:
				+ Changes to Simulation Quality are picked up
				+ Bombs' extra mass

		+ Cleanup TODO's at Ship (SpringForces attempt)
		+ Points::UploadForceBuffer: decide length
		+ Update materials.md docs with new properties, including water
		+ Update ShipAnalyzer for correct buoyancy-adjusted mass
	+ Improve light diffusion
		+ Use real distance
		+ No more non-linear behavior

	+ Add "Low-Dimmed Lights" and "Medium-", and "Portholes"
		+ New Electrical Property of Lamp ("Luminescence") at ElectricalMaterial
		+ New Lamp property at ElectricalElements
			+ Consumed by DiffuseLight
		+ Use at Queen of Unova
	+ Wind and cloth
		+ Step 1: Points has WindReceptivity buffer, for now set at Add(.) to 1.0 if material is one of cloth
		+ UpdatePointForces:
			+ Add wind force vector to overwater points, multiplied by WindReceptivity
				+ From mParentWorld.GetCurrentWindForce()
					+ Step 1: GameParameters.WindDirection * GameParameters.WindSpeed
					+ Will become erratic later on			  
		+ Test with new flag (Iceland) attached to FlagShip
		+ Step 2: new StructuralMaterial property: WindReceptivity
			+ Optional in json (default=0.0), only set for cloth
			+ Update guide
		+ Step 3: erratic behavior of wind
			+ GameParameters::WindSpeed becomes WindSpeedBase
			+ World::UpdateWind(): implements state machine and calcs current wind force
				+ Incorporate gust adjustment
				+ See if we need to up force a bit for fater response
					+ See first w/64 fps first if more respondent - skinnier test ship 
				+ Use short running average to smooth transitions (minimally)
					+ Make it 4
					+ Get rid of intermediate states
				+ Do piecewise state machine, w/various prob types
					+ Gust transitions are still poisson, but not their duration
		+ Step 4:
			+ See interaction of wind on waves
				+ Hi-freq sine whose amplitude is normally zero unless wind force over base
		+ Add all wind settings to SettingsDialog
			+ Include global flag
		+ Sound:
			+ Layered like waves:
				+ 1 continuous sound
					+ Triggered by abs threshold, 30
				+ 1 one-shot sound (Gust)
					+ Triggered by abs threshold && force > .9*Max
			+ IEventHandlers::OnWindForce...(zero, base, max)
			+ Do more gusts
			+ Fix initial ramp up
				+ RunningAverage::Fill(float)
				+ Remove log message @ SoundController
			+ Remove probe
			+ Make sound's volume change inertial
		+ Add probe for wind force
		+ Step 5: implications of low wind settings
		+ Test: 
			+ SettingsDialog: 
				+ Dealing with negative wind
					+ See ripples
				+ Gust adjustment
				+ Modulation off
		+ Try: 
			+ Debris and Sparkles created with WindReceptivity=1.0
			+ Rope has small WindReceptivity
		+ SettingsDialog: expose "Play Wind Sound"
			+ Test
		+ Re-dimension wind force
			+ Try default being -24
				+ Flip Flagship
			+ Say it's km/sec and transform to F (m/sec, w/air mass) in ApplyForce
			+ Eventually adjust receptivity of cloth and rope
			+ If ok:
				+ Also change receptivity of sparkles and debris
				+ Test 
			+ Test Sailship 1
			+ Increase strength of cloth to avoid stress at Flagship
		+ Check with wind speed = 0 - divisions by zero!
			+ Wind
			+ Water
			+ Sound?
		+ Test another re-dimension:
			+ Fw = 1/2 rho v2 A  				
		+ Test perf
			+ Do perf analysis to rule out sound
		+ Rearc: Wind exports speed (vector & magnitudes), in km/h
			+ Ship calcs force
			+ Calc & adjust sound factors
			+ Test:
				+ Force on cloth
					+ Lower receptivity
				+ Force on Titanic's cables
				+ Sound
					+ Lower curve
				+ Waves
					+ Make them faster
				+ Clouds
				+ Max settings
		+ Cloth:
			+ Less heavy
				+ Up strength by same factor
			+ Less stiff
				+ No		
		+ Do SailShip 2
			+ Larger sail?
			+ Cleanup texture
			+ Add ropes
			+ Finish structure
	+ Decay (rust)
		+ Spec:
			+ Over time, *wet* points and springs get decayed (grey), and strength lowers
			+ GameParameters: DecayAcceler8r controls how quickly
				- 0  = +INF == never
				- 1  = 5m (default)
				- 10 = 10s
			+ Low-frequency Ship update does job
		+ Impl:
			+ Points: new Decay float buffer
				+ Init as 1.0
					+ Idea is that Ship::DecayStructure sends it asymptotically to 0.0
			+ Springs: new MaterialStrength float buffer
				+ Init with material strength, same as Strength
				+ Getter const
			+ Points: ConnectedSprings structure contains size_t with # of springs owned by the point
				+ Update at Add/RemoveConnectedSpring
					+ And make owned first, non-owned next
				+ Clone same to triangles - remove isAtOwner flag there
			+ FastLog2 benchmarks
			+ Commit
			+ Ship::LowFrequencyUpdate()
				+ Invoked by Ship::Update
				+ Checks whether currentSimTime >= lastLowFrequencyUpdateSimTime + GameParameters::LowFrequencySimulationStepTimeDuration<float>
				+ Does:
					+ Ship::RotPoints() -> decay
						+ alpha = (10^-5)^(f(Acceler8r)/300) (~total decay in 300/f(RotAcceler8r) steps)
							+ Accel = 1 => 300 steps (5 mins)
							+ Accel = 10 => 30 steps (30  secs)
							+ Accel = 0 => +INF steps
							+ Come up with reasonable min, max
						+ for each point p:
							+ beta = alpha * log(1 + p.water) (beta << 1)
							+ if p.isLeaking: beta *= 5.0
							+ p.SetDecay(decay *= (1.0 - beta))
								+ Check assembly for p.SetXYZ() vs p.GetXYZ()*=y !

						+ Points.MarkDecayBufferAsDirty()

					+ Ship::DecaySprings() -> strength
						+ for each spring: strength = material's strength * avg of two endpoints' decay
						+ Check assembly
					+ Spread out the two calls
						+ Check with large ship if stutters
					+ Do RotPoints at SimulationStepSequence%4 and DecaySprings at SimulationStepSequence%5
						+ Change visit sequence number to SimulationStepSequenceNumber
							+ Double-check first
							+ Type (SequenceNumber, never zero) and variable (SimulationStepSequenceNumber
			+ (Ship)RenderContext:
				+ UploadDecayBuffer
					+ Just like upload plane ID, opportunistic
					+ Interleaves in attribute group 2, at the place of padding
				+ Shaders:
					+ Group2: vec3 -> vec4
					+ Triangle, Spring, Ropes, and Point shaders give value to fragment shader
					+ Fragment shader uses it for:
						+ Pre-test: triangle shader: just display white*decay
						+ Production:
							+ Blend with rot color == l(brown) + (1-l)(green), with l==lightness
					+ Do also at ship_color shader
			+ Less stress sounds when really decayed
			+ Ship::Render:
				+ Points::UploadAttributes
					+ Now also uploads Decay buffer @ //mutable attributes// if dirty, and of course resets flag
			+ SettingsDialog: 
				+ RotAcceler8r
				+ Debug option for rendering decay
			+ Debug option for rendering decay
				+ Make 1 single layer
			+ Scrub tool
				+ Cleans when moves (sends decay back to 1.0) 
					+ Along trajectory, magnitude dependent from distance between tool and point 
				+ Icon: sponge
					+ Make separate down and up
				+ Sound: scrub, with movement (based off feedback from GameController, like saw)
				+ Better sounds with vector directions
				+ Help

+ Water
	+ Water
		+ Ship::LeakWater:
			+ Try rearc: just check if leaking and if externalWaterPressure (0 if above World::WaterHeight) > mWater
		+ Test hull springs/water propagation
			+ Check if also in old program Titanic.png had non-wet hull rudder: YES
			+ Less hull material in Titanic, but maintain strength
			+ Test Titanic afterwards
 	+ Rush sound: should water rush sound be more....rushy?
	+ Water rearc:
		+ Points::Water is height of water column that provides equivalent pressure
			+ When 0<=Water<=1 is also fraction of volume filled with water
			+ Add comments at Points
		+ Ship::LeakWater:
			+ Calc velocity of entering water with Bernoulli
				+ Still need to cap to max (external pressure) because of dt possibly being too large?
			+ Also do negative pressure (i.e. water leaving cell)
		+ Do water-momentum based dynamics					
		+ Cleanups and deferred TODOs:
			+ Test with Bernoulli's spring velocity being added to point's water velocity (times its mass of course)
			+ Do U-shaped tube
			+ SettingsDialog:
				+ Flex spacing
			+ Rename water detail parameter: Water Detail Coarseness
			+ Take perf measurements:
				+ FPS: 26.8/26.9/27.0/27.4
				- MainFrame::RenderGame:	61.08%
				- GameController::Update:	32.92%
					- UpdateWaterDynamics:	 5.85%
						- UpdateWaterVelocities:	5.77%
			+ Refactor UpdateWaterVelocities:
				+ Normalize based off sum of magnitudes
				+ Finalize double-buffering
					+ Take perf measurements afterwards: 27.3/27.5/27.6
				+ 1) Test with memcpy of water buffer
					+ Perf before: UpdateWaterVelocities: 5.59%
					+ Inline first (taking also oldPointWaterBuffer * as restrict)
					+ Perf after: 27.4/27.6
					+ Move to Points as:
						- float * restrict CheckoutWaterBufferTmp()
						- void CommitWaterBufferTmp(float * restrict ...)
							- asserts same as own				
				+ 2) See to improve (sse for 2?) water momentum making/demaking
					+ Move to Points (anyway) as:
						- vec2f * restrict CalculateAndCheckoutWaterMomentumBuffer()
						  or: vec2f * restrict PopulateWaterMomenta()
							- Returns the buffer afterwards
						- void CommitWaterMomentumBuffer(float * restrict ...)
							- asserts same as own
						  or: void PopulateWaterFromMomenta()
				+ Use restrict pointers also for source buffers and springs' properties
					+ Start with only waterBuffer and waterVelocityBuffer, see if improves 1) pre- and post- steps,
					  and 2) main loop
					+ Check asm before
					+ Take perf measurements afterwards: 27.7/28.0
			+ Move "other endpoint" to Springs class
				+ Verify with asm: it's inlined
			+ Finalize 
				+ Take measurements: 27.4/27.7/27.9
				+ Check asm
					+ Momenta initialization
					+ Velocity recalculation
				+ Finalize perf snapshot
			+ ShipRenderContext: add waterLevelOfDetail param to all other shader programs
			+ SettingsDialog: make it tabbed: mechanics, fluid, rendering
			+ Add crazyness to SettingsDialog
			+ Rename GameParameters::GravityNormal to GravityNormalized
			+ GameParameters:
				+ Rename NumDynamicIterations as NumMechanicalDynamicsIterations
				+ Add NumWaterDynamicsIterations
			+ Is Springs::WaterPermeability still used?
			+ See if GameParameters::WaterPressureAdjustment still needed (or needs to change name)
			+ Remove old water dynamics code from Ship
	+ UpdateWaterVelocities: 
		+ See what happens when we also incorporate dest's velocity in Bernoulli
		+ See what happens with drag (after final calculation of velocities)
			+ See if needs to be linear or quadratic
		+ Test with reflected momentum
	+ Splash sound:
		+ First we need to cleanse "rushing water" of bubbles sound
		+ New "splash" continuous sound, with volume controlled by total magnitude of momentum change
			+ Test with ProbePanel, ScalarTimeSeriesControl
			+ Go for kinetic energy lost instead		
		+ Finalization:
			+ Nail down sound
			+ Nail down volume
			+ Measure perf:
				+ FPS: 25.9/26.1/26.2
				+ UpdateWaterVelocities (2m): 11.19%
					+ expf: 2.34%
			+ When removing Q from point, test with using only component of oldV along spring
			+ Recheck one-sided deltaT
			+ Cleanup
			+ Run in debug mode
			+ Averager needs to become member of ship
			+ Optimizations - things to test:
				+ That scalar/vector/scalar
				+ See if can either update all point water momentum once, or for each spring - not both like now!
					+ => FPS=26.2/26.5
					+ UpdateWaterVelocities (2m): 8.75%
						- expf: 0.81%
				+ Low-hanging fruit
				+ Initial point visit for populating exp(water) 
					+ Requires temp buffer
					+ Pre: 26.2/26.5
					+ Post: 26.8/26.9
				+ Initial spring visit for all Bernoulli's (scalar)
					+ Requires temp buffers
					+ Still need to assign sign depending on whether pointIndex is spring's point A or not
					+ Post: 26.8/26.9
					+ NOT WORTH IT
			+ Should replace water rushing in - decide
	+ Do water bubbles (at intake) and water drops (at outtake)
		+ Ephemeral particles emitted at UpdateWaterIntake()
			+ Intake:
				+ Material ("Air") with (very low) weight (real air weight) and full buoyancy so rises up automagically
					+ MaterialDatabase: special getter for it
						+ Mechanism for detecting this and Ropes: unique_type
						+ SoundType needs to become optional
						+ IsRope has to go/ColorKey comment has to go
				+ Ship must take MaterialDatabase 
				+ Emit
					+ Need to coalesce multiple emissions into one
				+ Points::Ephemeral support
				+ Sounds:
					+ Destroy-AirBubble
				+ Expose DoGenerateAirBubbles to SettingsDialog
				+ Air Bubbles Tool:
					+ ~Continuous Tool
					+ Cursor
					+ Continuous Sound
					+ Clean Destroy() doing air bubbles
				+ Don't steal ephemeral particle for air bubbles
					
			+ json comments
				+ Stripped out at Utils
				+ Add comment to air bubble water volume fill
		+ Cleanup: 
			+ Points::Ephemeral maxlifetime expiration is per-type, not global
				+ But buffer stays, useful for finding free slots
			+ Make vortex parameters GameParameters


+ Debug light/drag issue
	+ Could be due to distance too close and shooting light to sky
+ Do connected component detection
	+ Get new baseline
+ See perf of merged LeakWater+DetectConnectedComponents vs Separate
	+ Use perf analyzer:
		+ Merged:
			- Ship::Update: 60.64%
				- PreparePointsForFinalStep: 3.14%
		+ Separate: 
			- Ship::Update: 63.69%
				- LeakWater: 0.11%
				- DetectConnectedComponents: 3.02%
+ Fix multiple clouds

+ Game Interactions and Controls:
	+ IGameEventHandler: individual methods, including parameter changes, all default-implemented
		+ OnDestroy(Material const *, size) // size=1 for each destroy, but Dispatcher aggregates assuming size=anything
		+ OnBreak(Material const *, size) // size=1 for each break, but Dispatcher aggregates assuming size=anything
	+ GameController::RegisterGameEventHandler(IGameEventHandler *)
		+ calls into GameEventDispatcher::RegisterGameEventHandler, who does:
			+ Registration of real sinks (vector of plain IGameEventHandler *)
			+ Aggregation of duplicate events 
				+ e.g.: OnBreak: keep distinct Material * and sum for size
				+ Clears aggregations at OnStepStart() (from GameController) and publishes them
				  to registered sinks at OnStepEnd()
	+ GameController gives shared_ptr<GameEventDispatcher> to Game at Game's cctor (as shared_ptr<IGameEventHandler>)
	+ GameController calls mGameDispatcher (shared_ptr<GameEventDispatcher>)->OnStepStart()/End()
	+ Invoke events at Game and below (pass handler at XYZ.Update())
	+ First GameEventHandler: EventTicker
		+ It's custom panel at bottom with text ticker
		+ EventTicker holds wxPanel and draws it (figure out OnPaint and DC...)
		+ Created by MainFrame and registered by MainFrame on GameController
		+ Hide it by default and only show via MainFrame menu option
		+ Complete event handlers
		+ Do ship sinking event notify in ship (mWater > 1/3 points)
	+ Increase max grab force
	+ Extended status text
		+ Shows:
			+ Current zoom
			+ Rendering vs simulation percentages
				+ GameController continuously updates, same way as FPS
			+ If paused
				+ Actually, this is from StatusText
		+ Multi-row:
			+ Text layer gets it split & gives vector to TextRenderContext
	+ Move tool
		+ Rename current "move" as "Pan"
		+ ShipId type (see around here)
		+ ObjectId type (see around here)
		+ With move tool enabled:
			+ Click on ship -> GameController returns std::optional<ShipId> -> if not None, tool is engaged (save cur screen pos)
				+ Works like pan 
			+ Moving tool tells GameController delta (offset) screen 
	+ Ship definition: multiple layers
		+ We want to maintain BW compat for ease of one-layer ship making
		+ Impl:
			+ json:
				+ "structural_colour" -> "color_key"
				+ "colour"->"color"
				+ Copy & rename
				+ Structural:				
					+ Refactor sound_type for all structural elements
					+ Remove electrical properties
				+ Electrical:
					+ Remove non-electrical materials
					+ Refactor materials
			+ Breakup material class
			+ MaterialDatabase
				+ Restructure 
				+ Find: fallback to rope
			+ ResourceLoader::LoadMaterialDatabase()
			+ IGameEventHandler events take now StructuralMaterial
			+ Points::new struct for materials
			+ Springs, Triangles
			+ ElectricalElements
			+ Ship
			+ ShipDefinition/File: new layers, plus bw-compat
			+ ShipBuilder
			+ Event publishing
			+ Event handlers
			+ Sound renames
				+ StructuralMaterial::MaterialSoundType MaterialSound
			+ GameController
			+ Fix issue with rope endpoints
			+ Fix issue with rope buoyancy
			+ Rope shader: use color from point color buffer
				+ And then get rid of rope color passed to RenderContext
		+ Get rid of IsRope from structural material
			+ Also from json
		+ Test:
			+ BW compat old ships
				+ Electrical
				+ Ropes
				+ All
		+ Renew ships:
			+ Make SS queen of unova use layers
				+ Fix structure as well
			+ Make Szersen cargo use layers
				+ Also test propagation of electrical (cable, in this case) along ropes
				+ Also test different colors for ropes
		+ Cleanup:
			+ Do two new material template screenshots and nuke old one
			+ Redo materials.md
	+ New "Impact" Bomb
		+ Only explodes when spring is destroyed
		+ State machine only for explosion
		+ See why huge explosion
		+ See why texture weird
		+ Center texture
		+ Help
	+ Tool to flood ship
		+ Name: Flood
		+ Shift: un-floods
		+ Icon: bottle (flood), syphon/dropper (unflood)
		+ New ToolController/Tool
			+ Continuous, like Destroy
		+ World->Ship::OnFloodAt(x,y,strength)
			+ Find closest (very small radius)
			+ Add water quantity to point
			+ Emit event
		+ Sound: continuous as long as ship takes water
			+ So, like sawed
				+ Update() attempts to stop i
	+ Control incisiveness (contrast) of water color for water in ship
		+ New uniform
	+ Save screenshots/photos 
		+ Saves automatically in custom folder
			+ New settings provider: UISettings
				+ Managed normally by SettingsManager, and thus tweaked via SettingsDialog
				+ Cctor sets default path (which will be default for SettingsManager)
		+ Code (at RenderContext::TakeScreenshot() -> returns ImageData)
		    glPixelStorei(GL_PACK_ALIGNMENT, 1);
		    glReadBuffer(GL_FRONT);
		    glReadPixels(0, 0, windowWidth, windowHeight, GL_BGR_EXT, GL_UNSIGNED_BYTE, pixels);
		    + See glPixelStorei and glReadBuffer
		    + Call glFinish before all
		+ MainFrame does the saving, via GameLib/ImageTools
			+ Move load functions from ResourceLoader to ImageTools
			+ All static methods
			+ Creates UISettings and passes to SettingsDialog
			+ MainFrame responsible for finding unique filenames like smartphone, with micro's portion
			+ Fires snapshot sound	
		+ SettingsDialog:
			+ Add DirCtrl under tab "TODO"
				+ https://docs.wxwidgets.org/3.0/classwx_dir_picker_ctrl.html
		+ Make actual snapshot sound
		+ Changelist

+ Sound:
	+ SFML:
		+ Build own
		+ Add bins reference to ship CMake
	+ Mute @ Menu
	+ Fix splash progress - make sure final "Complete" shows
	+ Break/Destroy: handlers also take bool isUnderwater (based off Y of broken thing wrt world's water height)
	+ MainFrame initializes SoundController, which implements IGameEventHandler
		+ Initializes off visit of Data/Sounds and Data/Music, w/Music and Sounds
			+ Mapping of sounds with IGameEventHandler events via:
				+ Material::optional<SoundProperties>
					+ SoundMaterial: enum(wood, metal, ...)
					+ Material enums have StrToX()
				+ Filename patterns of sounds and music (e.g. destroy_wood_small_underwater_1.wav)
					+ Parse: if 'destroy'=>expect SoundMaterial next, then ...
				+ Storage of sounds:
					+ Maps store vector<SoundBuffer>
						+ Values are all the variations of the sounds, and 
						  SoundController chooses randomly
					+ Sounds are created when played and stored in queue together with timestamp
				+ Sounds stored in maps (of maps of...) indexed by coordinates off filename patterns
					+ Material's enums used as coordinates, together with SoundController's own
					  enums (e.g. action, size, underwater type)
				+ ResourceLoader has: 
					+ GetSoundFilenames() -> all sound (relative) filenames
					+ GetSoundFilepath(filename)
		+ Do random choice
		+ Need to manage number of currently-playing sounds
			+ When currently playing > MaxPlayingSounds (constexpr):
				+ ScavengeCompletedSounds()
				+ If still full, stop oldest (among same SoundType, or absolute if none) and pop it 
			+ ScavengeCompletedSounds() also called at SoundController::Update()
	+ Stress event
		+ At break loop: for each spring:
			+ Spring->UpdateTensionStrain(..., IGameEventHandler):
				+ If is broken=> this->Destroy(); break event (calc undewater); 
				+ else if is stressed=>
					+ If !mIsStressed:
						+ set; stress event (calc undewater)
				+ else:
					+ mIsStressed = false;
		+ Spring::IsStressed()->mIsStressed, used for rendering
	+ Don't play soundbuffer if already playing for < 20ms
	+ Sounds:
		+ destroy, stress
		+ finish destroy 
		+ better cable snap
		+ Listen to all materials
		+ fix destroy cable/string's
		+ Batch convert all to flac
			+ Test and commit
		+ underwater: with reverb effect
			+ Batch mode, save aside current underwater's first!
	+ MainFrame registers SoundController as Handler with GameController
	+ Sinking music
		+ GameController starts it upon OnStartedSinking() event
	+ See if sounds should be spaced more apart
	+ See underwater cable sounds - sound like metal?
		+ break small 1, 3, 4
		+ destroy medium 1
		+ destroy small 4
	+ Draw event: 
		+ GameController fires Grab, simple
		+ SoundController: uses own sound.isPlaying as state and starts @ event/stops @ update
			+ Uses two consecutive Update() w/no Draw in-between as stop
			+ how to loop though?
	+ Rethink notification of Draw and Swirl events
		+ Remove from GameController, fire at tool via "Toggled(bool)" events
		+ Remove magic from SoundController
		+ Can always modulate sounds at Tool::Update, for example asking GameController::IsUnderwater(screen coords)
			+ Do at Chainsaw, do underwater sound 
				+ Change event handler:
					+ OnSaw(opt<bool> isUnderwater): off, on overwater, on underwater
		+ Test: get rid of all FlushEvents outside of update
			+ If OK, remove commented-out code
	+ Reset sound controller at ResetAndLoadShip()
	+ Water rushing-in
		+ Continuously-playing sound
			+ Find sample
		+ Volume time-interpolated off total quantity of water that entered ships during step
			+ Communicated via new event - OnWaterRushedIn(total_water_quantity)
			+ total_water_quantity update (passed by arg &) replaces mTotalWater update
				+ mTotalWater updated afterwards with +
			+ Volume = 100 * ( -1/(Qw+1) + 1 )
				+ Qw = some scaled version of total_water_quantity (1.0f might suffice)
	+ Separate sound control for tools
	+ Saw sound
	+ Turning down a bit the very high pitch stress noise
		+ Do it on flac - on all high-pitched ones (same amplitude)
	+ Sawing: do not publish destroy events when cutting springs, but new "Sawed" events with own metal/wood sounds
		+ Two new continuous sounds: metal and wood saw
		+ OnSawed is invoked with Type and size - size=0 means nothing
		+ Event handler sets continuous sound's volume up/down (when size=0), and eventually starts it
		+ Stopping continuous saw sound also sets volume of these two to zero

+ Put credits
	+ Splash: https://www.artstation.com/stukata/profile, contact the guy

+ Fix: When land is above water, water is upside down

+ Optimization: to improve locality: points in contiguous buffer
	+ No PointerVector but (fixed) std::vector<Point>, and others point to locations in the vector
	+ Points never deleted, just marked
		+ So have to check point.IsDeleted() each time the Point buffer is iterated
		+ No check
	+ Point destroy: also clear *own* references
	+ Try contiguous buffer also with springs and triangles
		+ And not checking isDeleted
			+ Remove assert's
		+ Multi-step create loop
		+ Spring destroy: also clear *own* references
		+ Triangle destroy: also clear *own* references
		+ Do check IsDeleted for Spring and Triangle operations that may affect connected non-deleted points
		+ New perf: 15.7/15.8
		+ See ElementContainer::range(start, end)
			+ UnitTests, verify last excluded
	+ IsDeleted needs only be checked at SpringRender and TriangleRender
	+ Try fast_qrt for vec2f::length()
	+ Test fast_XYZ at vector
		+ fast_inv_sqrt: 15.2/15.3/15.3
		+ 1/sqrt: 15.3/15.3/15.3
		+ Nuke'em if ok
	+ EventTickerPanel is stealing 1.99% even when not shown

+ Render optimization: only upload spring elements, triangle elements when they're dirty (deletion occurred)
	+ Get perf analysis first:
		- Game::Render: 34.90%:     Ship::Render: 31.53% (Incl)	3.05% (Excl)
			- RenderShipEnd: 28.24%	- Ship::RegisterDeletion: sets mAreSprings/TrianglesDirty=true
	+ cctor: true
	+ set to false after uploaded to RenderContext 
	+ Move XRay flag consumption to RenderContext 

+ Now that we have connected components, fix covering of ship pieces:
	+ Draw batches of triangles and springs by component, so that pieces are "covered" nicely
		+ Ship keeps track of # of connected components and of each size
		+ At RenderXYZ(), allocate N buffers for the vertex indices and dispatch each triangle/spring
		  to the correct buffer based off ConnectedComponentID 
			+ ConnectedComponentID passed by caller (spring or triangle) based off the (first) point
			  of the primitive
				+ assert other points have same ID
			+ Note: points themselves are not affected by this; they're still uploaded in their entirety 
			  once per cycle
		+ At RenderXYZEnd(), draw each connected component buffer from last to first
		+ Do for triangles
		+ Do for springs
		+ Each connected component must be drawn together - its springs then its triangles

+ Technical Debt:
	+ Resources: lowercase filenames
		+ git
		+ code
	+ /Data
	+ /Ships
		+ Uppercase ship filenames
		+ Code (ResourceLoader)
		+ source (git)
		+ CMake
	+ MainFrame::Die(msg of exc)
	+ Get rid of Game.cpp and move functionality to GameController
		+ ResourceLoader::LoadDefaultShip()
		+ Also, don't load default ship autonomously (need to register event handlers before that happens);
		  rely on MainFrame calling GameController::LoadDefaultShip() after registration
	+ Change calls to Point::SubtractFromLastPosition() to AddToLastPosition() and use (& implement) unary '-' operator for vectors
	+ Points and Springs and Triangles::Destroy()'s are templated on Point/Spring/Triangle"Being"DeletedHandlers (others than self),
	  & ship passes own methods
		+ OR: even better, as handler never really changes: cctor takes handler at beginning, given by ship,
		  and stores as std::function
		+ Handlers invoked *before* actual deletion
			+ Comment on handlers on connected-to-argument might be deleted
		+ Not re-entrant - can't delete from within
		+ Handling of pinned point deletion is then done here
		+ See if also whole logic of point<->spring<->triangle can be done in handler
			+ If so, don't pass containers at various Destroy()'s
		+ Test
	+ CircularList::Erase unit test: complete verification of returned iterator
	+ Containers::Destroy and GameEventHandler::OnDestroy rearc:
		+ 3 containers are given shared_ptr<GameEventHandler> and ParentWorld & at cctor
		+ The 2 Destroy()'s fire events (after invoking DestroyHandler), unless otherwise specified
		  via DestroyOptions
		+ Ship's DestroyHandlers don't fire events anymore, and Ship::SpringDestroyHandler takes boolean
		  for triangles (translated from Springs::DetroyOptions)
		+ Test assert's with Debug build
	+ Move definition of ElementIndex et al into GameTypes.h
	+ Move also pinned points to a PinnedPoints class, just like Bombs
	+ Textures are json files, with world size, offset, and lighting boolean
		+ SEE MOLESKINE
		+ Cleanup:
			+ RenderContext:
				+ Hook up IProgress to individual loads
					+ Double-check total count adjustment				
			+ Commit
		+ Then:
			+ (Ship)RenderContext: Do not store sizes but whole database instead
				+ Database must be associated with GLuint's of textures
				+ RenderContext stores (moves) database at cctor
				+ Passes reference to ship
				+ TextureDatabase::GetFrameMetadata(TextureFrameId)
					+ TextureDatabase builds map of references at cctor
			+ Remove hardcoded sizes and offsets and substitute with metadata lookups
				+ Cloud size
				+ Water size
				+ Land size
				+ Pinned point size
				+ Bombs sizes and offsets
			+ Test
				+ Double-check clouds's aspect ratio
				+ Anchor at all frames of timer bomb
			+ Commit
			+ ShipRenderContext: replace pinned points and bombs with Upload(Ship)TextureRenderSpecification:
				+ PinnedPoints
				+ Bombs:
					+ Upload4Render() eventually invokes twice (lighted and unlighted)
					+ Frame indices are TextureFrameIndex instead of uint32
				+ Args:
					+ ShipID (used only by RenderContext to dispatch)
					+ ConnectedComponentID
						+ Until Z-rearc: ShipRenderContext has one TextureRenderSpecification per-connected component
						- After Z-rearc: put in buffer for shader to transform to Z
					+ Position (vec2f)
						+ Of anchor
					+ Orientation (std::optional<vec2f, vec2f>)
					+ TextureFrameId
				+ ShipRenderContext gets TexturePolygon from TextureRenderManager::CalculateTexturePolygon
					+ TexturePolygon is declared at RenderTexture.h, which includes other Texture render .h's
					+ Contains 4X{pos,textureCoord, and AmbientLight adjustment}
					+ For the time being it calculates also rotation
					+ Nuke RotatedTextureRenderInfo.h
				+ Use a single shader for these "simple" textures
					+ Takes TexturePolygon, described to OpenGL
				+ ShipRenderContext rearc:
					+ Textures -> TBD Name="Generic"
					+ Simplify alpha and beta with just beta, and beta is "ambientLightSensitivity"
				+ ShipRenderContext: Detach textures from ConnectedComponentData
					+ RenderContext::RenderShipStart(connected components)
					+ RenderContext::RenderShipEnd()
				+ Double-check cloud rectangle calc'n against TexturePolygon
				+ Test
					+ Double-check clouds's aspect ratio
					+ Anchor at all frames of timer bomb
					+ Rotation of bombs
				+ Move TextureRenderManager::AddRenderPolygon method to .h, and call it EmitRenderPolygon
				+ Move bind into TextureRenderManager, templated
				+ Nuke old bombs/pinnedpoints at ShipRenderContext
				+ Commit
		+ Change the single shader to do *all the work* (for the "simple" textures, including rotation) for all ships and connected components
			+ Initially, runs on 1 texture at a time
				+ After atlas and Z, runs on all textures (via atlas' per-frame texture coordinates)
			+ Perf before moving rotation into shader (2000 textures, @ 30s):
				+ With multiple batches:
					+ FPS: 16.5
					+ ShipRenderContext::RenderGenericTextures: 31.29% 
					+ TextureRenderManager::EmitRenderPolygon: 0.53%
						+ atan2f: 0.16%
						+ sin+cos: 0.09%
				+ With single batch:
					+ FPS: 12.24
					+ ShipRenderContext::RenderGenericTextures: 4.65%
					+ TextureRenderManager::EmitRenderPolygon: 0.83%
						+ atan2f: 0.28%
						+ sin+cos: 0.16%
			+ Move rotation et al into shader (without Z for now)
				+ TexturePolygon is modified to also contain orientation
			+ Perf after moving rotation into shader:
				+ With multiple batches:
					+ FPS: 16.4
					+ ShipRenderContext::RenderGenericTextures: 32.23% 
					+ ShipRenderContext::UploadGenericTexture...: 0.56%
						- atan2f: 0.14%
						- vector: 0.10%
				+ With single batch:
					+ FPS: 12.29
					+ ShipRenderContext::RenderGenericTextures: 6.88%
					+ ShipRenderContext::UploadGenericTexture...: 0.75%
						- atan2f: 0.21%
						- vector: 0.08%
			+ If OK:
				+ Nuke TextureRenderManager::EmitRenderPolygon and do all at ShipRenderContext::UploadGenericTextureRenderSpecification
				+ Move TextureRenderPolygonVertex out of RenderCore and make it private to ShipRenderContext

			+ Extra optimizations to test:
				+ vector (no test)
				+ Use a vec4 for the four lonely floats
					+ With multiple batches:
						+ FPS: 16.4
					+ With single batch:
						+ FPS: 12.29
				+ further packing: two vec2 as one vec4
					+ With multiple batches:
						+ FPS: 16.4
				+ Commit
				+ atan in shader - REJECTED
					+ requires two extra vec2 or a vec4
					+ With multiple batches:
						+ FPS: 16.2
						+ ShipRenderContext::RenderGenericTextures: 31.50% 
						+ ShipRenderContext::UploadGenericTexture...: 0.56%
							+ vector: 0.56%
			+ Final perf test:
				+ FPS: 16.4
			+ Text single texture rotating
			+ Cleanup:
				+ Ship's test upload
				+ reorder RenderCore::VertexAttributes
			+ Final test with game, real textures
	+ Fix issue with very fast rope sinking
		+ How's a wet rope different than iron hull? Test with test_ship.png
		+ It's because ropes get water (when broken) and gravity force is based off point_mass+water, while integration only uses point_mass
			+ In fact it also applies to all light hulls that are broken
		+ See if can apply buoyancy always, and thus get rid of Points::Buoyancy
			+ Nope: too many hull materials would float
		+ NOPE: Apply water mass at Integrate then? And what about springs - should use new mass there as well?
		+ Two possible fixes:
			+ Just don't consider water at gravity if buoyancy=0 (i.e. if hull)
				- i.e. revert the buoyancy fix
				- result is that wet hull points never feel water weight (and neither buoyancy)
			+ THIS ONE: Or, buoyancy=0 points (i.e. hull points) never take water, period
				+ i.e. they are never set leaking upon spring destruction
				+ First figure out how internal hull gets wet - if it does - IT DOES NOT!


	+ Move RenderContext et al into Render:: namespace and file group
			+ See if TextureTypes.h is still needed and whether it can be moved to GameTypes
				+ After all, ShipRenderMode is in GameTypes
				+ Polygon for now moves to that class that makes it

	+ ToolController rearc:
		+ ToolController has pointer to SoundController, and tells the latter when to play and stop tools' sounds 
		+ IGameEventHandler events then exist only for the world-generated noises (e.g. something really breaking), not
		  for the tools
		  + So Swirl, for example, should disappear from IGameEventHandler; some others as well
		  + Tools don't invoke IGameEventHandler->OnSwirl(), for example
		  + Removed:
			+ OnSaw
			+ OnDraw
			+ OnSwirl

	+ CMake:
		+ INSTALL target for release
		+ RelWithDebInfo: Inline any suitable (/Ob2)

	+ Replace ShipDefinitionFile's metadata with ShipDefinition

+ Ships:
	+ Titanic:
		+ Introduce weak metal
			+ Use it underneath funnels

+ Help:
	+ wxWidgets HTML help: http://docs.wxwidgets.org/3.0/group__group__class__help.html
		+ Also, just https://github.com/wxWidgets/wxWidgets/blob/WX_3_0_BRANCH/samples/html/about/about.cpp
	+ Use icons for keys

+ Fix bug: when you reload ship when paused, no clouds & no ship are visible until resumed
	+ World::Initialize():
		+ Calcs connected components for each ship
		+ Builds clouds
		+ Invoked by GameController after pair of world::Reset and world::AddShip()

+ Compare old (released) look with this one, and see if there are changes (in phys, render,...) to take in
	+ Also jellyfish fixed in 1.2.6? NO

+ Release:
	+ Do structure first (above)
	+ Check if less rope mass makes empress of britain not break
	+ Add all other ships 
		+ Remember: uppercase and spaces filenames
	+ Do new .shp's:
		+ Carnival
		+ Titanic
	+ Rerun perf profiling
	+ Lower volume of stress sounds, so that break sounds are louder
	+ @Release only: make Krafting.shp the default ship
	+ Screenshots @ github readme
	+ Tell art guy
	+ Send email to Luke
	1.3.0:
	+ Fix Ocean Depth
		+ Affects only textures, not land
	+ Make some ships
		+ Copy three balls
		+ Make ShipTools, -quantize verb
		+ Make some stiffer columns of steel, iron, titanium, etc.
			+ materials: also order rows based on mass
			+ Do last steel column stiff
			+ Iron and Wood
				+ Switch stiff wood with new one
					+ Switch also Titanic
						+ Test
			+ Add "f=..." to template or better "M:S:F"
			+ Test newest ship
		+ Copy, change, and fix from old:
			+ Ship5
			+ Ship6
		+ Cruise vessel
			+ Plan:
				1 + New layer, with thin hull and light interior
					+ Fix buoyancy
				2 + Introduce heavy metals - own row, just grey's
					+ Make strong structural beams
				3 + Adjust colors by peeking at lower layer
					+ Redo the layer with quantize
				4 + Detachable life raft 
					+ Make "Nails" material
	+ Call .shp parts ".png.dat"
		+ Rename via git
		+ Edit .shp files
	+ Build and release 1.2.0
	+ Post to forum
	+ Add to gamejolt

+ Lights
	+ need Optional()
	+ Material:
		+ use picojson
		+ Material.ElectricalProperties (optional)
			+ type (Material::ElectricalProperties::ElectricalElementType=lamp, cable, generator)
			+ flat list of all electrical properties, some apply some don't
	+ class Lamp()
		+ points to Point and Point points optionally to ElectricalElement (base abstract of Lamp, Cable, Generator)
			+ ElectricalElement::GetType(){return mType;}: non-virtual, it's optimized by compiler
	+ Move electrical components to ElectricalElements class, an ElementContainer but also like bombs, with update and state machines
	  (but no render)
		+ GameEventHandler and points members
		+ Buffers (type, connected electrical elements, etc.)
		+ AddCable/Lamp/...()		
		+ Destroy
			+ Removes self from connected
				+ OR NOT: If Ship::PointDestroyHandler deletes point's connected springs before point's electrical element,
				  then we can assert that electrical element has no connected points anymore already
		+ Getters ("subset" section) for Lamps and Generators
		+ Update()
			+ Invoked by Ship
			+ For each lamp: runs its state machine 
				+ Via RunLampStateMachine(LampState &)
				+ Outcome: AvailableCurrent
	+ Materials: self-powered lamp
		+ Just boolean property in JSON
			+ Current light material is self-powered
			+ New light material is not
		+ ElectricalElements: store boolean at LampState (const, passed via cctor)
	+ Point has ElectricalElementIndex (or None), passed at cctor
	+ ShipBuilder:
		+ Create ElectricalElements via ElectricalElements::Add
		+ Give point/elec element index to each other
		+ Add connected electrical elements to each other
			+ See how it's done for points, springs, etc.
	+ Nuke ElectricalElement, Cable, Generator, Lamp
	+ Nuke unused Material electrical properties
	+ Ship::PointDestroyHandler:
		+ Destroy point's ElectricalElement, if any
		+ Do this after deleting springs, so that ElectricalElement::Destroy does not have to remove self from connected elements (see above)
	+ Ship::SpringDestroyHandler:
		+ Remove each endpoint's ElectricalElement (if any - both must be elec elems) from each other's ElectricalElement
	+ Move StrToDuration and includes to GameTypes.cpp
	+ Move ElectricalElementIndex at Points to own buffer
	+ @Ship::Update():
		+ New "inline" electrical section:
			+ UpdateCurrentConnectivity():
				+ Invoke regardless of dirty elements, as generators might become wet
				+ From generators to all reachable points, just propagates visit seq num
			+ ElectricalElements::Update()
			+ DiffuseLight()
				+ For each ElectricalElement::Lamp: 
					+ Use its AvailableCurrent and set mLight 
	+ Implement full lamp state machine @ ElectricalElements::RunLampStateMachine
		+ EventHandler: OnLightFlicker(size, length, isUnderwater)
		+ Update() takes Points (for underwater)
		+ Implement
		+ SoundController
			+ Add new sound for electrical cable
				+ 2 X random, X 2 underwater
			+ Find 2 sounds ("electrical discharge" or "electric arc")
				+ And make them also underwater
				+ Lower volume of overwater ones
	+ Optimizations:		
		+ Take perf analysis of circuit test 1 (2 mins Circuit Test 1)
			- World::Update: 30.15%
				- UpdateElectricalConn: 0.06%
					- Deque::new: 0.01%
					- Deque::~: 0.01%
				- ElectricalElements::Update: 0.05%
				- DiffuseLight: 0.43%
		+ Ship::DiffuseLight: see inverting nested loops (for each lamp: for each point)
			+ Need test ship with many more lamps
			+ Before perf analysis: DiffuseLight: 35.83% == ~30,000 samples; fps=22.10
			+ Switch loops:
				+ Requires first point light zeroing!
				+ After perf analysis: DiffuseLight: 30.63%; fps=24.x
		+ Do perf analysis with complex graph
			+ Need circuit test 3
			+ Impact negligible: Ship::UpdateElectricalConnectivity: 0.21%
	+ Diffusion:
		+ Can test it by itself, by using light material and by cheating with current!
		+ After current propagation:
			+ Zero out mLight of each point (use generation sequence number? useful for other Point properties?)
				+ No, easier and probably faster to do it in same pass as LeakWater - LeakWaterAndZeroLight()
		+ Diffusion: propagate mLight to adjacent points (incl. other lamps),
		  inv. proportional to distance^2, with a graph flood stopping at max distance
		+ Point.GetColour() takes also into account mLight (from itself, not from lamp) 
                  and makes alpha blend just like water
		+ Need "off" color to use at lamp point when Lamp is off (different than structural color),
		  used when rendering point in springs/triangles/points
			+ Not used when using textures, of course
			+ Needs material's Color to split in StructuralColor and RenderColor (set to the same except for lamps)
	+ Diffusion improvement: see if can simply add light (rather than max'ing it)
		+ Need to ensure sum is always < 1.0
		+ Or just set to max(1.0, cur+new)
			+ Best when done in point->lamp loop: add up in inner loop, then assign to point as max
			+ Doesn't improve look considerably, and still requires an if

+ Bugs: 
	+ Ship::Render: when there are no changes to elements and we keep uploading stressed springs, we don't reset the count
	  in ShipRenderContext::mElementBufferSizes
		+ Fix simply by having Start and End for uploading stressed springs
		+ Done in FB branch
	+ No default args @ vec cctors
		+ Done in FB branch
	+ Fix mem leak
		+ Plan:
			+ Calc base rate of growth: 500K/sec
			+ Comment out ShipRenderContext::Render halves until find the one
				+ When nothing done in loop: 159K max
				+ Just PinnedPoints: grows fast
				+ No texture & no buffer: grows fast
				+ No parameters: grows extremely slow
				! No OrthoMatrix param, Yes AmbientLight param: grows fast
				+ Yes OrthoMatrix param, No AmbientLight param: grows extremely slow
			+ Undo all (dbl-check)
			+ Commit other work
			+ glHint(..._HINT) x 2 at Render::Start()
		+ Cut down on calls to glSetParameter:
			+ Before FPS: 27.4
			+ ShipRenderContext::SetXYZ (ortho, visible world coordinates, and light)
				+ Sets into all programs
				+ Nuke member references
			+ ShipRenderContext::cctor:
				+ Sets into all programs with value from cctor args (this time by val)
			+ RenderContext::UpdateXYZ
				+ Set into all ships
				+ Passes current values by val into new ships
			+ After FPS: 27.4
			+ Verify leak is slower
			+ Do also at RenderContext
	+ Fix issue with clouds and canvas size (wrong aspect ratio)
	
+ Roadmap:
	+ 1.7.0
		+ Magic spring optimization (*)
			+ Then decide whether to increase the number of basis iterations, and whether to adjust strength
				+ SQ: 2.0 => Basis = 24
				+ Strength to maintain Titanic auto-break: <= 0.397928
					+ Change max strength to 10 and see again value: 0.403352
				+ Tune bombs
				+ See pin				
				+ Change ocean floor bump - remove center chasm and move it right
				+ Fix sound quantity
				+ Adjust volume of those two high-pitched sounds
				+ Adjust container ship
				+ Bomb blast radius: 2.0
				+ Fix missing RC bomb pings 
					+ verify break & stress sounds are still good
		+ Test collisions with seafloor being less destructive
		+ Fix crash
			+ Springs and Triangles cctors: pass default-ccted FixedSizeBuffer() there, not {}
			+ Then revert floor collision
			+ Remove TODO's with checks at: 
				- Ship.cpp
			+ Clear super/sub buffers in destroy handlers

		+ Move inertia & ultra-violent mode
		+ Move tool extension: rotate
			+ Shift: up ccw, down cw
				+ Make it relative to prev pos
			+ Change icon
		+ Slider for water drag adjust
			+ Test with water drag depending on v^2
		+ Update help:
			+ Anti-Matter bombs
			+ Move tool

		+ See collisions' bug
			+ Move tools always update velocity
				+ Checl L'n'F'

		+ Strength adjust at 1.0

		+ Decide max water drag: 
			+ 100: OK,but not really "draggy"
			+ 10,000: awesome

		+ Extended status: take stats from RenderContext
			+ RenderContext::Stats:
				+ LastRenderedShipSprings
				+ LastRenderedShipTriangles
				+ LastRenderedGenericTextureTriangles
				+ LastRenderedConnectedComponents
				----
				+ Reset stats at each RenderContext::RenderStart()

		+ Redo full perf analysis

		+ Recheck L'n'F' for current collision handling
		+ Recheck L'n'F' for strength
	+ 1.7.5
		+ Test a density adjustment to make ships float more easily without affecting bending
			+ 0.55
			+ See real weight of steel H-beam: 151 Kg
			+ See old ships
			+ See Roma: work on it and see L'n'F'
			+ If OK:
				+ Fix ships:
					+ Base: a bit heavier (lower center of mass) - make it stiffer in the process
					+ Container ship: make it heavier, containers are too light and ship won't sink
						+ Rename .dat's
					+ Submarine
				+ Adjust materials.json
					+ Python script for materials
					+ except for double-bottom's
				+ Remove hack at Materials.cpp				
				+ Recheck all ships
					+ Fix Submarine
				+ Redo materials template
		+ See if can make Titanic not take water all up quickly
		+ See if now some TODO ships are buoyant
		+ .dat renames:
			+ Ship 0: PM_Oasis
		+ Try out auto-texture
			+ Awful
			+ See with nn_mipmap_linear
			+ See with custom upsize
		+ Figure out strength adjustment based off # of simulations
		+ Check structure/texture alignment issue
			+ Fix
			+ Fix Titanic
				+ Fix ropes: offset -1L, +1B
			+ Fix Queen of Unova
				+ Fix ropes: offset -1L, +1B
				+ Fix eaten things
		+ Reduce sparkles' angle
		+ Impact bomb (*)
	+ 1.8.0
		+ Multi-layer ships
		+ Initial GL canvas size issue
		+ Focus kill/tools issue
		+ Add cloth material (*)
		+ Improve light diffusion (*)
		+ Buoyancy rearc (*)
		+ Crazy ropes:
			+ Don't touch water retention
			+ Add new "water diffusion speed" - value=0.5
				+ Materials system
				+ Points buffer
				+ Use at UpdateWaterVelocities
				+ Rope: 0.015

			+ Make water quickness a "water quickness adjust", between 0.0 and 2.0, default = 1.0
				+ Also @ setting dialog
			+ Test:
				+ Ropes @ ATest
				+ Flags/Cloth
					+ Also with move
				+ Settings Dialog
				+ Perf (after optimization above)
		+ See if need to bump up again global damp
			+ Test: bomb on Titanic; splinter springs tend to dance a tad too much		
		+ Add Roma
			+ .dat renames
		+ Light:
			+ Add low/medium/high-dimmed lights and portholes (*)
		+ See if cloths should be lighter - to not break ropes
		+ Bubbles
		+ Flood tool
		+ Test if debris (and sparkles?) really fly out of water
		+ Redo Submarine - thicker to avoid bending
		+ Lights with different chances of turning off when wet
			+ Do test ship
			+ Do
		+ Trawler with cloth
		+ Ship loading: resize of texture must depend on actual image size (don't get huge)
		+ Make these ships more breakable:
			+ Titanic
			+ Krafting
		+ Porthole: "wet_failure_rate": 3.0
		+ Terrain adjust tool
			+ Managed by World via OceanFloor
			+ See if can get rid of extra sample
				+ Also at Water
			+ Fix zero-index
			+ Undo 500 samples
			+ Test multiple destruction sound w/delay being 50ms
			+ Sound (hammer)
			+ Changelist
		+ Wind and cloth (*)
		+ Do we still need render color in material?
			+ YES - For ephemeral particles
			+ Update guide
		+ SettingsDialog: advanced tab
		+ Bubble tool: 
			+ Hide menu, but ensure it is still reachable
			+ Do inverse visits at World anyway
		+ Log marker w/timestamp
			+ -------------------- 519558699552151
		+ Complete "How to Build a Ship" guide
		+ Move all guides to own folder "Docs"
			+ Also material_template's
		+ Air bubble randomization
		+ WiX Installer
			+ Rearc:
				+ Heat only used for:
					+ Data - ComponentGroup "Data", own wxs
					+ Ships - ComponentGroup "Ships", own wxs
				+ Then manual ComponentGroups:
					+ Binaries
						+ w/proper platform
						+ w/shortcuts
					+ license, readme, changes

			+ No upgrade/downgrade
				+ Version in product name
				+ New product guid each time
					+ Just use new variable
			+ Program files
			+ Desktop shortcut
				+ No working directory
				+ Check icon
			+ Start menu shortcut
				+ Check icon
			+ UI
				+ Initial screen
				+ Progress
				+ Final confirmation
				+ Canceled
				+ Already installed
			+ Icon of add/remove programs
			+ Version main binary:
				+ CMake: only include resources if MSVC
				+ Use version defines from Version.h
			+ Test repair
			+ Remove whole folder on uninstall, even with users' files
				+ https://helgeklein.com/blog/2014/09/real-world-example-wix-msi-application-installer/		
		+ Installer: add location picker
	+ 1.9.0
		+ Ship file dialog (*)
		+ Fix metres bug
			+ ShipPreview must carry original size, before resize
		+ Add new ships
		+ Installer does not install guides
		+ Change version
		+ ConnectedSprings/OtherEndpoint Optimization (*)
		+ Create "z_buffer" branch
		+ Zbuffer (*)
		+ See if can avoid freezing (so, deleting) springs to which we have bombs attached
			+ Don't destroy spring if it has a bomb attached, at:
				+ StressedSprings break 
			+ Test L'n'F':
				+ 3 Bombs
				+ Anti-Matter bomb (should fall at some point)
		+ ShipLoadDialog: make sure default Ships directory is always in recent dirs, first
			+ Test w/empty preferences
			+ Also add Home button
		+ Fix bug with cross-of-light spawning underwater		
		+ Fix sailing ship - cut sail in texture (but not in psd)
		+ Fix Titanic's jagged sides
		+ Tooltips (*)
		+ Update changes.txt with tooltips and z-buffer
		+ Fix SettingsDialog/RecentDirs bug: when new dir loaded, it doesn't appear in combo
		+ Make flood tool adjustable
			+ Two settings - radius and quantity of water
			+ Make sure ultra-violent mode applies to both
			+ SettingsDialog
				+ Use same sliders as DestroyRadius
			+ Test mins and maxs
		+ Make ropes less crazy when they get wet
			+ Test: base tall, slice rightmost tip
			+ Lower water intake adjust seems to help: add per-material
				+ StructuralMaterial: WaterIntake: 0.1 for Rope, default 1.0
					+ Also to guide; dimensionless
				+ Point buffer
				+ Use 
			+ Find good value:
				+ 0.05
			+ Perf:
				+ Pre: 29.1/29.2
				+ Post: 29.3/29.3
		+ Add more cloth colors
			+ Redo structural palette afterwards
		+ New render setting: Ocean Render Mode {Texture, Flat, Depth}
			+ One vertex attribute structure to rule them all 
				+ Texture
				+ Flat
				+ Depth
					+ restWaterHeight is sea depth, no need for: RenderContext need to be told of changing sea depth by GameController
					+ Rename as seaDepth
			+ 3 shaders
			+ VisibleWorld bounding box in viewmodel
				+ Test CrossOfLight
			+ SettingsDialog:
				+ RenderMode
				+ 3 colors
			+ Test all 3 with:
				+ Ambient light intensity
				+ Ocean transparency
			+ Find good default colors:
				+ Depth
				+ Flat
		+ New render setting: Ocean Floor Render Mode {Texture, Flat}
			+ One vertex attribute structure to rule them all 
				+ Texture
				+ Flat
			+ 2 shaders
			+ SettingsDialog:
				+ RenderMode
				+ 1 color
			+ Test all 2 with:
				+ Ambient light intensity
			+ Find good default flat color
		+ Initial help window (HTML) @ Startup
			+ UserPreferences tag to suppress
	+ 1.9.1:
		+ Fixed crash when attemping to load a ship from a directory containing an empty ship
		+ Fixed crash with air bubbles tool
		+ Spring Damp setting
			+ Test mass changes (now that coeffs are recalc'd on mass change)
				+ Bomb attaches
			+ SettingsDialog: advanced
			+ Play to see if can find value
			+ Try dividing by dtSquared
		+ Fix V offset of AM bomb cursor
		+ Slice-while-paused bug

