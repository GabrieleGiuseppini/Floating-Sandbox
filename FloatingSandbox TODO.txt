====================================================
====================================================
====================== Plan ========================
====================================================
====================================================

- Roadmap:

	+ Show build date @ Credits

	+ New OceanSurface interaction experiment:
		+ 1. Tool: only interacts with OceanSurface at Update(), using last known button state & mouse position
		+ 2. OceanSurface:
			+ a. New "InteractiveWaves" buffer with:
				+ CurrentHeight
				+ TargetHeight
				+ CurrentVelocity
			+ b. @ Update():				
				+ b1. Remove SWE interactive state machine update
				+ b2. Add new InteractiveWaves update
					+ Magick goes here
					+ State machine should take into account current SWE height field to avoid adding delta's over delta's:
						+ Interactive state machine:
							X Opt 1: TargetHeight is absolute, so might also be reached naturally by SWE
								X Then force exherted must depend on delta behind current SWE height and target 
								X TODO: but then we have a problem with zero-ing - if we zero target to current SWE height, perturbations never disappear
							X Opt 2: TargetHeight is relative (to 0.0), but we need some kung-fu when we incorporate into SWE height field in order to prevent adding delta's over delta's
								- TODO: but then we compound delta's: we add a delta to SWE height field, then we add it again at the next iteration
							+ Opt 3:
								+ Target height is absolute
								+ Target height reset to SWE height field at end of Update
								+ At beginning of update: interactive state machine updated, and _now_ its output set into SWE height, _before_ SWE height update
								+ Try coefficient approach
									+ Do anti-cuspid and see if it fixes a) cuspid and b) not reaching target height
										+ Wider?
											+ If no works: use non-linear ratio, more radius at low values
									+ Cleanup									
									X Try without height growth coefficient growth
									+ Try larger cuspid
									+ Add comment on fall rate
									+ See rates for fall vs raise, and fine-tune
										+ Ask Mattia
									+ See if we want waves to rise faster at small H
										+ GrowthCoeffGrowtRate should be higher at small height
											+ 1.0f at 0.0, InteractiveRaiseHeightGrowthCoefficientGrowthRate at ~1.0
									+ Cleanup 2
										+ Incl. vectorization
						+ Take pointer size
					+ Fix cuspid
						+ Analysis:
							+ The cuspid we see is the result of setting H and running two field cycles;
								+ First, the H we set at x=X becomes Dt / Dx * (velocityField[i] - velocityField[i + 1]) smaller
								+ Then, for any target H, there are two "regime" H's:
									+ The one at x=X - lower than H - and the one in the neighborhood, extending to infinite
									+ The cuspid itself is our interpolation! It's just that the regime H at x=X is way higher than the regime H at its neighboring cells
										+ Add all of this as comment to code, top of OceanSurface
				+ b3. @ calculate samples: add CurrentHeight from this new buffer
					+ OR: copy (add) CurrentHeight to DeltaHeightBuffer at previous step
				+ b4. Zero out TargetHeight
			+ c. Misc other improvements to OceanSurface:
				+ Try with swapping coeff growth and height growth
				+ Try texture anchor change
					= Nice when we anchor at bottom (e.g. 0.0f) and leave top "almost static" (static would be yTop - yVisibleWorldBottom, almost is yTop * 0.75f - yVisibleWorldBottom),
					  but ugly when one zooms out					 
				+ Mid ocean border line more transparent
				X Try adding back field advection
					+ Add an interactive way to turn on and off to appreciate difference
				X Try changing speed of waves
				X Try incorporating wind speed in SWE velocity field
				+ Try moving Tsunami & RogueWave to new Interactive system
					+ Still need state machines for these, which will invoke AdjustTo
					+ Tsunami will want a slow growth, while RogueWave would be fine with current interactive speed
						+ Pass AymptoticRate as param
							+ Requires our curve to work better: serious 1.0 at low height, real AymptoticRate at 6.0				
			+ d. Cleanup:
				+ Tool: no need to invoke when turning off; just invoke simply each time mouse button is pressed
					+ Also cleanup OceanSurface::AdjustToHeight() then
						+ And remove current simulation time arg altogether
				+ Nuke old SWE interactive state machine
					+ After replacing Tsunami & RogueWave with it
		+ 3. Try with from-to
			+ If doesn't work: Tool: reset mIsEngaged
			+ Test sound
		+ 4. Port to Android

	+ New ambient light control: Full day/night
		+ @ GameController:
			! Toggles based on current time-of-day value
			! Old controls are really about time-of-day
			+ GameController:Set/GetAmbientLightIntensity replaced by TimeOfDay
				+ Own parameter
				+ Method renames up to MainFrame
				+ Initial ToD
			+ GameController::SetTimeOfDay maps tod to ambient light intensity (->RenderContext), sun rays inclination (->RenderContext)
			+ GameController::DaylightCycle state machine's Update() calls IGameControllerSettings::SetTimeOfDay()
				+ SM doesn't need RenderContext anymore
			+ GameController::ToggleFullDayOrNight()
		+ MainFrame: menu item: "Full day/night"
			+ GameController::ToggleFullDayOrNight()
			+ => Localization task

	+ Enhanced sea rendering: rays of light
		+ Fuzzier borders
		+ Inclination
			+ Base:
				+ Param: sunRaysInclination: 0.0==vertical, 1.0/-1.0==45/-45 degrees
					+ Shader
					+ Params enum
					+ Set to 1.0
				+ Use of param
			+ Depending on time-of-day
				+ Map time of day so that:
					- amb=1.0 => ri=1.0 (so that default is +45 degrees)
					- amb=0.0 => ri=-1.0 (so that at night we've flipped to -45 degrees)
			+ Should we map instead the _whole_ NDC space into the buffer (thus making the buffer 3x as large to maintain resolution), so to fix inclination?
		+ "Too many clouds => all black" problem:
			+ Option 1: add (1-mean) to all values, so that mean becomes 1.0
				! Will have darks and lights
				+ Adjust so that we do not reduce darkness (0.0) when it's dark - YES, we keep it dark
					+ Think of new strategy: keep shadowSample's range, but cap its highest point
						X 0.0->1.5: 0.0009090909 + 1.239091 * shadowSample - 0.2454545 * shadowSample * shadowSample;
						+ 0.0->1.4: [0.001818182 +] 1.278182*x - 0.2909091*x^2
					+ s = 1.0 + (s-1)*(exp ... * step(1.0, b))
			X Option 2: shift values up so that min of current values becomes 1.0
				! Will have normal and lights, never darker				
			+ Constrain mean/min to visible only? Should have less jumpy behavior
			+ Need to constrain range, goes too high (white)
		+ Double-check order of things in shader
			+ Shadows -> Darkening -> Border
		+ Too discrete borders (stepping problem), need interpolation
			+ 2-way
			+ 3-way
		+ Depth-darkening of brightness enhancement
			+ Lighter should darken less
		+ Lower speed of clouds
		+ Test storm
		+ Lower # of clouds: 32
		+ Test flat & depth ocean render mode
		+ Cleanup clouds code
		+ Test on Dell, and check perf before & after
			+ See if Dell slowdown is due to R instead of RGBA
			+ Do texture upload conditionally on ocean surface being hi-quality
		+ Merge back into master

	+ Lamps flashing when exploding		
		+ At depth
		+ Via sparkle tool

	= Change ocean defaults, see color decision on Discord
		- Changelist
	= Cloud shadows:
		+ Try with more pronounced depth-darkening delta
			+ Should also darken "lighter" areas which are still < 1.0 but lighter than surroundings
			+ Note that using e.g. 0.5 in lieu of 1.0 as the "threshold" in the shader for lighter vs. darker helps, but then the sea gets too dark
			  as we're darkening also the base color
			+ Should we try again with normalizing to 1.0 rather than to mean?
			+ Test injecting noise for darkening, so we can have flanges
			+ Try as it looks good:
			+ Have a last look
		+ Fix darkening bands issue
			+ See if it repro's with "depth gradient" and using deep black as second color - IT DOES
			+ Search:
				+ https://www.shadertoy.com/view/MlV3R1
			+ Make sure darkening (w/trick) is at:
				+ Flat detailed
				+ All depth's
			+ See if can get rid of noise 0 (Ship Flames, Ship Jet Engine)
			+ Test all shaders:
				+ Lighting: 2
				+ Ocean: 3

				+ Physics probe: 2
				+ HeatBlaster: 2
				+ Fire Extinguisher: 2
				+ Blast tool: 2
				+ Wind sphere: 2
				+ Laser ray: 2

				+ Ship Flames: 1
				+ Ship Engine Flames: 1			
			+ Cleanup GlobalRenderContext.cpp
		+ Try it on fish
			+ Do detailed/basic:
				+ Split shader: basic and detailed, via include-and-#define trick
				+ Choose one shader or the other based on oceanRenderDetailMode
		- Dark stripe issue
		= Tried using shift on the flame tool, game instantly crashed
		- Test all 6 shaders
		- Test on Dell
		- Merge
		- changelist
			= Credit guy (asked name)

	- Night light
		- Blue-ish, just like sun, but dimmer and blue
		- Spec:
			- Sky rendering step @ World
				- First in Draw, takes place of cleaning
					- Uses shader if doCrepuscolarGradient (incl. z), and glClear otherwise
					- Move RenderContext::ApplyClearColorChanges to WorldRenderContext, and refactor as TODOHERE
						- 
			- bool "DoMoonlight"
				! For all shaders except sky
				- Dirty sky render parameters
				- Used by:
					- World:
						- Calculate and set moonlight_color shader param value (black vs. moonlight_color) @ all world shaders
					- Ship:
						- ""
			= rgbColor MoonlightColor
				! For all shaders including sky (which will use it only if it's doing crepuscolar gradient)
				+ Dirty sky render parameters
				= Used by:
					= World:
						= Calculate and set moonlight_color shader param value (black vs. moonlight_color) @ all world shaders
							+ Clouds
							- Water
							- Land
					- Ship:
						- ""
					- Sky:
						- Calculate and set moonlight_color shader param value (black vs. moonlight_color) @ sky shader
			- bool "doCrepuscolarGradient"
				- Just for sky shader
				- TODO
			- rgbColor "CrepuscolarColor"
				- Just for sky shader
				- TODO
			- ocean shader might need to swap depth darkening and ambient darkening

	- Chainsaw sound still on when tool sounds are muted?

	- Combustion ignition: try starting with advanced development when much temperature delta wrt ignition
		- So that explosion generates sudden, large flames

	- Nuke default_ship.shp2 and make Titanic's filename in code
		- So users don't see two Titanic's


	- Greyscaling (of texture and particles) before Thanos snap, and mass changes (lighter), and different phasing of ashing in band
		- Phasing: each particle randomly pulverizes, but towards band end prob is 100%
		- Try with decay
			- Make sure we only upload decay when we mark a dirty flag
	


	- Extra ports from SpringLab:
		- TaskThreadPool, because of:
			- Pointers to tasks

	- Release:
		- Localization (yes, it's dirty)

	- Wrecking ball tool

	- Replace points with quads from geometry shader

	- Buy new track for farewell: https://www.pond5.com/royalty-free-music/item/204959560-nearer-my-god-thee

	- Option to render ocean floor independently from darkening
		- Just affects if/how we set Land::OceanDarkeningRate

	- Ships:
		- N.S._Savannah (Pocketwatch)
		- Stardust (train)  - UR LOCAL BRAZILIAN
		- Shed x 2 - Higuys153#5865
		- Bright mamooth - âµâµð“ð¡ðž ðŸðŸ’ð­ð¡_ðƒð¨ðœð­ð¨ð«-ðŸðŸ—ðŸðŸâµâµ#1963
		- Mauretania - UR LOCAL BRAZILIAN
		- wood ship 2 - Gustav Shedletsky|Local RUS guy#8464
		- SS.Statendam - p1x
		- 4 ships from uneducated_potato, on Discord
		- SS.dermark - desperate soldier
		- RMS Desirable - desperate soldier
		- UH-1 - desperate soldier
		- SS Frederik IV - Pocketwatch
		- Lanticimes (blimp) - UR LOCAL BRAZILIAN
		- Take Dugongsmallwtrtight-Walter (ToTake folder)
			- Name? (ASKED)
			- Credits? (ASKED)

	- Adjustable level of water
		- Think of problem with flattening waves on bottom?

	- Transparency setting for glass material
		- Managed by Ship adjusting colors' alpha's

	- Frozen structure (*)

	- Windows 11 issue: try to play with vsync
		- https://stackoverflow.com/questions/589064/how-to-enable-vertical-sync-in-opengl

	- Bubbles issue (that "old" issue)
		- Add temp code to calc total internal water, and see if it's true that it keeps increasing
		- Do same for "other internal pressure"

	- Fireworks (*)

	- Review rope strength:
		- 0.025 is better, but stresses too much
			- Add optional stress_strength_fraction material property, default=current value, for ropes=100%

	- Quad rendering with indices
		- Sharing VBOs in VAOs: 
			- https://computergraphics.stackexchange.com/questions/4623/multiple-vao-share-a-vbo
			- https://stackoverflow.com/questions/23542355/using-a-vertex-buffer-in-two-different-vertex-array-objects
			- Idea: one single "TriangleQuadIndexSeries" (or "sequence") VBO for all render contexts, created and initialized in GlobalRenderContext, and passed
			  to all child contextes via cctor
				- New class in OpenGL lib: TriangleQuadIndexSeriesVBO (or "sequence")
					- Wraps VBO (private) and local buffer (BoundedVector, private)
						- VBO created in static factory (read below, instance of TriangleQuadIndexSeriesVBO is deferred-init'd as uq_ptr)
					- Exposes void ensure_size(# of quads)
						- If # of quads > current: enlarge & populate local buffer, flag as dirty
						- Starts empty
					- Exposes IsDirty()
					- Exposes Bind()
					- Exposes Upload()
						- Binds and uploads
					- OLD:						
						- Exposes void ensure_size(# of quads)
							- If # of quads > current: enlarge & populate local buffer, re-allocates VBO and uploads new portion
							- Starts empty
						- Exposes VBO via getter
				- One single instance owned by GlobalRenderContext, as uq_ptr (w/deferred creation via static Create())
					- At GlobalRenderContext::cctor() (verify doable)
				- Passed to child contextes as reference
				- GlobalContext does:
					- @RenderPrepare: if TriangleQuadsSeriesVBO.IsDirty: Upload()
				- Child contextes do:				
					- Upload(): ensure_size(# of quads)
					- Draw: Bind before drawing quads
		- Test with bubbles
			- Do
			- New Dell: 
				- Before: upload= render=
				- After: upload= render=
			- Old Dell: 
				- Before: upload= render=
				- After: upload= render=
		- If works, other candidates:
			- Clouds
			- Generic textures
			- Text (NotificationContext)
			- Fishes

	- Add more background music:
		+ "Symmetry" - Kevin MacLeod (incompetech.com)			
		- "Shadowlands 5 - Antechamber" - Kevin MacLeod (incompetech.com)
		- More from Kukaneffect?

	- Make Mac instructions
		- SFML build: https://github.com/SFML/SFML/issues/1496

	- Misc quick things:
		- See if water entering via hole is faster than water entering natural non-hull ("cut funnel")
			- See why Bernoulli doesn't make inflow faster
		- Negative pressure in Mylar bubble - bug?
		- See why with high water density, water entering a ship goes above the waterline - bug?

	- More parallelism at Ship::Update (was: Multi-threading, phase II):
		- Move PhysicsSimulation::UpdateWaterVelocities (8%) to separate thread
			- If water is being read in parallel, make UpdateWaterVelocities take the newWater buffer, and swap it after the tasks have completed
		- Springs: each iteration done in parallel with NThreads partitions
			- Do
				- Pool: if run 1, run straight away on main thread
				- Spring indices need to be partitioned beforehand into multiple Buffer<ElementIndex>'s
					- These are stored by Springs
					- @ShipBuilder:
						- Is given # of partitions
							- ...caller uses mThreadPool->GetNumberOfThreads();
						- N-1 partitions plus one "stitching" partition
							- Partition points and all springs between those points
							- Put cross-partition springs into last partition
				- Prepare parallel tasks
				- Run parallel tasks

	- Test using normalize_approx in spring loop
		- Verify gain on Dell

	- Spring relaxation with intrinsics

	- Lights improvement options (*)

	- Sources of Light
		- See if there's a * below
		- Add to fireworks as precondition
		- Spec:
			- Ship owns LightSource instance, just container of point index, material params, calcd params
				- A part of it is fixed, the other comes and goes
					- ElectricalElements go to fixed part
					- All others to dynamic part
				- Buffer-aligned
				- Params are shader-friendly, as we'll upload them with Lights Improvements work (*)
			- Add/Removed to by:
				- ElectricalElements: added @ init & kept forever
					- Populated initially by ship invoking ElectricalElements::PopulateLightSources(LightSource &)
					- LightSource::AddStaticSource -> LightSourceIndex
					- Lamp state @ ElectricalElements stores the index in LightSource, which is needed for setting params, etc.
				- Firework state machine: added & removed as needed
					- LightSource::Add/RemoveDynamicSource
					- Ephemeral particle state @ Point stores the index in LightSource, which is needed for setting params, removing, etc.
			- Used by lighting algorithm AND by shader (after Lights Improvements work (*))

	- New tool 2: Punch
		- Spec:
			- Works only on frontier from outside->in
				- Might want to try, at end, also from inside->out
		- Impl:
			- TODOHERE

	- Sound space (*)

	- ShipRenderContext: see if may turn off Z-depth check @ triangles
		- Check first on Dell if doing so would improve perf
		- Check then if there are any artifacts when doing so

	- Investigate perf hit of rendering to buffer and directly drawing the buffer afterwards
		- OpenGL Frame Buffer Object 101: https://www.gamedev.net/reference/articles/article2331.asp
		- http://www.mathematik.tu-dortmund.de/~goeddeke/gpgpu/tutorial3.html
		- If it works: do "reshader" type of work (*)

	- See if may put smoke emitters behind triangles and springs
		- At the moment we're using GenericTextures for smoke, hence we're in the same layer as bombs, etc.;
		  need to have a way to change layer, which would however require a different rendering batch (because
		  of different orthomatrix)

	- Test: re-try cache layout optimizations
		- See current optimization's impact first with NOP optimization
		- Check if simply ordering points by X makes it faster (because of improved ocean floor/ocean surface sampling locality)

	- Splashes
		- Option A) Ephemeral particles with own shader:
			- Texture of splash
			- Elongated with vertical velocity
		- Option B) Same as A, but instead of one single texture, a (small) set of frames
		- Option C) Fully "movie" (not ephemeral particles), just like explosions

	= See if fire may emit Heavy smoke
		- Smoke should be drawn behind flames, hence GenericTexture's should be in an earlier layer than flames.
		  However, generic textures (smoke) have internal transparency, while flames have none; the Z test makes it so then
		  that smoke at plane ID P shows the ship behind it, even though there are flames at plane IDs < P
		- We need a new shader, 'cause black smoke looks awful when it fades away
			- Identical to GenericTextures, but with whitening contestual with alpha
			- Buffer can stay the same, just need separate portions: all generic textures followed by smoke
		- Do cleanup tasks

	= Do shader at Anti-Matter bomb pre-implosion
		+ Shader already started: https://www.shadertoy.com/view/3sVSRc
		- See if should add some noise: add some of those playful experiments
		

- Release template:
	- Branch is merged into master (if applicable)
	- Windows
		- MSI variable
		- Commit & push
		- 64-bit MSI
			- Cleanup Install
			- Build Release Install (after clean)
			- Make MSI
			- Rename MSI
			- Test upgrade from previous version
		- 32-bit MSI
			- Cleanup Install
			- Build Release Install (after clean)
			- Make MSI
			- Rename MSI
			- Test clean install
	- Ubuntu
		- rm -rf ~/floating-sandbox
		- pull 
		- rm -rf build; mkdir build; cd build
		- cmake -DCMAKE_BUILD_TYPE=Release -DFS_BUILD_BENCHMARKS=OFF -DFS_USE_STATIC_LIBS=ON -DwxWidgets_USE_DEBUG=OFF -DwxWidgets_USE_UNICODE=ON -DwxWidgets_USE_STATIC=ON -DFS_INSTALL_DIRECTORY=~/floating-sandbox ..
		- make install
		- Make tar ("cd floating-sandbox && tar -cvf ../Floating-Sandbox-1.16.5-x64.tar . && cd -")
		- Zip tar
		- Smoke-test tar ("rm -rf tmp && mkdir tmp && cd tmp && cp ../Floating-Sandbox*.tar.gz . && tar -xf Floating-Sandbox*.tar.gz")
	- Get 3 installers tested on dev server
	- Wait for test results
	- Cut tag on github
	- Upload packages to GameJolt
		- Report file as safe (https://gamejolt.com/privacy)
		- Post
	- www.floatingsandbox.com:
		- Update current version in FAQ
		- Wait a day or two, to exclude disastrous bugs
		- Upload changes2.txt
			- Test w/old FS

- Localization:
	- Italian: Gabriele Giuseppini
	- Russian: DioxCode (Fallback: Ilya_Voloshin, Faulttix#8691)
	- Ukrainian: DioxCode
	- Spanish (Latin American): Joadix (Fallback: The G a z e r W o l f)

	- Portuguese: Kiko
		- Add to credits: "Kiko", and change in other sections as well, and also in .shp files
		- Fallback: The G a z e r W o l f
	- Hungarian: S.S. Atlantic
		= Doing HTMLs
		- Add to credits:
		- Invite to server

- Ships:
	# Credit names:
		# ShippyMcJerry: ShipBuilder1912
		# Coolman115: CorbinPasta93
		# Ilovedumbphones: Dumbphones
		# SweetStrawberryBoy: TopHatLemons
		# sum wulf gurl: Artica
		# An SR71 Habu: NotTelling
		# JackMellon: JackTheBrickfilmMaker (Discord, https://drive.google.com/drive/folders/1isy3QiRzMfyu69v5M0gwD5tvBnYZMWXx)
		# JonBrisby: Takara
		# den2006: Denis
	- Ship Packs:
		+ Kiko's pack
			+ Screenshots and description in PM
			+ I keep donations
			+ Test
			+ Meta
			+ Zip & release
		- HummeL:
			- Meta: <asked>
		+ Waallrus: have all
			+ He'll dig PayPal once I need it
		+ MasterGarfield: have all
			+ Have also his PayPal email
		+ Liamo's pack
			+ Test
			+ Rename "Iowa class" as in meta
			+ Meta
			+ Got his Paypal
			+ Repackage
			+ Publish
		= Alex02:
			+ Have Part 1 and Part 2
			+ Titles: "Le navi dalla storia" (vol. 1 e vol. 2)
			+ Description: I make it
			+ Author: "Alex di Roma"
			+ Add "Andrew Hensley" to credits of: Blue Regalness, 2xQueen Anne
			+ Test
			- Release:
				+ Vol. I
				- Vol. II
					- Asked ShipBucket
			+ No PayPal
		- Space ship pack: [free]
			- JohnSmith: gave permission for his
			- Ships in PM
		- nomadavid's pack
		- Captain Nobinson
			- Test
			- Meta: <asked>
		+ The_Mateuszs_Small_Steamships_Ship_Pack
			+ No Shipbucket
			+ Test
			+ Meta: The package includes 11 ships. The name of this pack is: The Mateusz's Small Steamship ShipPack. Author: "The Mateusz"
	- New ships:
		- TO_TRY\Ships\ 
			- "Dimitri Warin" or "Hellooping" (gmail)
			- Asked name
			- Asked ShipBucket credits
		- Check out from FS server:
			- You can find the best ships in the #architect-creations channel
			- Theres some really good ones in #creation-sharing as well so dont forget about that
		- Ships to make:
			- HMS Victoria: make yourself w/texture from ShipBucket or else
				- Needs to sink vertically!
			- http://www.shipbucket.com/drawings/1821
			- http://www.shipbucket.com/drawings/6850

		- To test and to choose from:
			- Architect Creations
			- mrpasta444_ship_pack
			- TheodoreRoosevelt
			- Graza's from awesomeyorkie
				+ Asked if ropes of abandoned are cut on purpose: yes
				- Fix Antonia vs Antonio
				- Require .shp to limit initial sink
			- Pac0master's Structures
			- Ryanair's planes
			- Kazindel
				+ Asked latest SpaceX and airplanes packs
				- Credits: "Kazindel"

- Ubuntu:
	+ Event polling issue:
		+ Try: on Linux: 
			+ if elapsed < 0: wxWakeUpIdle(), else SetTimer
			+ OnIdle(): if mHasStartupTipBeenChecked && !timer.isArmed: invoke RunGameIteration
	+ Keyboard shortcuts don't work
	= Misc issues:
		- Slider control is clipped
		- MouseMove's are delayed and/or skipped
		- The plain '+' key doesn't work as shortcut
		- The switchboard panel's background selection popup is crippled
		- SpinBox is only horizontal
	+ Build as RELEASE
		+ See if have to set _DEBUG in CMake also for Linux, so it appears in BuildInfo
			+ Test
	+ README.md
		+ Requirements: do different by OS
	+ Gather testers and send them tar.gz
		X gabe3333342323, ayjanu: sent friend requests
		+ Walther first
	+ TheCrafters001: Real Hardware on a Live Linux USB Drive, OS: Linux Mint 20.1 (Ubuntu/Debian Based)
		+ Make fixes:
			+ Fix keyboard shortcut => menu checking
				+ Test:
					+ Pausing is non-functional: "When I check the pause option in the menu, it stays checked. For throughout most of that log I was playing with it checked. 
					  I think I managed to get it paused once, but it took a minute to get it unpaused."
					+ Changing tools using the keyboard, doesn't update the tools menu correctly. Clicking on the tool you were just using does nothing.
				+ Remove Logging for diagnostics
			+ Rotating Boats/Objects happens way too fast
				+ Remove diagnostic logging
		+ Add him to credits
			+ Discord: give him feedback and ask alias for credits: "TheCrafters001"
		+ Send him new beta
	+ Test new feautures:
		+ Inflatable balloon popping
	+ Fix unit tests
	- MainApp does not exit

	
- MAC:
	+ FS build cannot find wxWidgets
		+ Issue is due to pthread and iconv libs not found; added FIND_PACKAGE for APPLE in CMakeFiles
	= Linker issue: DevIL references but can't find jpeg, png, jas, tiff
		- Add png, jpg to shiptools, unittests
			- ADDITIONAL_LIBRARIES is empty
				= Find correct IF to detect - asked to try again
				- See if FIND_PACKAGE for pthread and iconv is still needed after that
		- See if need to rebuild DevIL without JAS, TIFF
			- -DIL_NO_TIF=1 -DIL_NO_JP2=1
	= Full high-DPI path:
		! a) Window scaling: on a 2X DPI, a wxWindow of size (500, 500) would be (1000, 1000) on Mac and (500, 500) on Windows. To overcome this, use wxFrame->FromDIP:
			  myFrame->SetClientSize(wxSize(400, 300));   -->   myFrame->SetClientSize(myFrame->FromDIP(wxSize(400, 300)));
		! b) Physical pixels are never scaled, on any platform, and must be used when drawing graphics elements to ensure that the best possible resolution is used. 
		     For example, all operations on wxGLCanvas use physical pixels. To convert between logical and physical pixels, you can use wxWindow::GetContentScaleFactor(): 
		     this is a value greater than or equal to 1, so a value in logical pixels needs to be multiplied by it in order to obtain the value in physical pixels.
		+ Tests:
			+ With plist (i.e. full screen): ContentScaleFactor=1 DPIScaleFactor=1 100x100dip=100x100px
			+ Without plist (i.e. 1/4th of screen): ContentScaleFactor=2 DPIScaleFactor=2 100x100dip=100x100px
			+ See mouse coords: are they scaled or not scaled?
				! Max is 1900, i.e. scaled
				+ Remove TODOTEST @ MainFrame.cpp
		+ Changes:
			+ _PixelCoordinates and _PixelSize ("logical" and "physical" versions via usings & tag template param)
				+ @ GameTypes, "Rendering" section
			+ GameController::cctor / IGameController: all interface methods take/return coords of correct type (i.e. always the "window" ("logical") type)
			+ RenderContext / ... / ViewModel: all methods take/return coords of correct type
			+ RenderDeviceParameters: takes LogicalToPhysicalPixelFactor, passed down to ViewModel
			+ ViewModel:
				+ Stores LogicalToPhysicalPixelFactor for returning (and taking) "logical" types
				+ Precalcs canvas width/height as "physical"
			+ ToolController: mouse position in MouseState is in LogicalPixelCoordinates
			+ Tools
				+ _PixelXXX::From/ToFloat
			+ MainFrame: pass ContentScaleFactor to RenderDeviceParameters
			+ Tests:
				+ Pan & increment from settings
				+ Tools:
					+ Rotation
					+ MoveBy
				+ Shaders: cross of light, interactive, texture notifications
				+ Screenshot
		+ ScreenToOffset with electrical panel
			+ Add logging
			+ Remove TODOTEST logging
		+ Move BuildInfo generation to BuildInfo
			+ Log
			+ CreditsPanel
		= Test setting glContext after resize
			+ If works, add #ifdef for MAC 
				+ Do it from RenderContext directly, @ ApplyCanvasSizeChanges
					+ Callback binds to a new MainFrame's private method
						+ std::atomic for pointer to canvas
					+ Callback from RenderDeviceProperties goes back to being simply named
					+ "RebindContext" call takes no args
			= Take care also of resize's happening with splash screen
		- MAC tests:
			- Tools:
				- Move tool
				- Rotate tool 
				- Smash tool
			- Shaders:
				- Cross of Light (i.e. in the AM bomb, the "halo" expanding at the beginning, and the final "cross" of light when the bomb explodes)
				- HeatBlaster (make sure the flame is drawn at the right position)
				- Mute notification (appears when you set sounds to mute in FS itself, make sure it appears on the bottom-righ side)
					- Please send me a screenshot of this one
				- PhysicsProbe (new tool, you'll find it under Tools) - should open a "panel" on the bottom-left side
					- Please send me a screenshot of this one
			- Screenshot (take a screenshot in-game and verify it's correct)
				- Please send it to me together with an *external* screenshot
			- Ship preview window
				- Please send me a screenshot of this one
			- Credits
				- Please send me a screenshot of this one
	+ Disable multi-threaded rendering on MacOS - at RenderContext when instantiating TaskThread, but make it so BootSettings may still swing the decision either way
	+ FPS: 13-14
	- Build issues:
		- set (CMAKE_FIND_LIBRARY_SUFFIXES ".a")
	= Current path (absolute-pathness in ResourceLocator): see if with app packaging, current directory is the executable's directory. If not, use current process directory
		+ Add log entry for current directory *and* for executable directory
	- Packaging:
		- wxWidgets so's
			- See if may statically link
		- SFML: so's?
		- DevIL: so's?

- Marketing:
	- GameJolt:
		- Use new video as preview
	- www.floatingsandbox.com:
		- Embed GameJolt Widget
		- Talk about builder (w/screenshot) on main page
	- After release: update Wordpress post w/new engine stuff
		- Connectivity
		- Types

- Suggestions to spec:
	- Northern lights
	- Heat bomb
		- Just heat
	- Fishing log
		- Players can collect different kinds of fish; click on one they don't have and it goes into like a collectors book
		- Could have a "fishing rod" tool
	- Drain ocean
	- Shockwave bomb
		- When detonated the area destroyed is quite small but it sends out a shock wave with a pretty big radius that can cause things to break or collapse and stuff like that. Also maybe it could be very damaging to rotted materials, causing it to shatter like the thanos snap thing.
	- Make lights not propagate through hull
	- Sun rays
	- Moving furniture
		- Need way to prevent springs made to other materials
	- Slow motion
		- When bombs explode
	- Wreno's suggestions: https://docs.google.com/document/d/1kOYAgvh2rFYJJBnSp4DCiFm3FdJlfVEiCXQWNzJzO-I/edit
	- Be able to place nuke and AM bomb anywhere
	- Plants on the bottom - don't have to interact with the ship, just on layer in front of it
	- Different colored lights
	- Different maps: maps that might even have islands and grass
	- Black hole
	- Tool to increase or lower mass under the cursor
	- Can the bubble tool be used to remove water from the ship? that could be pretty cool
	- I wonder if that's possible to make the UI dark once the brightness of the game gets lower than a specific level just like your make the FPS counter white
		+ Tools turning white at night
	- Tornado
		- Mixes swirl and grab
	- Meteorites
	- Earthquake
	- Add circular zones around bombs when placing showing what the expected blast radius should be. The circle should change in size when settings are tweaked. Much better than crunching numbers to figure out what's gonna happen.
	- Air friction: e.g. you throw a ball and it catches fire

	- Update Idea: When we get collision detection AND the ability to spawn multiple ships can you make a "Magnet" colour for eletrical ships, where you can push a switch and it activates a magnet, and if two ships have close magnets, they connected? that would be amazing! We could have aircraft carriers acutally carry helicopters/planes, and tugboats rescuing ships!

	- Ideas from the FS discord server:
		-Whirpools
		-ports and piers to RP with
		-Waterspout/tornadoes
		-Animal NPCs
		-sea life
		-Pixel Ground for higher end PCs
		-trees and grass for islands
		-make underground tunnels
		-atomic bomb
		-snowstorms
		-infinite map or expand the map size
		-option to disable bouyancy from temperature
		-mines
		-water reflections
		-icebergs and growlers
		-ability to spawn more than 1 ship
		-freeze tool
		-Styrofoam material, it always floats and never degrades
		-projectile explosives
		-copper material that oxygenate and turn blue
		-hydrofoil and hovercraft material
		-electrical wires that when active and cut create sparks and light things on fire
		-morse code chat
		-rust from humidity
		-hull damage status
		-working gun turrets
		-foam from bubbles and suction
		-emergency flares and fireworks
		-aircraft and submarine AI that can spawn and raid a ship
		-cargo holds and bunker hatches
		-multiplayer
		-ability to weigh anchor
		-selectable backgrounds
		-lifeboat layer
		-Volcanoes
		-NPCs
		-time travel
		-torpedoes
		-toggle camera to follow a ship with engines
		-splashes from the water when a steamer's funnel buckles and falls
		-pipeworks
		-sunsets
		+surface wake
		-spring optimizations
		-mist for a ship's final plunge
		+day/night cycle
		-change gravity
		-tides
		-background layers
		-3 bodies of water:
			- sea water: the default
			- lake water: a brownish color; not as good as decaying ships, they turn brown but don't break apart
			- river water: a constant turbulent water that flows along the contour of the terrain much like a river does
			- more details:
				So I know you said different water types would be something in the distant future
				but I was thinking about something unique that could involve lake water
				the rot is minimal so I was thinking of an alternative growth
				was thinking that maybe we could have zebra mussel colonies that grow on the wrecks over time in fresh water
				we could introduce a new tool
				like a picaxe type tool that can remove heavy growths like zebra mussels and barnacles
				barnacles would be the problem for the default water settings
				and zebra mussels could be something in lake water settings
				these would slowly colonize the hull and put weight on it			

- Testers:
	- Pac0master: Intel core i5-8600K 6 cores, NVIDIA GeForce RTX 2070
	- Oxurus: Intel i3, Intel(R) HD Graphics 2000, OpenGL 3.1

======================================================================================================================
======================================================================================================================
======================================================================================================================
- Technical Debt:
	+ Global damp as game parameter
	+ Ships start from 1
	+ Do #include "foo.glsl" at ShaderManager
		+ After including redo
		+ Detect loops with unordered_set<std::string>
		+ Use for ship color and texture
	+ Sound controller: complain if find extraneous files (had issue with ".flc"
	+ Ship: replace handler registrations with points, springs, etc. with IShipPhysicsHandler, declared in own .h
	- Change splash screen to wxSplashScreen
	- GameEventDispatcher: set mIsXYZHandlerDirty at event publishing and consume at Flush()
	+ Translations
		+ Make localizable
	+ SSL cert: https://www.sslforfree.com/
	+ Sign with certificate (*)
		+ https://blogs.msdn.microsoft.com/ieinternals/2011/03/22/everything-you-need-to-know-about-authenticode-code-signing/
		+ https://www.thegeekstuff.com/2010/03/microsoft-digital-signatures/
		+ Reasons:
			- Anti-virus complains of saving
		+ Buy certificate
			+ https://www.leaderssl.nl/suppliers/sectigo/products/code_signing
			+ Plan B:
				+ https://comodosslstore.com/code-signing/microsoft-authenticode
				+ https://comodosslstore.com/codesigning.aspx
			+ Print receipt and store in Taxes
		+ Sign exe
		+ Sign MSI
			+ https://stackoverflow.com/questions/17589754/wix-installer-msi-publisher-unknown/17591603
	= Wine:
		+ Test checking for the APPLE extension for VAO's: https://developer.apple.com/opengl/OpenGL-Capabilities-Tables.pdf
			+ "APPLE_vertex_array_object"
		+ Give SamminAter another RelWithDebInfo + pdb
		- Other issues:
			- No fullscreen mode
			- Crash (with Wine stable version 5.0)
				Backtrace:
				=>0 0x0000000000237742 EntryPoint+0xf96a() in sfml-system-2 (0x000000000f0bffd0)
				  1 0x000000000022e526 EntryPoint+0x674d() in sfml-system-2 (0x000000000f0bffd0)
				  2 0x000000007bc91c13 call_thread_func+0xd2() in ntdll (0x000000000f0bffd0)
	+ Build DevIL as a static lib (*)
		+ Redo zlib and libpng SDKs
	- Upgrade wxWidgets (3.2.0):
		= x64 SDK
			+ Build wxWidgets
			- Test FS against it
				- Settings window
				- Ship load window
				- ShipBuilder
				- Credits
				- Switchboard
		- 32 SDK
			- Build wxWidgets
			- Test FS against it
				- Settings window
				- Ship load window
				- ShipBuilder
				- Credits
				- Switchboard
		- Changelist, readme.md

	- See if may upgrade SFML to master (~2.6) with OPUS support
		- Then make all music OPUS
	- Looped sounds (engines, bells, horns, etc.): make them OGG with built-in loop points (see https://rpgmaker.net/tutorials/1341/)
	- Redo SetEventRecorder dynamics between GameController/World/Ship
		- Also GameController::Reset() should clear all events

- Known issues:
	- After many many hours, rain looks aweful - very likely due to timer values being high
		- Storm: store timestamp of rain start, and pass (now-start)::to_float() to shader
	- After many hours, zoom stutters
		- Can test both with faking RealTimeClock start time?
		- Solutions for long-running clock: https://randomascii.wordpress.com/2012/02/13/dont-store-that-in-a-float/
			- Rain solution: 
			- Zoom solution: ParameterSmoother: various timestamp members become time_point (rather than float's)
		- Might have same issue with various tools
		- TODO: is it really worth fixing this?


- Simulation Optimizations:

	= Computer calibration
		+ Executed by GameController
			+ After RenderingContext initialized (for OpenGL capabilities)
			+ OpenGL: based off capabilities
			+ CPU: based off loops
			+ Ask testers for help
				- DKuz: i7-9750H, (12 HW threads), 2.60 GHz, Intel(R) UHD Graphics 630, FPS 64 | CPU Calibration: iterationCount=124 score=1; Graphics Calibration: score=1
				- Oxurus: i5-6400 (4 HW threads), 2.70 GHz, NVIDIA GeForce GTX 960/PCIe/SSE2, FPS 55-57 | CPU Calibration: iterationCount=96 score=0.995328; Graphics Calibration: score=1
				- DioxCode:  i7-870 (8 HW threads), 2.93 GHz, NVIDIA GeForce GTX 1650/PCIe/SSE2, FPS 60 | CPU Calibration: iterationCount=89 score=0.966362; Graphics Calibration: score=1
					- Bad upload perf?
				- m2: i7-4790k (8 HW threads), 4 GHz, NVIDIA GeForce GTX 960, FPS 58 | CPU Calibration: iterationCount=114 score=1; Graphics Calibration: score=1
				- Joadix's brother: AMD A6 3400M with Ryzen HD 6520G
				- Old Dell: Celeron 900 (1 HW threads), 2.2 GHz, Mobile Intel 4 Series Express Chipset Family, FPS 29.5 | CPU Calibration: iterationCount=54 score=0.559872; Graphics Calibration: score=0.0429688
		= Produces CalibrationScore and calibrates
			= ComputerCalibrator::TuneParameters(CalibrationScore const &, GameParameters &, RenderContext &)
				- Sets GameParameters and RenderContext's parameters
					- Max # burning particles
					- Max #Explosions
				+ Happens before SettingsManager samples defaults, so these are the new defaults
					+ Verify this is indeed the case


	- See if additional springs (e.g. between i and i+2) help

	= Cached spring lengths (*)
		! Spring lengths are reused between water update and heat update, and don't change again
			- Cache quantities in Update loop that comes first or last
				- Make it clear that the Update function calculates them: TBD in name
				- Alternatively, use lambda
					- Verify with assembly that there's no overhead with empty lambda
				- Alternatively use Algorithms::CalculateSpringDirAndReciprocalLengths
		- Cache spring length, spring dir
			+ Valid as long as points don't move
				+ In DEBUG, mark mPoints.mDiagnostic_ArePositionsDirty on each position change, and expose mPoints.Diagnostic_ClearDirtyPositions() which is
				  invoked after Springs' cached lengths are re-calculated
					+ Force position changes to go through setters
						+ Except for buffered ones, follow these manually and invoke mPoints.Diagnostic_MarkPositionsAsDirty()
						+ Verify assembly for SetPosition(GetPosition.x, GetPosition.y + foo)
			- Used by: water update, heat update, Springs::UpdateStrains
				- Also use instead of factory rest lengths at:
					- Water
					- Heat

	- 2** Try with SpringRelaxation updating only positions **2 (*)
		- RelaxSprings() updates position directly, no forces involved
			- So no need to integrate afterwards
		- However, need to update velocity, and it's faster if we do it for each point rather than for each spring:
			- Save positions first
			- Do iteration
			- Add resulting velocity: (newPos-oldPos)/(DT/NumMechanicalIterations)
		- Finalization:
			- Initial positions snapshot and UpdateVelocitiesFromPositionDeltas: we only need them for the particles
			  that might have springs - we definitely don't need ephemerals

	= GPUCalc:
		+ 1: Simple OpenGLContext
		+ 2: Multiple OpenGLContextes
		+ 3: Integrate ShaderManager
		+ 4: Run fragment shader to fill-in with frag coords
		+ 5: RenderBuffer
		+ 6: Read pixels back
			+ Nail down clamping
			+ Nail down viewport dimensions/renderbuffer dimensions
				+ Fragment shader runs according to window sizes
				+ Try glViewport to set dimensions (40x40)
		+ 7: Make OpenGL initialization once per thread, after first context creation
			+ Test first at FloatingSandbox: do init at MainFrame after context creation
				+ Export required OpenGL version from GameOpenGL
				+ If ok, move ctx creation et al at postinitialize trigger
					+ Test openGL failure
				+ Cleanup comments (3.3.) and TODOTEST's
			+ Do also at GPUCalcText, also at MainFrame after a first dummy context creation
			+ Commit
			+ MainFrame:
				+ Move OpenGL initialization at cctor, rethrow, and catch at MainApp
					+ Test failure
				+ Same identical at GPUCalcTest
				+ Commit
		+ Fix shaders: 120
			+ Test with FloatingSandbox
			+ Send to guy
			+ Commit after confirmation
		+ 8: Redo Glad with 2.0 profile, and manual ARB's and EXT's for:
			+ Framebuffer
			+ Instanced Drawing
			+ VAOs
			+ Texture Float
			+ Restructure:
				+ Each feature is a "min"
				+ Merge GladLib into GameOpenGLLib
					+ g_glad.h stays
				+ GameOpenGL_Ext stays
					+ h:
						+ global vars with API and enumerants
							+ validate all enumerants the same across core/arb/ext
					+ .cpp:
						+ Various Init():
							+ Load only one set based off version/ext, with LoadAndVerify
					+ LoadAndVerify
			+ Build all and commit and push
		+ 9: Restructure GPUCalcTest
			+ Log window, clear button
				+ RichText: green/red for TEST_PASS: .../TEST_FAIL: ...
			+ Testcase class:
				+ .h:
					+ Macros that call "this"->OnFail(__LINE__....)
				+ void Run() final;
					+ Inits state
					+ Logs start/end
					+ global pass/fail state
				+ virtual void InternalRun() = 0;
			+ Button for "Init OpenGL"
				+ Clears log first
				+ Own test
			+ Buttons for tests, button for "All tests"
				+ Each button clears log first
			+ Tests:
				+ (all tests create own calculator)
				+ PixelCoords
				+ Commit
		+ 9b: GPUCalcTest: independent from DevIL
			+ Verify GameCore and GameOpenGL are independent from DevIL
			+ ResourceLoader back to GameLib
				+ ShaderMgr takes absolute folder path
			+ CMake adjustments to not need DevIL
			+ Commit
		= 10: Sum test:
			+ RenderBuffer and textures all have same dimensions
				+ FrameSize this time is calc'd based off min of the three limits
			+ Fragment shader gets texture coords from vertex shader
				+ Interpolation is fine
			+ Cleanup:
				+ See if need to replace ShaderMgr::SetTextureParams with new one
			+ Commit & push
			- Compare perf with normal sum

		- Other tests:
			- Sum w/calculator reused twice
			- Sum size1 and Sum size2 (2 calculators), one after the other
				- Verify viewport is per-context

		+ x: Verify works with hidden wxFrame, and verify frame is not visible, neither on the taskbar
		- x: Test on two other laptops

		- Cleanup:
			- Set endianness same as platform (x86)
			- See how to force texture sizes to be POT

		- Follow-up's:
			- Optimize ReadPixels
				- Use correct format: query for GL_READ_PIXELS_FORMAT, GL_READ_PIXELS_TYPE
					- See https://www.khronos.org/opengl/wiki/Image_Format
				- Consider using pixel buffer objects to asynchronously read from render buffer
					- See https://stackoverflow.com/questions/12157646/how-to-render-offscreen-on-opengl

	- Array merging:
		+ Springs: RestLength with Coefficients
			+ Pre:  31.7  32.03  31.5  31.6
			+ Post: 31.5  31.7   31.4  31.6
			* With pad:
			+ Pre:  31.1  31.5   31.6  31.7  32.0
			+ Post: 31.3  31.38  31.3  31.3  31.9
		- Points: Position with Velocity and Force
			- Affects Integrate and Rendering

	- UpdateWaterDynamics:
		- Test turning it around into (multiple) spring visits, rather than point visits
			- Multiple because of need to normalize outgoing for each point

- Gfx optimizations:

	- Temperature buffer is currently uploaded separately; now that we've made it "mainstream", see if it makes more sense
	  to upload it together with the other frequently-changing fields (i.e. water, light)
		- Pre: UPL=0.05ms

	- OceanFloor doesn't need to be uploaded at each step
		- However, vertex buffers rely on inputs such as view model, so when these change, we'd need to trigger a re-upload from OceanFloor itself
		- So, best solution would be to make VertexBuffer independent from these extra parameters

	- Reduce number of VAO changes by incorporating multiple VBOs into one, with element size as large as largest (union of structs)
		- Each element type though retains its own BoundedVector, which is uploaded as-needed into larger VBO

	- See impact of drawing onto texture and then quad'ing the texture onto the screen (w/no filtering) (*)
		- If fine:
			- Do stars once and for all
			- Spec gfx niceties such as reflections and after-effects/post-processing

	- Lights improvement options (*)
		- "Static light":
			- Pixels that are sources of light should be rendered as constant yellow, without ambient light effect
				- How to do without triangle interpolation?
		- Lights' glows as textures:
			- Shader adapts the texture to the varying light parameters
			- Then a quad is drawn for each source of light, with size depending on aperture
				- TODO: z-depth issue? Lights will be drawn _after_ ship parts
					- Try to just draw textures at their Z, with Z test enabled
					- Need to be drawn *last* as they are transparent
		- Lights on the GPU with instanced drawing
			- Light at fragment (Phong)
				- Lamp coords, spread, and luminiscence in uniform array
			- Loop drawing ship as many times as necessary to avoid going beyond uniform limit of the GPU
				- Figure out max at OpenGLInit
			- Test 1: simply instance TrianglesTexture
			- Test 2: also instance others
			- Test on Dell
		- Check proposed luminiscence settings (from @Carter_JL on GameJolt)
			- Luminiscence Adjust: 0.5
			- Light Spread Adjust: 0.5

	- Air bubbles with instanced drawing (even though we can only do ~100 at a time, but then might do nBubbles/100 vertices)

	- Try using GL_SHORT for Ship texture coordinates
		- Passing NORMALIZE and 3 components to glVertexAttribPointer


- Gfx:

	- Auto-focus improvements:
		- Settings to fine-tune how close (or far) auto-focus should be
			- Basically changes NDC fraction/s

	- Tensile/Stress display: 
		- Show water (@ point buffer)
		- New variant: only color springs (but in "normal" mode)

	- In Windows' "high contrast mode", the names of the ships in the Ship Load Dialog disappear

	- Flames: make sampling resolution independent from dimensions
		- Need to pass width and height of flame quad, and divide texture coords by these

	- Intro screen: the game's title falling into the sea and floating back up - interactive to a smaller extent, e.g.
	  by just punching holes

	- Background ships: just any of the other ships, that would sail in the background

	- Fog
		- Requires post-processing work

	- Different backgrounds: use keys to switch between a dock, cliffs, open ocean, ice field, etc.

	- Sky:
		- Add SkyRenderMode (Flat, Gradient)
			- The two endpoints of gradient dependent on ambient light
				- Interpolated between two pairs of endpoints
			- RenderContext:
				- If Flat:
					- When clearing buffers, clear also color buffer with flat color
				- If Gradient:
					- When clearing buffers, do not clear color buffer
					- Run program with quad immediately afterwards
						- Shader
							- No orthomatrix, all NDC
							- No ambient light param, no new params

			- SettingsDialog:
				- Gradient RadioButton: on the right has two rows with a gradient each
		- Night sky should use a round darkening - center of screen is slightly lighter
			- Or even better, Milky Way

	- Electrical view (*):
		- Spec:
			- New flag (not in ShipRenderMode, standalone ~like StressedSprings)
				- Settable at SettingsDialog
					- Ideally, enabled only if there are electrical elements, but how to figure it out?
			- When enabled, draws "Connections" (lines - using ship endpoints) and "Devices" (points - using ship endpoints)
			  on top of ship
				- One new layer after tri's, springs, and ropes
				- Connection, w/bool isPowered
					- Powered: 1D texture, animated (w/clock->offset), red
					- !Powered: 1D texture, still, grey matte
						- Both textures are segments in same texture
				- Device: shader with concentric expanding and/or contracting circles and different colors
		- Impl:
			- (Ship)RenderContext::UploadElectricalConnection/Device/Start/End:
				- Conn:
					- vec2 startPos, endPos
					- planeId
					- isPowered => texture coord
				- Device:
					- vec2 pos
					- planeId
					- vec4 color => color
			- Ship::Render: if flag set: invokes Ship::RenderElectricalElements()
				- Do a sort of connectivity visit and upload as you go

	= AmbientLightIntensity:
		+ Use also in RenderContext::RenderStart() for clear (sky) color
		+ Phase 1: pgup/down
		= Phase 2: with clock / time-of-day
			- Sky should also have crepuscolar gradient
	- Magnifying glass
		- https://www.opengl.org/discussion_boards/showthread.php/154811-magnifying-glass-effect
		- https://www.shadertoy.com/view/4tdXDl

	- Add a flashlight to see the ships deep underwater. Its hard to see the ships at some depths. Plus the idea of seeing a rusty hulk of metal appear out of the dark abyss is really cool
		- Requires "sources of light" feature (*)

	- Less repetitive auto-texturization:
		- Material textures have to become procedurally-generated

			
- Dynamics:

	- Sand particles when hitting ground

	- Material system improvements (*)
		- Descriptions in ShipBuilder palette
			- Materials have optional description ID's (from enum)
			- All strings in LocalizationManager
				- ~"Structure"+"Form/Variant/Kind/Genre/Class"
		- New materials:
			- Structural materials:
				- "Lightning rod" material
					- Has precedence when looking for candidates @ Lightning strike
				- Uranium 235
					- "A single pixel of uranium when smashed with a hammer or cut with a chainsaw causes a huge explosion the size of the titanic. And it glows blue when you put in underwater."
				- New metal color (for White Line): F1D4A1
			- Electrical materials:
				- Backup generators: would activate 10 seconds after connection is cut from the main power and it would power the lights only
				- Non-Instanced Watertight Doors (see if possible)
				- Non-Instanced Water In/Out Pumps (see if possible)
				- Clamp
					- A and B types
					- When powered, destroys all springs between each pair of powered A and B points
					- Make ship with lifeboats, using multiple clamps to keep it
				- Flickering lights
					- Lights that flicker forever
				- Logic Gates
					- ...to be worked on...
				- Delayed switch
					- Different durations
					- Simple state machine @ UpdateAutomaticConductivity
					- Gfx: Clock dial (normalized on duration), new ElectricalControl
					- Sound: clock
				- Thermal switch
				- Solar panel
					- Like generator, but only generates power when daylight above threshold, *and* when on frontier

	- "Soft" setting for ocean floors
		- Just less impact

	- Sediment on ocean floor
		- Things basically bury a bit
		- Could be adjusted to where players could see through it or not, to show how much is under the mud
		- Sediment could also preserve anything that is buried under it


	- Transfer of momentum from waves to ship
		- When ship surface intersects water surface
		- Option A: by point visit; all points which were not underwater in previous step and are now (via double buffer for Points::CachedDepth), receive force
		  proportional to OceanSurface::VelocityVector
			- OceanSurface::VelocityVector: direction=normal, magnitude=SWE velocity. With two options:
				- A) SWE + Waves (i.e. full samples)
				- B) Just SWE
		- Option B: by point visit; all points in tiny band from depth 0, receive force...same as above....				

	- "Ground" material:
		- Spec:
			- It's just a material which stays in place and has no physical interaction. The idea is to help creating anchoring or any form of support for structures.
			  This will allow people to make bridges or towers, etc... And of course, we could have underground bases anchored to the ground or whatever.
			- Plus, given how you use textures already, perhaps there's a way to apply the ground texture on it as well
			- Could be couple with ship+settings file, to also provide custom terrain

	- Different scale for ships
		+ Metadata now has Scale member to convert ShipSpace into WorldSpace
		- Use at:
			= ShipFactory
			- ShipLoad Preview Window, when displaying size

	- Time slowing down, both automatically (at explosions, at big events, etc.) and by user

	- Spread out spring coeffs' recalculations (*)
		- For better look'n'feel

	- Electric sparks: material-driven
		- New "electrical conductivity" *structural* property - try to name it differently than the electrical property though
			- First off, need "Material Type" rearc (*) just for helping a script that populates electrical conductivity automatically in material json
		- New springs ranking: f(direction + conductivity)

	- Air bubbles with proper vortices, due to water moving fast around it
		- Like at https://youtu.be/KPsnUPIHZuM
		- Kinda as if the originating ship particle's velocity at the moment of generation has a (decaying) impact on the air bubble particle, making it move like an orbit

	- Generalized light emission
		- TODO: obsolete due to "Light Sources" work above
		- Option 1:
			- Points gets struct with:
				- Luminiscence (scalar float) (aka Available Light)
				- Distance coeffs
			- ElectricalElements writes into Points
				- Luminiscence (out of lamp state machine update)
				- Distance coeffs (at game parameter changes)
					- MaterialLightSpread and MaterialLuminiscence are renamed as "Lamp" properties
					- Alternatively: reaction to game parameter changes is at Points, which also stores individual (immutable) particle properties (LightSpread and ~Luminiscence) to be able to recalc calculated
					  values (i.e. distance coeffs) upon param changes, for all particles
						- ElectricalElements::Add(.) "copies" MaterialLightSpread and MaterialLuminiscence immutable particle properties to Points
						- Basically, Points has following:
							- Immutable particle properties + GameParameters -> Calculated particle properties (distance coeffs)
				- TODO: there are two Luminiscence here, rename:
					- Runtime (aka AvailableLight)
					- Material, immutable

			- Points also has fixed-size vector with indices of light-emitting particles
				- Zeroed out at beginning of Update()
				- Added to at each Luminiscence population, i.e. at:
					- ElectricalElements::Update
					- Combustion update
					- Ephemeral update (e.g. of firework sparks)
			- Ship::DiffuseLight populates algo work buffer from Points' vector of indices
		- Option 2:
			- Ship::DiffuseLight populates buffers twice, from:
				- ElectricalElements::Lamps (like now)
				- Points::LightEmittingParticles
					- The latter builds vector of indices at its various Update()'s that contribute to lights, e.g. combustion low freq and/or ephemeral update

	- Fireworks (*)
		- Spec:
			- 2 triggers: toggable thing like bombs, and electrical element that launches when powered
			- State machine of detonated firework owned by ephemeral particles in conjunction with IShipPhysicsHandler
			- 3 initial types:
				- Flair
				- Rose: sparkles radiating immediately from explosion point
				- MultiRose: sparkles radiating with delay from (invisible) sparkles radiating from explostion point
		- Impl:
			- New GadgetType
			- New GameTypes enum: Firework(Kind)Type: Flair, Rose, MultiRose
			- New electrical material: FireworkLauncher X each kind
				- Type: FireworkLauncher
				- Firework(Kind/Type): enum
			- New structural materials:
				- FireworkVector: ~wood
				- FireworkSparkles: ~paper
			+ "Bombs" become "Gadget"
				+ Gadgets::Trigger[RCs,...,FWs]
					+ Visits all IGadgets, and switches on GetType() to invoke specialization-specific Trigger[RC,...,FW]
				+ Event handlers as well
				+ Test all 4 bombs
					+ Place, Remove, Trigger, Explode
			- Points::CreateFirework[Vector|Sparkle]EphemeralParticle:
				- Args:
					- Firework(Kind/Type)
					- Pos, Vel
				- Based on FW type:
					- Alpha, color
				- If needed adds to LightSources
					- ...which is arg to Points::Create...()
			- EphemeralParticle state machine:
				- Vector: on expiry, remove from LightSources 
					- ...which is arg to Points::UpdateEphemeralPoints...()
			- IShipPhysicsHandler:
				- LaunchFirework(fwType, pos, direction)
					- Invoked by: interactive firework detonation, gadget auto-trigger @Gadgets::Update() (e.g. because of temperature), 
					  ElectricalElements::Update (sink)
					- Does: sound, Points::CreateFireworkVectorEphemeralParticle
				- BlastFireworkSparkles(fwType, pos)
					- Invoked by: EphemeralParticle state machine (end of vector)
					- Does: sound, N X Points::CreateFireworkSparkleEphemeralParticle
			- Tool
				- Icon: rocket on tube, out & in
			- Texture + specific shader for Gadget
			- MainFrame & Place/Remove events for menu enabling
			- Sounds
			- ElectricalElements state machine
			- Retrofit a ship
			- GFX (Shaders & Primitives):
				- FireworkVector
					- Params:
						- Vector: direction & magnitude used for quad
						- Scale: world size of square side perpendicular to vector; also side parallel to vector when |vector|==1
							- Used for quad
						- Color: used @ shader
						- [Texture]SpaceCoords: calc'd at quad and used @ shader
						- Halo: 0.0->Halo: hi-brilliant; Halo->1.0: no brilliant going to zero
							- Use narrow SmoothStep for narrow halo transition
							- Used @ shader
				- FireworkSparkle
					-


		- Implementation:
			- Triggers: both options below
			- Once triggered:
				- Rocket flying is one ephemeral particle;
				- Upon expiration invokes IShipPhysicsHandler::ExplodeFirework, which generates new ephemeral particles
			- These various ephemeral particles are also (ephemeral/dynamic) light sources
		- TODOHERE: triggers are both options below
		- Option 1: it's a gadget like bombs
			- "Bombs" become "Gadgets", as well as "IBomb"
			- "Firework" is new gadget
			- Placed by new "Firework" tool, clicking on same rotates through all types + removal
				- Type enum at GameTypes
			- State machine:
				- Ignited by heat (and by water?), and by explicit detonation action
					- Each detonation action triggers one firework detonation, until no more fireworks exist
				- Creates ephemeral particles as needed, and tracks them (remembers their ElementIndex)
				- Also expires ephemeral particles
			- Disadvantage: once fired it's gone?
		- Option 2: it's an electrical material, ignited at 0->1 power transition
			- State machine is started by ElectricalElements::Update via IShipPhysicsHandler
			- State machine takes care of flight and explosion, and of spawning ephemeral particles for sprakles/lights
			- Advantage: same element may keep firing over and over

		- OLD
		- New emitter material, much like smoke emitter
			- Or just new electrical material ?
		- Fires when wet for the first time
			- Or when powered?
		- "Whatever color block it's on it explodes that color" (AwesomeYorkie)

	- Superheated pulverization
		- In small neighborhood of very high threshold - say, 100K degrees, not material-specific - rotting skyrockets

	- Multiple electrical layers:
		- Option 1:
			- Implemented by array of ElectricalElements at Ship
				- Points has also an array of ElectricalElementId, one for each layer
		- Option 2:
			- If ElectricalElements doesn't use springs but own connections, just need Points to have an *array* of electrical elements ID
				- Then ElectricalElements is just flat set of N connected components, one per layer (or more for disconnected circuits in same layer)
				- Think if it would really fly for all features
		- Interaction with Sources of light:
			- If a particle is a source of light on multiple layers at the same time, then the particle will appear in Source of light multiple times
				- Points (ephemeral points): these always implicitly live on layer 0, so on first ElectricalElements
				- Lamps (electrical element): these are by definition per-layer (duh)
		- OLD:
		- Option A: H and V electrical cables
		- Option B:
			- Only the cables should be able to make 8 connections (sides + diagonals)
			- Any devices should only be connected in 4 direction (sides only)
		- Option C: multiple electrical layers

	= Ocean floor deforming upon impact (*)
		! Better done after frontier work, so that may calculate pointness
		+ ParentWorld exposes DisplaceOceanFloor(x, offsetY)
		- @ Ocean floor collision: upon (non-orphaned) point entering floor:
			- Ocean floor's H goes back (opposite) by displacement * FloorFriability * f(pointness, massiveness)
				- displacement is whatever displacement we moved (bounced) the point by
				- FloorFriability = new param [0.0, ..., 1.0]
				- pointness = TBD, based off frontier
				- massiveness = point's connected component size
		- WATCH OUT: might be ugly with peaks (very vertical slope)
			- Increase resolution of ocean floor - shouldn't impact perf other than for cache misses
			- Another way to reduce the warping is to have varying resolution, btw - e.g. the ocean floor becoming more detailed where an impact happens
				- That could also open up to simulating a layer of sand that gets disturbed with the impact, without having to use particles, but by just playing with that higher-resolution "bitmap"
		- Could also have a "dust cloud" effect


	- Richter reading upon impact (see https://www.quora.com/How-fast-did-the-Titanic-sink-to-the-bottom-and-did-it-make-a-noise-when-it-hit)


	- Gases:
		- Spec:
			- Drawn on separate layer and act as water, but with upside down gravity
			- It will leak through holes
			- Gets destroyed by water
			- Causes air buoyancy
		- Can be implemented as a parallel Point::Water system
			- It will only slow down marginally, and only when the user specifies a gas layer

	- Newton's 3rd law:
		- Emitter materials, like smoke (and a new "jet engine" one), should impart an opposite force on the emitter
		- Jet engine: need a way to render flames/particles coming out

	- Aerodynamic heating https://en.wikipedia.org/wiki/Atmospheric_entry, something like friction from the air

	- Air drag is thinner moving up, @ MaxWorldHeight it's open space

	- Lightning tool that summons lightning wherever it has been clicked
		- Lightning pointer: basically instead of lightning at random, you click and lightning strikes where you click

	- When lightning hits (a metal part of) the ship, then lights should go off temporarily

	- Fires break out where electrical layer breaks (e.g. where *powered* line is cut)

	- Tool to break enough to let water enter, but not to make a hole all the way to the other side
		- Just sets points as leaking

	- Randomize decay
		- Perlin noise on ship, created at ShipBuilder, stored as Points::WeakNoise
		- Used as rotting increase
			- From PM: also, idk if you do it already, but it would be fun if the speed of decay was pseudorandomized not by much but just enough so it would cause uneven patterns of decay along the ships
		                   it would simulate defects in the hull or something
				   the only way I have to help visualising what I mean is by adding some noise on top of an image of the ships and the darkness of the colour would represent the rate of decay

	- Underwater currents
		- Option 1:
			- New piecewise line across ocean:
				- Divide the ocean width in N chunks (N ~=256)
				- Each chunk boundary gets a point that moves slowly, randomly, and sinuisodally up and down
				- Each imaginary line connecting two adjacent points is the line along which bodies feel most force; the further from the line, the least
					- The gradient from the line should be enough to impart a rotational force to bodies close to the line
		- Option 2 (older):
			- Implicit function of x defines trajectory
				- To try:
					- Constant
					- Lorenz, from http://sprott.physics.wisc.edu/chaos/eulermap.htm
					- Lorenz II, from https://en.wikipedia.org/wiki/Lorenz_96_model
					- OceanSurface profile, but x-shifted
			- For each point: y-distance between point.y and trajectory(point.x) gives strength of x and y components of a force on the point
			- Dynamics:
				- Ship gets UnderwaterCurrents object from parent world
					- May be also give OceanSurface and nuke IsUnderwater/GetWaterDepth from World
			- Rendered (via option):
				- Texture is distorted depending on force field
				- TBD: see moleskine

	- Dynamite that may be thrown to the ship

	- Dive bomb:
		- The player drops it the sky and into the sea; the bomb goes below the waves for a bit and then refloats and
		  hits the bottom of the ship
		- Needs frontier

	- Breaking waves (Muller's paper)

	- Test:
		- Self-adjustment of kSpring and kDamp based off paper's formula (H and L bounds)
		- Debug to see if bounds ever exceeded

	- Frozen structure (*):
		- Physics:
			- Prep: allow temperatures to go below 0 but exponentially towards -273.15
				- Check curve for Dt=?Dq/T
				- At:
					- Air temperature
					- Water temperature
					- CoolBlaster tool
					- ...and everywhere else we update Points.Temperature
			- Freezing effect: simply, in low-frequency spring coeffs' Update(), also do other side of temperature spectrum:
				- With breaking length becoming smaller
				- With rest lengths staying the same
					- Or negligibly smaller? Or negligibly larger? To simulate volume change...
				- Stiffness approaches 1.0 (when from below, e.g. for rope)
		- Shader:
			- Reuse shader's temperature buffer: when negative, clamp by personality seed
				- And personality seed is also needed by shader for color saturation
				- Add personality seed to set of immutable attributes, uploaded @ beginning

	- Stars with database
		- python script to generate binary maps for N and S emispheres

	- Torpedoes and missiles and mines
		- "You place one down and click where it speeds off to and explodes at. Basically a moving bomb that explodes
		   when it reaches a destination, be that under water, or on the water."
		- "Missiles: like before, but above water"
		- Doesn't require collision detection right away; would detonate:
			- By button
			- By proximity with an AABB
			- (w/collision detection) by collision
		- Might either have own propulsion or follow a vector specified with click-and-drag
		- Also other objects might be launched with click-and-drag
		- Ideally, have their own physical body - kinda like (or exactly like) another ship

	- Ripple: "basically you click and hold somewhere on the ship, and when you let go, it sends a ripple into the ship, weak points might tear,
	  or start getting damaged, etc."


- Game Interactions and Controls:

	- Randomized start
		- Done by new method at SettingsManager, by choosing settings (system & user) weighted by new optional probability attribute
			- Proability at SettingsDialog
			- "defaults" (not a setting, just hardcoded) have own hardcoded probability
		- Add new system settings, with probs:
			- Starry night 0/10
			- Quiet sea 4/10
			= Blue world (sky: 0, 119, 196; find ocean, rest like quiet sea) 2/10
		- Triggered on/off via Game Preferences
			- Default off

	- Ship carries with it:
		- Overriding/addition of materials
		- Sounds (Ship Custom Sounds (*))
		- Changes to settings

	- Interior layer (multiple textures):
		- NOTE: not really useful as normally different textures require different structures
		- JSON: texture is optionally an array
		- ShipDefinition: texture is vector
			- Always non-empty
		- GameEventHandler::OnShipLoaded tells how many textures
		- MainFrame menu item: "Toggle Ship Layer"
			- Initially disabled
		- MainFrame @ OnShipLoaded enables/disables menu item based on whether at least 1 ship has > 1 textures
			- Stores count of textures as well
		- ShipRenderContext has array of textures
		- RenderContext->ShipRenderContext::ToggleShipTexture(int advance)
			- ShipRenderContext swaps textures
		- Merge multi-layered ships
		- Test
		- How to Guide

	- New tool: slingshot
		- "You hold down the left click, and pull back and aim - and it would fire somethin like a cannon ball or wrecking ball like projectile"

- UI:
	- Automatic contrast for the cursor, e.g. for when it's at depth

	- Searchbar for settings

	- Settings window: would be better to just have the settings properly minimize and have it be visible either when you use the button or search for it in the taskbar,
	  rather than the current annoying behavior

	- Also "clock time since last reload" would be helpful
		- Add Game Preferences radio to select clock type

	- ShipLoadDialog improvements:
		- Display folders in grid
			- If we want to keep them as info tiles, sorting need to leave them at bottom - e.g. by always sorting them last
				- We would also need different new info tile types: file or folder

	- Localization:
		- Keyboard shortcuts
			- But also MainFrame needs to know mappings, as it's MainFrame that reacts to key presses
		- Make NotificationLayer text translatable too
			- Requires a LocalizedText instance, passed to GameController from MainFrame
				- At this point, replace "ProgressMessage" enum with simply "Message" enum, and move localization of progress messages from splash screen to LocalizedText
			- But requires fonts
		- Ships' electrical panel labels:
			- First off, verify JSON can contain UTF-8 chars
			- Then, allow multi-language labels: label value is either string or {Lang, String}
		- MSI Installer

	- Customizable key bindings for settings

	- Ship descriptions: use Mike's drawings

- Sounds:

	- Ship Custom Sounds (*)
		- Ship may come with custom sound(s) for horns et al 
		- New electrical material: "Custom sound switch"; first one plays sound #1, second one play sound #2, etc.
		- Need to find way for ship-loading process to communicate sound file (buffer) to SoundController
			- At Electrical announcement! passing buffer as MemoryStream, or filename
		- Might be better done after ship builder, so that we may package sounds better in .shp2 files

	- Voices:
		- For ships with engine and electric systems, a voice says "Half Ahead on Engine 3" or "Pumps ON" and things like that, of course depends on the gameÂ´s language, 
		  for example in spanish it will be "Media Velocidad en Motor 3" and "Bombas Encendidas"
			- Joadix for Spanish
			- Tim for English
		- Multiple voices for the same sound
		- Disabled by default (people might hate them)

	- Sounds that play before ship starts sinking
		- SOS, bell, sailor screaming, etc.
		- Office TimCan provides the sounds

	- Morse code sound when it's about to sink (early sink detection)
		- Or at first drop of water
		- Morse code: text-to-morse encoder would be cool
			- Default "S.O.S.", also customizable via ship property

	- New sounds:
		- Ship sinking: https://www.youtube.com/watch?v=-f2B_bzcgV8
		- ShipSoundsForFS (in Scratch)

	- Sound space (*):
		- 1) Volume of effects should depend on distance/zoom
			- "Sounds' volumes that depend on the distance of their source from the visible field"
		- 2) Position of effects (L/R) should depend on world position re: camera
		- Tracking positions:
			- Events take global object ID
			- SoundController can access Position() buffer of each ship, and thus access positions at Update() and update
			  sound position

	- Sounds rearc:
		- ISoundManager
			- Implemented by both single sounds and composite/aggregates
			- Reset() // full reset, including container-stuff
			- Pause()/Resume()
			- SetMuted(isMuted, Group)
			- SetGroupVolume(vol, Group)
		- Sound (or "GameSound")
			! Base of all simple sounds
			- cctor(...Group...)
			- GetGroup()
			- SetGroupVolume(float)
				- On top of SetMasterVolume & SetVolume

-Probing:
	- IProbe:
		- World and Ship take shared_ptr<IProbe> and store it, exactly like IGameEventHandler
		- Single instance of IProbe is ProbePanel, which is given to GameController::cctor by Frame at initialization
		- Example IProbe methods:
			- void ProbeWaterSplashed(float waterSplashed)
				- One scalar, pass through to ScalarTimeSeriesProbeControl (iff IsActive)
			- void ProbePointForces(vec2f const *)
				- For other things at different steps in the simulation algorithm
				- IProbe knows whether it cares about a specific point and, if so, takes that and draw is
				- IProbe might also create stats
	= ProbePanel
		+ Pre-created member of MainFrame
		+ Then exposes Update() invoked by MainFrame, always, after simulation step
		+ Update():
			+ if not visible, return;
			+ Draw current Statistics from current StatisticsProbe
		- TBD: mechanism to select point, etc. from ship, which will be used for probing afterwards
	- Histograms:
		- class Histogram
			- map<float, float in [0,1]>
		- class Statistics (various Histograms, etc.)
			- Histogram pointWaterHistogram
			- ...

- Resource Packs

	- Resource pack contains:
		- Subset of textures
		- Subset of shaders
		- Subset of settings
		- Subset of materials, and new materials
	- Impl:
		- Data\Resources\{Default, <Pack name>}\
			- Textures\
			- Shaders\
			- settings.json
			- materials_structural.json
			- materials_electrical.json
			- metadata.json
				- author, description, name
			- Misc\
				- For ocean bumps
		- ResourceLocator:
			- Static methods only for default paths
				- e.g.: GetDefaultTextureDatabaseFilepath()
			- 1 static method to get list of non-default ResourcePackMetadata's
			- cctor takes optional pack name
			- Instance methods for *optional* pack-override paths
				- e.g.: GetOverrideTextureDatabaseFilepath()
			- Each "DB"'s Create(...) takes a ResourceLocator const &
				- Own responsibility to check if override exists and, if so, to load override and reconciliate
			- No more methods that load DB's
		- Switching:
			- Ad-hoc MainFrame dialog showing ResourcePackMetadata's
				- Chosen one goes to UIPreferencesManager
				- Checkbox for "Set as default" => UIPreferencesManager::Save()
				- At Save, before saving - notify that a reload is necessary

- Multiple ships:
	- Better done after collision detection
	- When ship loaded (added):
		- World adds it not to mShips, but as opt<Ship> mPendingShip
			- Not considered in Update(), but considered in Render()
		- MainFrame begins new PendingShipPlace tool
			- OnMouseMove: tell GameController (->World) mouse position as GameController::MovePendingShipTo(screen coords)
				- Ship::MoveTo(world x, y):
					- Moves all Points by (x,y)-mCurrentRepresentativePosition
						- Ship::mCurrentRepresentativePosition (init'd as {0,0}) tracks current "center"
					- mCurrentRepresentativePosition = (x,y)
			- OnLDown:
				- Tell GameController (DropPendingShip(x, y)) which:
					- Tells World via World::DropPendingShip(x, y):
						- Final Ship::MoveTo()
						- Move ship from mPendingShip into mShips
					- Fires IGameEventHandler::OnPendingShipPlaced(shipId)
						- EventTicker: say this and other Reset/Load
						- SoundController: play sound
				- Stop PendingShipPlace tool

- Passengers:
	- Ship has number of passengers
		- "like how many people would be aboard & as the ship sinks it like shows how many people are alive, escaped via life boat or died"
		- Maybe a life count? like you have sorta a life count on the top right of the screen that says Alive: number. Dead: Number.
		  And as the ship is sinking you press a button like say A (abandon) for example and people will start heading to the life boats
		  to survive. The counter will stop once the ship is fully under the surface of the ocean or the entire boat deck is under water.
		  The boat deck would be highlighted sorta like how the light system works.

	- Moving passengers
		- Separate layer provides floors, ladders, and obstacles
		- Can get away at beginning with pacman-like figures
		- For more realistic version:
			- Skeleton with 10 parts (8 limbs, body, head)
			- Need to make these actions:
				- Walk
				- Fall
				- Climb
				- Swim

- Collision detection - for multiple ships
	- Nearest neighbor: http://www.cs.umd.edu/~mount/ANN/

==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==== PERF
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================

=================================================
Current perf:
=================================================
1.16.5:
- default ship:
	- Old dell, RelWithDebInfo: FPS:30.65 UPD:19.5ms UPL:0.18ms RND:12.80ms
- Perf analysis: default_ship, between 10s and 30s (run stopped after 20s displayed):
	- GameController::RunGameIteration: 86.52%
		- World::Update: 85.21%
			- Ship::Update: 81.50%
				- Ship::ApplySpringForces_BySprings: 56.98%
				- Ship::UpdateWaterVelocities: 7.50%
				- Ship::HandleCollisionsWithSeaFloor: 4.24%
				- Ship::IntegrateAndResetSpringForces: 4.02%
				- Ship::PropagateHeat: 2.48%
				- Ship::EqualizeInternalPRessure: 2.02%
				- Ship::ApplyWorldForces: 1.34%
				- Springs::UpdateForStrains: 1.01%
				- Ship::ApplyStaticPRessureForces: 0.02%
				- Points::UpdateMasses: 0.33%
				- Ship::TrimForWorldBounds: 0.31%
				- Points::UpdateEphemeralParticles: 0.22%
			- OceanSurface::GenerateSamples: 2.04%
			- OceanSurface::Update: 1.42%
		- World::RenderUpload: 1.08%
=================================================
1.16.4.next, during Hydrostatic pressure
- default ship: Update=4.66ms
=================================================
1.16.3.next, after OpenGL optimizations (edge springs, etc.)
- default ship, 20s
	- Old dell: 31.9 FPS, 19.1 UPD, 11.8 RND (RelWithDebInfo)
1.16.3.next, after periodic CollisionsWithSeaFloor, and Points::CachedDepths:
- default_ship, 20s
	- Old dell: 30.4/30.5 FPS, 18.8/19.1 UPD, 12.7/13.6 RND (RelWithDebInfo)
	- New Dell: 4.45 UPD, 5.35/5.38 RND (RelWithDebInfo)
- GameController::RunGameIteration: 86.72%
	- World::Update: 85.69%
		- Ship::Update: 83.59%
			- Ship::ApplySpringForces_BySprings: 60.63%
			- Ship::UpdateWaterVelocities: 8.76%
			- Ship::HandleCollisionsWithSeaFloor: 4.73%
			- Ship::IntegrateAndResetSpringForces: 3.60%
			- Ship::PropagateHeat: 2.08%
			- Ship::ApplyWorldForces: 1.62%
			- Springs::UpdateForStrains: 0.93%
		- OceanSurface::GenerateSamples: 1.27%
		- OceanSurface::Update: 0.55%
	- World::RenderUpload: 0.86%
=================================================
- After initial 1.16.3 perf optimizations:
- default_ship, 40s, in [6s, 49s]
	- Old dell: 30.20 (RelWithDebInfo)
- GameController::RunGameIteration: 86.94%
	- World::Update: 86.17%
		- Ship::Update: 84.40%
			- Ship::ApplySpringForces_BySprings: 56.69%
			- Ship::HandleCollisionsWithSeaFloor: 9.00%
			- Ship::UpdateWaterVelocities: 8.45%
			- Ship::IntegrateAndResetSpringForces: 4.01%
			- Ship::PropagateHeat: 2.29%
			- Ship::ApplyWorldForces: 1.61%
			- Springs::UpdateForStrains: 1.08%
			- Points::UpdateMasses: 0.41%
			- Ship::DiffuseLight: 0.37%
			- Ship::TrimForWorldBounds: 0.25%
			- Ship::UpdateWaterInflow: 0.10%
		- OceanSurface::GenerateSamples: 1.20%
		- OceanSurface::Update: 0.30%
=================================================
1.16.0
- DELL new (default_ship): FPS=62.9 UPD=4.8ms RND=4.3ms
- DELL old (default_ship, basic ocean): FPS=29.8/30.0 UPD=20.4ms, RND=12.6ms/12.9ms
- HP (default_ship, basic ocean): FPS=20.4 UPD=48.05ms RND=14.2ms
- Samsung (default_ship, basic ocean): FPS=23.4, UPD=42.3ms, RND=7.8ms 
=================================================
1.14
- After forces rearc and iterations=30: FPS=30.16, Ums=22.5
- Call tree (45 sec game play, w/out PostInitialize):
	- MainFrame::OnGameTimerTrigger: 90.91%
		- World::UpdateAndRender: 87.23%
			- Ship::Update: 62.09%
				- Ship::UpdateMechanicalDynamics: 52.50%
					- ApplySpringForces: 39.15%
					- HandleCollisionsWithSeaFloor: 6.73%
					- IntegrateAndResetSpringForces: 5.57%
					- ApplyWorldForces: 0.40%
					- UpdateMasses: 0.33%
				- Ship::UpdateWaterDynamics: 6.91%
				- Ship::UpdateHeatDynamics: 1.68%
				- Ship::UpdateForStrains: 0.81%
				- Ship::DiffuseLight: 0.23%
				- Ship::TrimWorldBounds: 0.15%
			- Ship::Render: 20.16%
			- RenderContext::RenderOcean: 1.54%
			- RenderContext::RenderStars: 1.19%
			- OceanSurface::Update: 0.24%
			- Wind::Update: 0.07%
		- wxGLCanvas::SwapBuffers: 1.42%
=================================================
1.13
- After DiffuseLight rearc: FPS=29.5, U/R=19
=================================================
1.12
- fps: 29.1/29.5/30.1
- UR: 221/227
=================================================
- fps: 29.2/29.4 (Samsung w/Krafting: 17.0)
- UR: 210/220 (Samsung w/Krafting: 690%)
- GameController::InternalUpdate: 62.0%
	- World::Update: 61.98%
		- Ship::Update: 60.92%
			- Ship::UpdateMechanicalDynamics: 49.92%
				- Ship::UpdateSpringForces: 36.50%
				- Ship::UpdatePointForces: 5.95%
				- Ship::HandleCollisionsWithSeaFloor: 3.63%
				- Ship::IntegrateAndResetPointForces: 3.59%
				- Ship::UpdateTotalMasses: 0.24%
			- Ship::UpdateWaterDynamics: 6.81%
			- Ship::DiffuseLight: 2.99%
			- Springs::UpdateStrains: 1.02%
		- OceanSurface::GenerateSamples: 0.74%
		- OceanSurface::Update: 0.24%
- GameController::InternalRender: 22.7%
	- Ship::Render: 19.30%
	- RenderSkyEnd: 2.16%
	- RenderOcean: 0.58%
=================================================
Before SWE:
- fps: 30.8
- UR: 224
=================================================
Before ocean/land rearc:
- fps: 30.5/30.5/30.7/30.85
=================================================
Before decay:
- fps: 30.7/30.7/30.8/30.9/32.0
- U/R: 193.x%
- RunGameIteration: TODO:86.62% (initialization time)
- World::Update: 60.25%
		- UpdateMechanicalDynamics: 49.32%
			- UpdateSpringForces: 37.99%
			- UpdatePointForces: 5.51%
			- HandleCollisionsWithSeafFloor: 3.38%
			- IntegrateAndResetPointForces: 2.30%
			- UpdateTotalMasses: 0.13%
		- UpdateWaterDynamics: 6.72%
			- UpdateWaterVelocities: 6.57%
			- UpdateWaterInflow: 0.08%
		- DiffuseLight: 2.94%
			- FastPow2: 1.44%
- World::Render: 22.54%
	- Ship::Render: 19.36%
	- RenderSkyEnd: 2.33%
	- RenderOcean: 0.70%
=================================================
Before Vertex Attribute Optimization:
- fps: 28.2/28.4 (miracle: 28.7/29.0/29.1)
- World::Update: 54.66%
		- UpdateMechanicalDynamics: 44.64%
			- UpdateSpringForces: 34.70%
			- UpdatePointForces: 4.88%
			- HandleCollisionsWithSeafFloor: 2.89%
			- IntegrateAndResetPointForces: 1.99%
			- UpdateTotalMasses: 0.15%
		- UpdateWaterDynamics: 6.29%
		- DiffuseLight: 2.62%
- World::Render: 28.24%
	- Ship::Render: 25.11%
	- RenderSkyEnd: 2.23%
	- RenderOcean: 0.77%
=================================================
Before VAO:
- fps: 28.1/28.3
=================================================
Before bound world and point light<->ambient light additiveness:
- fps: 29.0/29.2/29.4
=================================================
Before Z buffer:
- fps: 30.2/30.6/31.2
=================================================
Before wind:
- fps: 30.8/31.0/31.3
=================================================
Before exp optimization:
- fps: 30.8/31.0/31.3
- World::Update: 58.48%
		- UpdateMechanicalDynamics: 48.44%
			- UpdateSpringForces: 38.25%
			- UpdatePointForces: 4.47%
			- HandleCollisionsWithSeafFloor: 3.43%
			- IntegrateAndResetPointForces: 2.10%
			- UpdateTotalMasses: 0.19%
		- UpdateWaterDynamics: 7.79%
			- UpdateWaterVelocities: 7.64%
		- DiffuseLight: 1.31%
- World::Render: 28.15%
	- RenderContext::RenderCloudsEnd: 3.98%
=================================================
Before diffusion improvement:
- fps: 31.5/31.7
=================================================
Current perf (spring optimization + double spring iterations)
=================================================
- fps: 31.3 (Samsung: 20.3 (Krafting)) (Mattia's: 15.5 (Krafting))
- World::Update: 57.05%
	- Ship::Update: 56.89%
		- UpdateMechanicalDynamics: 47.56%
			- UpdateSpringForces: 37.08%
			- UpdatePointForces: 5.30%
			- HandleCollisionsWithSeafFloor: 2.92%
			- IntegrateAndResetPointForces: 2.26%
		- UpdateWaterDynamics: 7.83%
			- UpdateWaterVelocities: 7.72%
- World::Render: 28.15%
	- RenderContext::RenderCloudsEnd: 3.98%

=================================================
Past perf (ephemeral particles)
=================================================
- fps: 28.8/29.0
=================================================
1.7.0 perf from users
	- Titanic: 50
	- Titanic: 55
	- Titanic: 48.3

=================================================
1.6.0 perf
=================================================
- fps: 29.6 (Samsung: TBD:31.5 (Krafting)) (Mattia's: TBD:25.1 (Krafting))
- GameController::Update: 35.06%
	- Ship::Update: 34.33%
		- UpdateMechanicalDynamics: 25.70%
			- UpdateSpringForces: 18.80%
			- UpdatePointForces: 3.45%
			- HandleCollisionsWithSeafloor: 2.45%
			- IntegratePointForces: 1.00%
		- UpdateWaterDynamics: 7.83%
			- UpdateWaterVelocities: 7.73%
			- UpdateWaterInflow: 0.05%
		- UpdateStrains: 0.78%
	- DiffuseLight: 0.58%
	- WaterSurface::Update: 0.11%
- World::Render: 57.00%
	- ShipRenderContext::RenderEnd: 52.87%
	- RenderContext::RenderCloudsEnd: 1.49%
	- RenderContext::RenderStart: 0.50%
	- Ship::Render: 0.14%
		- UploadPoints: 0.12%
	- RenderContext::RenderWater: 0.05%
	- World::RenderClouds: 0.04%
		- fmodf: 0.02%
	- RenderContext::RenderLand: 0.01%
- RenderContext::RenderEnd: 0.35%
	- TextRenderContext::RenderEnd: 0.35%
- wxGLCanvas::SwapBuffers: 1.07%
=================================================
NoInline
- World::Render: 53.36%
	- ShipRenderContext::RenderEnd: 49.69%
		- ig4: 49.22%
		- RenderRopes: 0.43%
		- ...
	- RenderContext::RenderCloudsEnd: 1.37%
	- RenderContext::RenderStart: 0.46%
	- RenderContext::RenderWater: 0.04%
	- World::RenderClouds: 0.02%
		- fmodf: 0.01%
	- Ship::Render (with uploads): 0.15%
	- RenderContext::RenderLand: 0.01%
	- RenderContext::UploadLandAndWaterEnd: 0.04%
	- RenderContext::UploadLandAndWater: 0.03%
- RenderContext::RenderEnd: 0.30%
=================================================
Render:
	- No Ship::RenderEnd: 64fps
	- Only springs: 30fps
	- Only triangles: 42fps
=================================================
1.3.0 perf
=================================================
- fps: 27.3
- GameController::DoStep: 33.06%
	- Ship::Update: 32.07%
		- UpdateDynamics: 25.53%
			- UpdateSpringForces: 18.72%
			- UpdatePointForces: 3.55%
			- HandleCollisionsWithSeafloor: 2.27%
			- Integrate: 0.98%
		- GravitateWater: 4.60%
		- BalancePressure: 1.06%
		- UpdateStrains: 0.83%
		- LeakWater: 0.03%
	- DiffuseLight: 0.89%
	- WaterSurface::Update: 0.09%
		- sinf: 0.07%
- MainFrame::RenderGame: 60.47%
	- ShipRenderContext::Render: 53.52% (Incl) 0.00% (Excl)
		- ShipRenderContext::RenderSprings: 30.72%
		- ShipRenderContext::RenderTriangles: 22.29%
		- ShipRenderContext::RenderRopes: 0.45%
		- Points::Upload: 0.14%
	- RenderContext::RenderCloudsEnd: 2.87%


==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==== DONE
==============================================================================
==============================================================================
==============================================================================
==============================================================================
==============================================================================

+ Build glfw yourself
	+ clone from git
	+ build
	+ fix Ship's CMake
		+ C:\Users\Neurodancer\source\build\glfw\src\Release
+ move to source/build:
	+ ShipSandbox

IF WX:
+ build WX (Debug, Release)
+ add WX to CMakeFiles.txt
	C:\Users\Neurodancer\source\repos\wxWidgets\include
	C:\Users\Neurodancer\source\repos\wxWidgets\lib\vc_x64_lib
		names: wxmsw31u[d]_core.lib wxbase31u[d].lib
+ remove titanicapp.*, titanicmain.* from CMakeFiles.txt
+ do a simple main with wx
+ rebuild WX with C++ Runtime being statically linked
+ test
+ see getting rid of whole wx.h and only include wxwindow
+ get rid of GLFW in all source files
+ setup CMakeFiles.txt: Remove GLFW
+ resuscitate old code, merging it with new existing structure:
	+ mainApp - mainApp class, main #define
	+ mainFrame - entire frame
+ test
+ remove titanicapp.*, titanicmain.*, main_old.cpp
+ one-shot timer
+ nuke GLFW from hard disk (repo, build)
+ add logger and fix missing ship

+ Get perf baseline and start Readme.md and Changes.tx
===========
+ cherry-pick that typo fix
+ logging window: try http://docs.wxwidgets.org/3.0/classwx_text_ctrl.html
+ rename members of Frame, cleanup code

+ Render/Game"Settings" -> "Parameters"
+ LoggingWindow -> "Dialog"

+ SettingsDialog:
	+ Add spacing
	+ Taller sliders
	+ Min and Max
	+ add textboxes 4 vals
	+ ApplySettings()
		+ GameController takes (& gives) absolute vals, & provides GetXMax/MinValue() (from YYYParameters)
		+ Helper funcs in SettingsDialog do conversions
	+ ReadSettings()
	+ Other controls for other settings
	+ rename members, cleanup code

+ MainFrame:
	+ LogWindow bug when minimizing and maximizing main frame
	+ Do we need mMainGLCanvas and context to be unique_ptr's?
	+ Render once @ beginning
		+ Check if OnPaint is the right one
	+ Maximize
	+ ReloadLastSelected
	+ See if canvas.setcontext is necessary
		+ Watch out for resize
	+ +/- for zoom *IN MENU*
		+ remove wxEVT_CHAR_HOOK at panel and use menu hotkey and event instead

+ Investigate dirty lines

+ Use own exception

+ Fix DestroyAt
	+ Add DestroyRadius to GameParameters (not in SettingsDialog yet)

+ Fix final destroyer

+ Setup UnitTests
	+ Build GTest Debug and Release
	+ Create UnitTests project in CMake
	+ First unit test: vectors

+ GameException: cctor with string
	+ Utils::Convert(string)->wstring

+ Rebuild Devil but make it a dll with static runtime
+ Move DevIL init to GameController
	+ No DevIL dep's in ShipSandbox
	+ DevIL_INCLUDEs from GameLib are not public

+ Move to picojson
	+ Nuke SDK
	+ Remove public-ness of JSonCPP

+ Settings:
	+ Destroy Radius
	+ "World"XYZ if really it is world

+ Frustum? For 2D? Try Ortho?

+ Change MainFrame's build info
	+ separate Version.h

+ Mask with copyright at all source files (copy from XXmain)
	+ Already capitalized
	+ Those to be capitalized
		+ material
			+ Rename
			+ cctors:
				+ from picojson obj
			+ Create()->UQ_PTR
				+ private cctor
				+ all members const
			+ optional Material::ElectricalProperties
		+ Also Renderer becomes a namespace, not a class
		+ render
			+ Renderer
			+ move ScreenToWorld here
			+ All static methods, inline
		+ util
		+ phys:
			+ Rename as Ship, World, Point, etc.
			+ TODO: see first if can split into separate files
				+ commit & push first
				+ cpp's in namespace
				+ Physics.h: includes all and each .h and .cpp includes Physics.h
			+ Private vs Public attributes:
				+ No friends
				+ All members mPrivate
				+ All getters and setters (when needed)
		+ vec

+ Simulation Optimizations:
	+ Move back to baseline
	+ Take profile X 2
	+ set these flags and see impact (on Release)
		+ Ox
		+ fp:fast
	+ Flags for non-MSVC:
				<Compiler>
					<Add option="-O3" />
					<Add option="-ffast-math" />
					<Add option="-fno-math-errno" />
					<Add option="-funsafe-math-optimizations" />
					<Add option="-ffinite-math-only" />
					<Add option="-fno-trapping-math" />
				</Compiler>
	+ Make all render() const
	+ Make all render() inline
	+ Make all vector funcs inline in .h
	+ Take full baseline first
	+ FPS: 17.3/17.7
	+ We don't need redundant triangles
		+ Row visit: for each point *after* the very first of a streak, only do triangles up to 90 degrees
			+ But keep doing all springs
			+ use boolean isInShip, init=false, set to true at end of single-point processing if point exists and set to false otherwise
		+ Before: 5231 points, 19932 springs, 19569 triangles
		+ After: 5231 points, 19932 springs, 9819 triangles
	+ FPS: 19.2/19.3
	+ Fix division by zero
		+ Do fix
	+ FPS: 19.1
	+ SSE2:
		+ Test first: Integrate:
			+ 1a: pack Pos, Vel, Force from 2 points into local vec4f
				+ For loop with two points at a time
			+ 1b: create buffers with all Pos, Vel, Forces, and call function with restricted pointers: IT USES PACKED SSE's!
		+ Undo
	+ Vertex cache optimizations with Forsyth's algo:
		+ Break out ShipBuilder, friend
		+ Use own LRU cache and calculate current ACMR for triangles and springs
			+ Spring ACMR: 0.516807
			+ Triangle ACMR: 1.01986
		+ Do triangle vertex cache optimization
			+ New ACMR: 0.68174
			+ FPS improvement: 19.1 -> 19.0
			+ Check if self-covering within same connected component now looks weird
			+ Test on samsung: 18.5/18.8 -> 18.5/18.6/18.8/19.0
			+ REVERT, IT'S (MARGINALLY) WORSE!
		+ Do spring vertex cache optimization
			+ New ACMR: 0.325156
			+ New FPS: 19.4/19.7
	+ FPS: 19.3/19.5
	+ ShipRendering: upload triangles, ropes, springs only when they change
		+ Have VBOs per connected component
	+ FPS: 19.0/19.4/19.7/19.9
	+ Point & Spring Destructuring:
		+ Starting FPS: 19.0/19.4/19.7/19.9
		+ Main goal: improve cache locality
		+ Secondary goal: make vectorization-friendly
		+ Replace Point, Spring, Triangle with Points, Springs, Triangles
			+ Base is ElementContainer
				+ Defines aliases (ElementCount, ElementIndex) - uint32
				+ ElementCount GetCount() const
					- Number of elements
					- passed at cctor
			+ They contain N buffers:
				+ Points: Position, Velocity, Force, MassFactor, Color, Water, IsDeleted ...
					+ All scalars of a point that are only used for both x and y (e.g. MassFactor) are stored
					 (and updated, if any) twice, as vec2f (only MassFactor?)
					+ All scalars of a point that are used as scalars (e.g. Buoyancy) are stored once
					+ Test first to see if N buffers make a difference vs 1 larger buffer:
						+ 1: Do Position, Velocity, Force, and MassFactors first in single Newtonz buffer
							+ Get baseline 1:
								- DoStep: 39.99%
									- Ship::Update: 39.05%
										- UpdateDynamics: 27.42%
											- SpringForces: 20.18%
											- PointForces: 3.77%
											- CollisionsWithSeaFloor: 2.19%
											- Integrate: 1.27%
										- GravitateWater: 5.70%
										- BalancePressure: 4.58%
										- UpdateStrain: 1.03%
								- Render: 51.69%
							+ FPS=24.0/24.2/24.4
						+ 2: Do separate Position, Velocity, Force, and MassFactors
							+ Get baseline 2:
								- DoStep: 39.01%
									- Ship::Update: 38.01%
										- UpdateDynamics: 27.44%
											- SpringForces: 19.97%
											- PointForces: 3.65%
											- CollisionsWithSeaFloor: 2.24%
											- Integrate: 1.57%
										- GravitateWater: 4.87%
										- BalancePressure: 4.51%
										- UpdateStrain: 0.90%
								- Render: 52.69%
							+ FPS=24.1/24.3/24.7/25.0
							+ Make buffer __restrict
							+ FPS=24.8/24.9/25.1
					+ If makes sense to explode:
						+ Also explode ConnectedComponent
				+ Phase 2: Springs: Points, dynamics coefficients, water coefficients, ...
				+ Phase 2: Triangles: Points, Network
				+ Phase 2: Change all ElementContainer::ElementIndex into ElementIndex
				+ Structure of buffers:
					+ For SSE2, need to be simple floats
					+ For handling, need to be structured
				+ Buffers are class Buffer
					+ Need to be mem-aligned
					+ cctor(size)
					+ data()/size()/emplace_back()
					+ uq_ptr
			+ They expose buffer getters for each buffer (as the structured type, e.g. vec2f *, or PointNetwork *, or float * for lonely scalars)
				+ e.g. vec2f* GetPositionBuffer()
				+ When needed also exposed as floats as well (e.g. Position, for Integrate())
					+ e.g. float* GetPositionBufferAsFloat()
					+ size math left to caller
			+ When needed, they expose getters and generally operations on single elements, via 32-bit index argument (aliased as ElementIndex)
				+ e.g. void Destroy(ElementIndex)
				+ e.g. float GetMass(ElementIndex)
			+ Destroy(ElementIndex) takes care of telling ship that element count is dirty
				+ Phase 3: set directly in Ship at initiation of Destroy chain, whenever we know we destroy something
					+ Do at Spring::UpdateStrain: returns bool, true if destroyed
					+ Do at tool's Destroy
					+ Then get rid of two-phase ship cctor - plain cctor with moved ElementRepo's
						+ So can also remove move assignment at Points
			+ Pointers to points are replaced by 32-bit indices
				+ Funcs that need to follow pointers (e.g. Destroy() and SpringDynamics()) also must take whole containers
				+ Phase 2: also pointers to Springs & Triangles
			+ ShipBuilder creates Points & moves into ship
				+ Points' ConnectedXYZ are updated at ShipBuilder time
					+ Remove code from Spring and Triangle and ElectricalElement-Cable-etc. cctors
			+ Do Ship
				+ Loop over indices, invoking Points::GetWhatever(index)
			+ End of Phase 1: FPS=22.0/22.3/22.6
			+ Phase 1.5: check assembly for:
				+ 1: loop over indices, invoking Points::GetWhatever(index)
				+ 2: loop over indices, taking buffers first and then dereferencing buffer with index
				+ RESULT: IDENTICAL
				+ Decide whether to keep bunch of GetWhatever(index) (both R and W) vs buffers
				+ Check also disassembly of index iterator
			+ End of Phase 1.5: FPS=23.2/23.3/23.4
			+ To check:
				+ UpdateDrawForces: see assembly difference for displacement.length() optimization
					+ NO, actually compiler autonomously saves length for later, and explicit
					  code looks a bit different
				+ UpdateSpringForces(): see assembly to check whether point.Force's are updated twice
					+ YES
					+ Update force once with sum of forces
				+ HandleCollisionsWithSeaFloor(): see assembly to check for twice GetPosition()
					+ YES, read once into xmm4 and re-used later
			+ End of checks after Phase 1.5: FPS=24.0/24.2/24.4
			+ Containers expose own Upload(RenderContext &)
				+ Phase 3: direct upload of buffers into GPU via RenderContext
					+ Nuke ShipRenderContext::mPointBuffer & friends
				+ Phase 3: move texture coordinates and colors into Points, which uploads
				  at Upload() via own mAreImmutablePropertiesUploaded state
					+ Nuke Ship::mIsPointCountDirty
					+ Nuke ElementRepository, as at this moment no one should be using it anymore
			+ Phase 3: Nuke PointerContainer
			+ Phase 3: Nuke ShipElement, if it's now only implemented by ElectricalElement
				+ See if managed to not need to tell Ship as well, see above
			+ Phase 3:
				+ Fix power-of-2 calculation at Buffer::cctor()
				+ Fix World::GetNearestPointIndexAt, by making use of Ship::GetPointPosition(idx)
					+ See square root optimization, here and @ Destroy()
				+ Also fix its use at MainFrame, by making use of Ship::GetStuff()
				+ Fix all warnings
		+ Phase 2: Integrate():
			+ After NewtonzBuffer exploded
			+ Test 1: use Points.GetWhatever(idx)
			+ FPS=24.7/24.8/25.0
			+ Test 2: use __restrict pointers
				+ Just simple 1-Point-Component loop, compiler makes times four
				+ Pointers are locally declared as __restrict, and adjusts count (i.e. times 2) and uses
				  indices in pointers
				+ Verify assembly
			+ FPS=24.9/25.1/25.2
		+ Phase 1:
			+ Beginning FPS=19.0/19.4/19.7/19.9
			+ Ending FPS=22.0/22.3/22.6
		+ Phase 1.5:
			+ Beginning FPS=22.0/22.3/22.6
			+ Ending FPS=24.0/24.2/24.4
		+ Phase 2:
			+ Beginning FPS=24.0/24.2/24.4
			+ After exploded Newtonz FPS=24.8/24.9/25.1
			+ Ending FPS=26.3/26.5
		+ Phase 3:
			+ Beginning FPS=26.3/26.5
			+ Ending FPS=26.6/26.8/26.9/27.0
	+ BufferAllocator<Type:vec2f or float>
		+ cctor takes ElementCount
		+ Allocate() returns std::unique_ptr<Buffer<Type>>, with deleter invoking mAllocator->Release(Buffer<type>*)
		+ Points::CheckoutWaterBufferTmp (as "AllocateWaterBufferCopy()") borrows one, copies it in, and returns it as std::unique_ptr<Buffer<float>>
		+ Opposite for Commit() (as "UpdateWaterBuffer")
	+ Points::ConnectedSprings is of struct { SpringIndex, OtherEndpointIndex }
		+ No two separate buffers, as we seldom (if not neveer) need them separate
		+ Init's @ShipBuilder or at whoever populates it now
		+ Maintained at SpringDestroyHandler
		+ Used at:
			+ ConnectedComponentDetection
			+ UpdateWaterVelocities
	+ Water and Land interpolations:
		+ Prepare first test bench (noinline)
			+ GetWaterHeight: 2.23%
			+ GetFloorHeight: 1.66%
			+ Save assembly
		+ 1: see if it's better to store delta's and/or other pre-calculated things
		+ 2: see if can do semi-integer x-axis interpolation
			+ GetWaterHeight: 1.25%
			+ GetFloorHeight: 0.77%
		+ Cleanup test bench
		+ Final functional test
		+ Final FPS test
	+ See if can avoid other IsDeleted checks, via zero'ing of coefficients
		+ UpdateSpringForces()
	+ Retry cache layout optimization, new strategy:
		+ Starting point:
			! ReorderSpringsOptimally_Tiling<2>
			! ReorderPointsOptimally_FollowingSprings
			! No Triangles reordering
			+ ACMR: 0.516807 ->  0.389524
			+ FPS: 28.5/28.8
		+ 1:
			+ Points in 2x2 blocks (with any point optional), advancing one column - and then row - at a time
			+ Springs in those 2x2 blocks, advancing one column - and then row - at a time
			+ ACMR: 0.516807 ->  0.508228
		+ 2:
			+ Do w/vertical streak of 2,3,4,5,6,7,8
			+ ACMR:
				+ Tiling<2>: FPS: 28.5 U/R: 213
				+ 2: 0.516807 -> 0.515553 FPS: 28.6  U/R: 210
				+ 3: 0.516807 -> 0.388722 FPS: 28.6  U/R: 213
				+ 4: 0.516807 -> 0.345725 FPS: 28.6  U/R: 213
				+ 5: 0.516807 -> 0.325507 FPS: 28.6  U/R: 213
				+ 6: 0.516807 -> 0.313153 FPS: TODO  U/R: 213
				- 7: 0.516807 -> 0.307245 FPS: TODO  U/R: TODO
				+ 8: 0.516807 -> 0.300773 FPS: 28.6  U/R: 210/215
		+ 3: Do final check w/Forsyth's triangles optimization
			+ FPS: 28.1 U/R: 206
		+ Triangles: optimize reuse of 2 vertices
			+ Starting ACMR: 1.01986 VMR: 0.49888
			+ Ending ACMR: 1.00672 VMR: 0.101436
			+ Test to decide whether to keep or not: NO KEEP
	+ Lights perf improvement
		+ Start: FPS=9.9 U/R=508/510 (Dorik 2)
		+ 1: Add IsLegacyElectrical to structural materials
		+ 2: Make spread linear, == max distance
			+ Update materials' DB
			+ Remove mapping and take spread as-is
		+ 3: Adjust spread adjustment:
			+ Min/Max = 0.0/20.0, linear
		+ 4: Adjust luminiscence adjustment:
			+ Min/Max = 0.0/4.0, exp
		+ Now: FPS=13.4 U/R=335/342
		+ 6: Invert loop and optimize
		+ Now: FPS=15.8 U/R=272
		+ 7: Vectorize
			+ Make unit tests
			+ Make benchmark
			+ Test if pointLight can be clipped to 1.0 (NO)
			+ Vectorize
				+ See why unaligned instructions (e.g. movups) are generated
				+ Check whole assembly

				DiffuseLight_Naive/1           1308910 ns    1195730 ns        561

				DiffuseLight_Naive/4           2055317 ns    2043863 ns        374
				DiffuseLight_Naive/8           3586917 ns    3441199 ns        204
				DiffuseLight_Naive/16          7220152 ns    6964330 ns        112
				DiffuseLight_Naive/32         16417383 ns   15912102 ns         50
				DiffuseLight_Naive/128        98089663 ns   91372014 ns          7

				DiffuseLight_Vectorized/4      1710142 ns    1605893 ns        408
				DiffuseLight_Vectorized/8      2995209 ns    2944597 ns        249
				DiffuseLight_Vectorized/16     5288064 ns    5304034 ns        100
				DiffuseLight_Vectorized/32    10752535 ns    9984064 ns         75
				DiffuseLight_Vectorized/128   39420602 ns   37623771 ns         17

		+ Ship: pad lamps to multiples of element count, and make all buffers aligned
			+ For now just dynamically
		+ Now: FPS=17.7 U/R=230
		+ Commit
		+ ElectricalElements: precalc lamp buffers and maintain w/GameParameters' changes
			+ Store initial GameParameters at cctor
			+ Calc values at Add()
			+ Recalc values at UpdateForGameParameters
		+ Now: FPS=18 U/R=222
		+ Try with exploding lamp's positions into x & y
			+ Algorithm
			+ @ UnitTests
			+ @ Benchmarks
			+ Run new benchmarks

				DiffuseLight_Naive/1          21471036 ns   12792082 ns

				DiffuseLight_Naive/4          20730892 ns   19165837 ns
				DiffuseLight_Naive/8          36127342 ns   34171648 ns
				DiffuseLight_Naive/16         70868391 ns   67600433 ns
				DiffuseLight_Naive/32        158081461 ns  156001000 ns
				DiffuseLight_Naive/128      1009125502 ns  936006000 ns

				DiffuseLight_Vectorized/4     16869165 ns   16361080 ns
				DiffuseLight_Vectorized/8     29228165 ns   28363818 ns
				DiffuseLight_Vectorized/16    54706011 ns   49636682 ns
				DiffuseLight_Vectorized/32   107635537 ns  101400650 ns
				DiffuseLight_Vectorized/128  413520040 ns  382202450 ns

			+ @ Ship
			+ Decide whether to keep or not
		+ Decide whether Ship should use a threshold to switch between vectorized and naive algo
			+ 1 naive is better than 4 vectorized, 2 naives are already worse
			+ Just one lamp is not worth optimizing for
		+ Disable whole diffusion when luminiscence adjust is zero
			+ Requires "current" member at Ship
		+ Run in Debug
		+ Now: FPS=18.1 U/R=235
		+ Update changes.txt
	+ Forces rearc:
		! Rationale: multiple spring iterations are really artificial; in reality, changes due to spring position changes in-between
		  iterations shouldn't impact physical world (e.g. buoyancy/drag) yet
			! So we may calculate point forces once and for all, assuming points' dynamics stay constant during spring relaxation
		+ Verify that the reason two separate integrations explode is because of velocity
		+ Split spring forces and point forces, achieving equivalence
		+ 1) Change integration scheme:
			! So that position-based spring relaxation does not require extra semi/integration steps
			+ P(t+1) = P(t) + SpringForcesDeltaPos + WorldForcesDeltaPos + V(t)*dt
			+ V(t+1) = (P(t+1) - P(t))/dt = V(t) + (SpringForcesDeltaPos + WorldForcesDeltaPos)/dt
			+ Verify equivalent
		+ 2) All non-spring forces calculated once, outside of loop
			! Assumption: no deletions take place during mech loop
			+ Points has two Force buffers: SpringForces and NonSpringForces
				! Only temporarily, until position-based springs are done
			+ Verify equivalence
			+ Move forces' application out
			+ Do not reset forces at integrate
			+ Zero forces after loop
				+ Check assembly
			+ See issue @ y=518.0, force = 1*e-06
			+ Test L'n'F'
		X 3) Spring relaxation based on position rather than forces
			X 1) Integrate inline (multipy sum of forces by point's integration coeff) and update positions
				+ Get rid of spring integration in iterations loop
				X !!! Test !!! SUCKS!
				+ See if need to also update velocities because they're needed (updated) for damping
			X Get rid of two force buffers and go back to one single "Force" buffer
			X 2) Incorporate particles' integration coefficients into springs' stiffness and damping coefficients, using
			     temporary IntegrationFactors buffer
				- Need pre-step before loop
				- Buffer alloc'd via Springs::AllocWorkBufferEtc.()
				- Populate inline
				- Test
		+ Finalize dual force buffer
			+ Methods and names
			+ Integration
		+ Test
		+ Finalization:
			+ Verify integration assembly
			+ Verify Points::UpdateMasses assembly
			X See if multiple relax iterations (nested) improve cheaply rigidity
				X Maintain all params the same (e.g. dt)
			X Experiment with different spring coeffs
				+ First, do all calculations in RelaxSprings, ignore coeffs for now
				+ Experiment with SpringReductionFraction set to 0.8 or 1.0
			+ Optimize spring relaxation assembly
				! Assembly inspection-driven
				! Not sse yet
				+ Start: 20.6-21.6ms, 31.80-32.10fps
				+ a) Add Hooke's and damping scalars and multiply only once with springDir
				+ Perf: 18.9, 33.7 | 18.5, 34.2 | 18.3, 34.5
				+ Do vector normalization in SSE
					+ Benchmark: copy vector from vector
					+ Unit Tests
					+ Integrate in Algorithms->Vectors
						+ Algorithms becomes templated on TVector
						+ Unit Tests
						+ Benchmark
				X Perf: 19.2, 33.6 %
				X Rollout spring loop
				+ restrict spring buffers
				+ Perf: 18.2, 34.5
				+ restrict point buffers
				+ Perf: 17.7, 35.21 (| 18.0, 34.8 | 18.1, 34.7)
			X See if it's faster to not reset forces at Integrate, but in a separate fill call
				+ Perf: 18.4
			+ Get rid of force fields and apply forces directly instead of queing force fields
				+ Ship_ForceFields: ApplyXYZ(.....)
				+ Test all manners of injecting force fields:
					+ Draw & Swirl
					+ Bomb blast
						+ Radius: 1.5
						+ Heat: 100K
					+ AM: pre-implosion, implosion, explosion
				+ Test perf improvement with many AM bombs
			+ See if HandleCollisionsWithSeaFloor may be also done once
				+ Perf before: 17.8/34.9, 17.5/35.4
				+ When sampling sea floor, clamp x
					+ OceanFloor: make sure we can ask for the derivative at x=MaxWorldWidth
				+ Take position snapshot before loop, and use it to calc 'before' position and effective velocity
				  when dealing with collision
					+ Do successive divisions of before->after segment to get closer to surface
					+ Add OceanFloor elasticity and friction
						+ New GameParameters
						+ Also at SettingsDialog
						+ Normal response: Vn' = -eVn (e = elasticity, [0.0 - 1.0])
						+ Tangential response: Vt' = aVt (a = friction, [0.0 - 1.0])
				X Does not work, dt is too large
				+ Just test friction and elasticity
				+ See if it's x-clamping that made 17.5ms go to 18.5
				+ Add friction and elasticity to changes
			+ Remove clamp at ocean floor and ocean surface
				+ Perf before: 18.5/34.3
				+ Test SEE clamp
					+ Test, including assembly
					+ See perf
				+ Optimize calculation of anti-normal
					+ Test
				+ Re-check world trimming and confirm it does what's expected
				+ Clamp at Repair when changing positions
				+ Do
				+ Perf after: 18.3/34.5 - 17.9/34.9
			+ World bounds: find right point to move back to
			X Spring relaxation: see if perf improves with loop by points, rather than by springs
				X First iteration: sucks
				+ Finalize isAtOwner (see below), change temporarily spring relaxation call, and commit
					+ Revert spring relaxation call
				+ Change spring loop to be unilateral, but still with forces
					+ Just to verify loop structure
				X Try with Gauss-Seidel and (yes/no) spring force integration in loop as well
					+ Fix world forces - reistate integration but only for world
						+ Loop:
							+ Make copy of positions
							+ Make copy of vels
							+ Do spring loop:
								+ For each point:
									+ For each spring: sum all forces
									+ Integrate force into deltaPos
									+ positionA += deltaPos
									+ velocityA += deltaPos/dt * damp
							+ Integrate(startingPos, startingVels):
								+ Ignore vels and only use startingVels
				+ Try with full integration for each visited point
					+ Requires springs owned by point Pi to only be connected to Pj with j > i
					+ Integrate point at end of spring loop
					+ Nuke integration call
				X Finalization:
					X If we go for it:
						X See if SpringForces needed and if not, Nuke Points::SpringForces buffer and go back to single force buffer
						X Pre-integrate world force buffer before loop
					X See double-buffers to avoid integration step
					X Cleanup point integration factor buffer - make it float itself, if we really go ahead
					X Re-think connected springs structure:
						X Incorporate coefficients
			X Spring relaxation: see if perf improves with position and velocity and spring force in the same buffer
				+ Perf before: 18.08/34.6 18.5/34.3
				+ position vec2f, velocity vec2f, spring force vec2f
					+ Struct at points, with methods for interleaving and de-interleaving
				+ Interleave before loop
				+ RelaxSprings
				+ Integrate
				- Collisions
				+ De-interleave after loop
				+ Perf: 18.7/34.0
			+ See if may replace spring dampers with higher global damp
				+ Add new GameParameters::GlobalDampAdjust
				+ SettingsDialog
				X Test replacement
				! Keep setting anyway
				+ Find better formula to map adjustment
			+ Adjust:
				+ Bomb blast strength
			X Try with spring-only additional iterations
				X Test
	X Try with SpringRelaxation updating only positions
		! This was done in NewSpringRelaxation branch, but was too unstable
		+ Still runs N times, but only updates positions (does a local "integration" based on "forces")
		+ After last step, update velocity adding last step's position minus initial position
			+ Need to save position buffer first
			+ Then add the saved velocity buffer with the resultant of the velocities generated by spring relaxation, which are the
			  resultant position delta's resulting from relaxation
		+ Test:
			+ See bounces from ocean floor
				+ The back-sending should be fine as it's based off real initial velocity TODO: double-check
	+ Cached depths (*)
		+ Underwater depth: Points::CachedDepth
			! Spec:
				! Valid as long as points don't move after caching, and as long as cached depth is not used between interactions and moment when it's calculated again
				! Also valid as long as points are not created after depths are taken
					! So also creation of ephemeral particles needs to be tackled
			+ Plan:
				+ Points::GetPosition() -> &: convert to Set
					+ Check assembly before and after
					+ Test:
						+ CollisionWithOceanFloor
						+ WorldBoundaries
				+ Interactions: clamp positions to world boundaries after each position change
					! GenerateDebris uses source particle's position
					! GenerateSparklesForCut uses midpoint of spring
					! GenerateSparklesForLightning uses source particle's position
				+ Test ApplyWorldForces
					+ Wind
					+ Friction drag
				+ Commit
				+ Take initial perf with analyzer
					- GameController::RunGameIteration: 86.52
						- Ship::Update: 83.82
							- Springs: 56.59
							- CollisionsWithSeafloor: 9.43
							- UpdateWaterVelocities: 8.27
							- Integrate: 3.74
							- PropagateHeat: 2.17
							- ApplyWorldForces: 1.63
				+ Try CollisionsWithSeafloor optimizations:
					X 1: Do once at the end, taking snapshot of positions ("pre-impact positions") before loop
						X Springs' displacement is too high to survive any strain check
					+ 2: If doesn't work: do once every N steps, taking snapshot of positions before N steps
						+ N=4: still too much
						+ N=2
							x Try N=4 again with fixed collision dynamics
							+ See ocean floor friction
					+ 3: Try using velocity instead of previous position vector
					X 4: Try sparsely for most of loop, then more densely at end
					+ Cleanup:
						+ See new minima and maxima for both friction and elasticity
						+ Cleanup TODOs and useless functions
					X Try soft interpolation
				+ Do DEBUG work above to catch late positions changes
					+ Also make sure to flag positions as dirty at modifiers of position buffer
					+ Test and verify that after WorldBoundaries there's no position changes
				+ Change sequence of steps at Ship::Update so that we put all position changes as early as possible, and take depths afterwards
					! [WorldBoundaries apply]
					+ [Interactive position changes]
						+ These take a world in boundaries, and leave the world in boundaries
							+ Since we'll likely be accessing OceanSurface or OceanFloor during interactions
						+ Need to make sure these clamp to world boundaries then
					! [WorldBoundaries apply]
					! START
					+ UpdateForGameParameters
					+ UpdateMasses
					+ Spring + Integration + OceanFloorCollision
					+ TrimForWorldBounds
						+ This ends position changes in the entire loop						
					+ // From now on, we only work with forces and never update positions
					+ ResetNonSpringForces
					+ ApplyWorldForces							
					+ [Cached depths are valid starting now]
					+ RotPoints()
					+ Gadgets::Update()
					+ UpdateForSpringStrains
						+ Because bounce @ WorldBoundaries requires UpdateForSpringStrains in same frame to prevent humongously long springs
						+ Requires depth for sounds, but no big deal if has to calculate it
					+ UpdateStateMachines
					+ ... everything else...
					! [WorldBoundaries apply]
					! END
				+ Test:
					+ Verify that after WorldBoundaries there's no position changes
					+ Rotting
					+ Melting
					+ Bombs detonations (ship's state machine)
					+ Ocean floor bounce
					+ World boundary bounce
				+ New Points::CachedDepth buffer
					+ Initialization: via mParentWorld call at Add()
					+ Getter
					+ Buffer getter & swapper (see water buffers)
				+ Ephemeral points: ephemeral points must take depth at creation, always
					+ Change all Points::CreateXYZ() methods to take point depth
					+ Bubbles already have it anyway!
					+ Creation happens at:
						+ Interactions
						+ Breakages at UpdateForSpringStrains
						+ Bubble generation
						+ Anywhere else?
					+ Test:
						+ Water inflow (for depth recalculation)
						+ Air bubbles
						+ Debris
						+ Smoke
						+ Sparkles
						+ TimerBomb smoke
				+ Populate CachedDepth at ApplyWorldForces
					+ Alloc new depth buffer - no need to clean
					+ Per-Particle: calculate and store depths here
					+ Swap depth buffers
				+ Use it, getting rid of now-superfluous parent.IsUnderwater/GetDepth calls
					+ Fork exe, take initial perf (UPD):
						+ Normal: 4.65
						+ With bubbles (@ all eph particles): 4.80/4.90
					+ ApplyWorldForces:
						+ Per-frontier (water pressure drag, waves)
					+ Add Points::IsCachedUnderwater(): just depth > 0.0 check
					+ UpdateWaterIntake
					+ Heat dissipation
					+ Rot points
					+ Springs::ApplyStrains() for sounds
					+ Points::UpdateCombustionHighFrequency
					+ Points::UpdateEphemeralParticles (AirBubbles - and others?)
						+ Make sure no other ephemeral types change positions
					+ All ephemeral particle creation call sites
					+ Catch any other calls to parent.IsUnderwater/GetOceanFloorSurfaceAt() by changing names
						! Only places allowed to invoke World.IsUnderwater/GetOceanFloorSurfaceAt() now:
							+ Points::Add for Points building
							+ CachedDepth population at ApplyWorldForces()
							+ Ephemeral particle creation
							+ Interactions
							+ PhysicsHandlers at Ship, as they might be invoked at any moment
							+ Gadgets' and PinnedPoints' interactions
							+ Anywhere the position is not that of a particle
								+ ElectricalElements::Update for offseted engine
						+ Rename World::TODO's back
							+ Verify "allowed" list as you go
							+ Add GetDepth(position)
					+ Test:
						+ Verify assembly of mWorld.IsUnderwater() and GetDepth() at a caller's site
						+ Debug
						+ Water inflow via leaking
							+ Pumps
						+ Combustion initiation and smothering
						+ Air bubbles expiration
						+ Sparkles expiration
						+ WakeBubbles
						+ Rotting
						+ Stressed springs underwater (for sound)
						+ TimerBomb
							+ And fuse
						+ Ephemeral particles at right depth:
							+ Air bubbles
							+ Debris
							+ Smoke
							+ Sparkles
							+ TimerBomb smoke
					+ Final perf: 
						+ Normal: 4.63
						+ With bubbles: 4.81

+ Fix 4 BPP images
	+ Need ilCopyPixels to convert to standard format (BPP:3, Format: RGB, Type: U_BYTE)

+ Material::"Electrical" (and "Sound")
+ See if destroy's lack of point allows for water to flow in
+ FileDialog: filters based off image formats that are supported
+ Jelly ball: see orig code for doubles
+ Less ocean depth max
+ Data/
	+ InitialShip.png [also change @ code]
	+ Materials
+ see if it makes sense that ship::points is set<x, set<y, points>>
+ nuke wxSmith
	+ Verify all is fine afterwards
+ set icon
+ Debug builds:
	+ Enable /Fp:strict and set fpcontrol via /DFLOATING_POINT_CHECKS
	+ See if SEH needed (/EHa)

+ Mouse pointer based off current tool
	+ Only on Canvas, normal outside
+ Move IsPaused member out of game controller & parameters; handled by MainFrame via status of mPauseMenuItem
+ DrawAt: the longer it's pressed, the stronger it gets
	+ Requires TimerTick to also update force and invoke DrawTo when l is down and current tool is Draw
	+ Also radius of Smash, same thing
+ Tool strength modulation:
	+ Also modulate cursor (red bar rising)
		+ Build 10 images (and then cursors) off the base image
		+ @ tool application, also call SetCursorStrength(strength, minStrength, maxStrength)
			+ Calculated which one of the (xyzCursors.size()-1) to set, of current tool's cursor

+ Phys rearc:
	+ Confirmed: destroy breaks due to iterator invalidation
	+ In order to allow for ship building unit tests:
		+ static unique_ptr<Ship> Ship::Create(unsigned char const * structureImageData, un_map<vec3f, Material*>)
		+ void World::AddShip(unique_ptr<Ship> && newShip)
		+ Game::LoadShip(filename) still loads the image, and then Ship::Create and World::AddShip
	+ Ship_BuildsFromStructureImage_XXX unit test:
		+ Make structureImageData and verify points, springs, triangles, etc., also indexes & relationships
			+ Might actually want Material::cctor to be public
	+ Destroy unit tests:
		+ Make structureImageData
		+ DestroyAt
		+ Verify points, springs, triangles, etc., also indexes & relationships
		+ Verify crashes in Debug!
	+ Do phys renames and file split above
	+ Verify unit tests (1) & runs normally & no fps regression
	+ Commit & push
	+ Take new perf baseline (FPS and percentages): 8/9
	+ Repository rearc:
		+ PointerContainer:
			+ Flag is via getter (IsDeleted())
				+ Also rename other GetIsXYZ() -> IsXYD() and SetXYD()
			+ RegisterDeletion(): increments counter
			+ ShrinkToFit:
				+ Only if deletion counter != 0
				+ Allocate new and copy pointer by pointer that's not deleted
					+ assert counts at the end
				+ Fix unit tests (need to register deletion, and add case with no registration but deletion)
		+ Replace parentWorld with parentShip at all elements
			+ See also if can get rid of accessing World altogether, in lieu of GameParameters or specific parameter(s) of it (e.g. gravity)
			+ Spring
			+ Triangle
			+ Point
		+ Physics::ShipElement<TElement>
			+ Provides IsDeleted()
			+ Has mParentShip * const (set via cctor) and getter
			+ public Destroy()
				+ mIsDeleted = true
				+ mParentShip->RegisterDestruction<TElement>((TElement *)this)
			+ Everything derives from it, publicly
		+ Ship maintains lifetime of points, springs, and triangles in backbones
			+ Springs: PointerContainer
			+ Others: depends, if fast iterator access in arbitrary order is needed => PointerContainer,
				  else use set (even if never iterated, makes faster deletion)
			+ RegisterDestruction<TElement>(TElement *element):
				+ For things in PointerContainer: invokes PointerContainer::RegisterDeletion()
				+ For things in sets, maps: invokes set/map.erase(element) // it's a shortcut!
					+ In these cases, mIsDeleted setting is redundant, but heh...
		+ Fix crash at Destroy
			+ Remove all TODOs
		+ Rethink pointer container: it should iterate Element* rather than Element&
		+ New FPS: 11/11/12
		+ Fix disappearing ship
			+ Make PointerContainer Log a Debug afterwards, instead of Info
			+ Nuke all the other TODO's
			+ Run with strict floating point
				+ Disable exc with overflow & verify that's how we get to NaN
		+ Commit & push
		+ See if chunk splitting reprocesses same point twice
		+ See if connected triangles (at point) should also be vector instead of set
			+ Requires Triangle.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
		+ Test mAllTriangles in PointerContainer
			+ Should make faster render:
				+ Before: FPS with pause=18/19
				+ After: FPS with pause=19
			+ If not good, undo - KEPT!

		+ Try Adjancency rearc:
			+ Commit and push first
    			+ Each adjacency arc exists for each non-hull spring, and lives as long as the spring lives;
			  we might then get rid of these and just visit the non-hull springs,
			  provided that we adjust GravitateWater and BalancePressure for the fact that each arc
			  would now be visited only once
			+ However, for electrical elements we still want to visit the spring-connected graph,
			  regardless of hull-ness this time;
			  we then want each point to know its N attached springs (arcs), which
			  we maintain as a vector<Spring *> (there's max 8)
				+ Actually: FixedSizeVector<TElement, Size>, w/erase that shifts and returns bool
				+ Remove: use vector::erase(std::remove(val)), or self-done for just one
				+ Adjust GravitateWater and BalancePressure for the fact that each arc
			  		is now visited only once
					+ GravitateWater: change to visit springs, and do realize that one of the points
					  always has cos > and the other cos <
					+ BalancePressure: for each pair in which one has water > 1.0, do delta
					+ Don't take shortcuts, and add comments about this
				+ Point: expose same API as triangles
				+ Spring:
					+ cctor adds itself to its endpoints
					+ dctor removes itself from its endpoints
					+ Make sure it's the same code as triangles
					+ Then remove code from Ship construction
				+ Replace adjacencymap visit with spring visit (of non-hull only)
				+ Remove ship.adjacencymap
				+ Requires Spring.DestroyFromPoint(Point *) which avoids coming back to caller, to not invalidate iterator
			+ Then see if Point->Destroy() can avoid enumerating all springs to find the ones affected
				- Check speedup
		+ x::Destroy()  // Removes all references to self that are found in counterparties
				// Invokes Destroy() on counterparties it "owns" (e.g. Point->Spring)
				// Basically: replaces dctors (which now have to go away)
				// Then, calls base ShipElement::Destroy()
		+ At the end of each Update(), Ship calls shrink_to_fit on owned pointer container(s)
			+ Also removes points et al that were deleted on previous DestroyAt()
		+ Remember to exclude IsDeleted() things during enumerations!
			+ And assert(!IsDeleted()) when it's impossible the're deleted (e.g. if accessed via relationship that should
			  have been cut if that element was deleted)

	+ Remove TODO's from unit test and verify (2) & runs normally & no fps regression
	+ Complete unit tests with all new relationships
	+ Commit & push
	+ Take new perf baseline (FPS)
	+ Final refactor physics:
		+ No friends
		+ Clear all warnings
		+ Args by ref - no vector copies!
		+ phys getters (e.g. point.GetColour()) inline
		+ Make other inlines
		+ Fix include files
		+ Formulas optimizations
			+ Point forces: gravity may be applied twice with different magnitude but same vector
		+ gameparams/world::(waterpressure, strength, ): are these "factors" or "global" really?
		+ See if FP:fast really makes a difference (Release only)
		+ All TODO's
	+ Commit & push
	+ Verify unit tests & runs normally & no fps regression
+ Menu entry to reset pan and zoom
+ Get rid of unicode
	+ Can, really?
+ Add splash screen

+ OpenGL Rearc:

	+ Test with no repopulating buffer
		+ Is: 54/55
		+ Vs: 54
		+ DISCARDED


	+ Finish render primitives:
		+ Water
			+ Check for blend!!!
		+ ShipPoints
		+ Springs * 2
			+ Convert to indices
			X Check control of interpolation/end vertex?
		+ DrawPoints

	+ Remove Z depth for transparent water (shader param)
		+ Menu with lambdas

	+ AmbientLight also for water and land (calcd @ color param setting)
		+ Use own AmbientLight render parameter (getter & setter) & shader parameter for water and land only
			+ MainFrame sets it based off phase, and takes it for own Point::GetColour(.)
		+ Also getters for others (separate X and Y)

	+ Code cleanup:
		+ RAII (generic)
		+ Point description routine

	+ Zoom rearc:
		+ 0 - 1000
			+ 1 is normal
			+ ---> 0: smaller
			+ ---> 1000: lerger
			+ WorldHeight == 2*70/(zoom + 0.001)

	+ Take new baseline
		+ 22/23fps for 28,000 triangles

	==================================
	Integration:
	==================================

	+ GameController owns RenderContext (as uq_ptr)
		+ GameController created by MainFrame after glContext created

	+ GameController::Get/Set<RenderParameter>(.): // Zoom, Camx-Camy, CanvasWidth-CanvasHeight, AmbientLight, booleans
		+ Set: forward to RenderContext::Set<RenderParameter>(.)
			+ ...which does changes on the fly
			+ ...and also stores those that Physics::XYZ::Render() needs for procedural and color changes
				+ e.g. booleans, exposed as GetXYZ()
			+ ...and also stores world bounding coordinates (R,L,T,B) to give to Physics::RenderWater/RenderLand()
		+ Get: forward to RenderContext::Get<RenderParameter>()
		+ Defaults: in RenderContext cctor
		+ Nuke RenderParameters

	+ GameParameters stays unchanged

	+ Physics::XYZ::Render():
		+ Takes RenderContext &
		+ When and if needed, polls RenderContext::Get<e.g. boolean or world bounding coordinates>()

	+ Screen2World and World2Screen:
		+ Calcd by RenderContext using OrthoMatrix and its inverse (or formulas if can't do with inverse)
		+ Exposed by GameController who asks RenderContext

	+ Ship::Render:
		+ First, all points, assigning RenderElementID - TEMPORARY
		+ Then, springs and/or triangles, using elements

	+ Nuke RenderUtils

	===================================
	Baseline perf of openGLTest:
	- 82,524 triangles:
		- 13/14fps
		- OnGameTimerTrigger: 86.76%
			- RenderShipTrianglesEnd: 73.67%
			- fminf: 8.18%
	- 27,324 triangles:
		- 43/44/45fps (42fps when doing full color interpolation)
		- OnGameTimerTrigger: 86.27%
			- RenderShipTrianglesEnd: 71.05%
			- fminf: 7.79%
	-----
	Vertex shader doing light and water:
	- 27,324 triangles:
		- 38/39fps
		- OnGameTimerTrigger: 85.18%
			- RenderShipTrianglesEnd: 75.24%
			- fminf: 0.0%

	Fragment shader doing light and water:
	- 27,324 triangles:
		- 35/36fps

	Elements:
	- 27,324 triangles:
		- 39/40/41fps

	Elements and light and water shading in software (still with water and light):
	- 27,324 triangles:
		- 49/50/51fps

	Elements and light and water shading in software (no more water and light):
	- 27,324 triangles:
		- 49/50/51fps

	Without ambient light re-calculations for each vertex (shader parameter):
	- 27,324 triangles:
		- 51/53fps
		- OnGameTimerTrigger: 85.84%
			- RenderShipTrianglesEnd: 76.26% [all external]
			- fminf: 1.56%
	+ See if reordering springs according to small tiles helps, instead of according to cache heuristics
		+ Visit point matrix as 2X2 blocks
		+ Add all springs connected to any of the included points (0..4 points), except for already-added ones
			+ Use vector<bool> to remember indices of springs already added
			+ Need un_map<point index->[spring index]>
				+ See if [spring index] could be member of PointInfo
			+ Done like this, it favors springs extending to the right and down
	+ Sea and Ocean Floor: take advantage of bounded-width world (*)
		+ Main concept:
			+ OceanSurface and OceanFloor contain samples for the entire width
				+ Have to find <#Samples==BufferWidth, MaxWorldWidth> pair that we are comfortable
				  with *and* which gives a good resolution
					+ Water:
						+ Current dx = 20*pi/512 ~= 0.122m
						+ Next dx = W/S @ W=10K => ~80k samples
							+ But we ended up with 8k samples!
			+ Not anymore periodic, hence no mod anymore to get water height and ocean floor
			+ Only the number of samples dictates final definition of surface and floor
			+ Uploading is by sample (when not minifying a lot)
				+ Loop uploads S(i0+ni), with i0=left start, n depending on zoom
					+ Magnifying: n = 1, dx > 1; GPU fills-in
					+ Minifying: n > 1, dx = n * resolution
						+ n chosen so that number of slices kinda like now, i.e. ~= 500
		+ Initial FPS: 29.5/29.8
		+ Impl step 1: Ocean floor
			+ # of samples: try 2K first
			+ dx = MaxWorldWidth/NumberOfSamples
			+ Initialization:
				+ OceanBottom bitmap gets implicitly upsampled to 5000m if w < 5000
					+ If it looks bad, made it larger until definition is enough
				+ Then it gets cut/repeated to # of samples
					+ ImgX = (s * dx) % 5000
					+ Do interpolation
			+ Update:
				+ Sine/cosine is superimposed for each sample, like now
			+ AdjustTo:
				+ Fix
			+ Sampling:
				+ Just find sample index and interpolate in-between
				+ See issue with x==MaxWorldWidth
					+ Do extra sample with same val as previous
						+ Delta is zero though
					+ Remove change at Ship
				+ Test last ocean floor sample, again
			+ Since you're here, change AdjustTerrain tool to do trajectory
			+ Test:
				+ OceanFloor bitmap larger, not multiple (say, 700) - w/recongizable pattern
		+ Impl step 2: Render upload: use same spatial frequency as samples, so to avoid interpolating altogether
			+ Need first to always render ocean up to visibleWorldBottom, in which case the two are fully independent
				+ Test afterwards
			+ Break World::UploadLandAndWater into OceanFloor::Upload(.) and WaterSurface::Upload(.)
			+ Fix perf issue w/tall quads
				+ Test waves below visible bottom
			+ Test ocean gradient
			+ OceanFloor::Upload(.)
				+ Find first sample == sample immediately to the left of visibleWorld.Left
				+ Magnifying: n = 1, dx > 1; GPU fills-in
				+ Minifying: n > 1, dx = n * resolution
					+ n chosen so that number of slices kinda like now, i.e. ~= 500
				+ No, minifying is old sampling way
			+ WaterSurface::Upload(.)
				+ For now, like it was at World
			+ Go back to 500 slices
				+ Test seams
		+ Perf:
			+ FPS was (during step 2): 30.2/30.4
			+ Now: 30.5
			+ UR was (during step 2): 214
			+ Now: 217
		+ Impl step 3: WaterSurface
			+ # of samples: try 4K first
			+ dx = MaxWorldWidth/NumberOfSamples
			+ GetWaterHeightAt()
			+ Init
			+ Update
			+ WaterSurface::Upload(.)
				+ Do same as OceanFloor
			+ Test if # of samples good wrt waves' resolution
				+ Not really, but we can live with it
		+ Perf:
			+ FPS Now: 30.8
			+ UR Now: 224
+ UI:
	+ Smooth pan and zoom
		+ Takes 1 sec to get to final value (which is stored immediately as real value)
	+ Zoom: inverse
		+ 0 - 1000
		+ Renderer::ZoomToWorldY(zoom) == 70/(zoom + 0.001)
		+ Also called by GameController's Screen2World
			+ also move GameController's Screen2World implementation to Renderer
		+ See if needs to be exponentially-slider'ed as well
	+ Settings:
		+ Strength Adjustment must be settable exponentially (slider=>exp)
			+ Formula done by gamecontroller at AdjustStrengthAdjustment(), or by SettingsDialog directly
	+ Page up and page down in menu
	+ Ship name in title
		+ MainFrame implements OnShipLoaded() and OnGameReset(), populates mShipNames vector with ship names, and calls SetTitle()
		+ SetTitle appends Utils::Join(vec<str>, ' + ') to current title
	+ Radio: draw points, springs, structure, texture
		+ (Bit) Flag @ GameController->RenderContext->Ship
			+ Inspected as bit glag by Ship as well @ Render() to avoid useless uploads
		+ Larger points
		+ SettingsDialog
			+ Better grouping, see RadioBox?
	+ Space bar for pause
		+ When pause, also pause sounds and music
	+ MainFrame: AboutDialog is member & shown on demand
	+ Make stiffness adjustment
		+ Points::SetStiffnessAdjustment(stiffnessAdjustment):
			+ Called by Ship at each Update()
			+ If != last, recalc coefficient/s
	+ Set max and min zoom (or monsters awaken when you zoom out too much)
	+ Reset view (ESC) should also reset camera pan
	+ SettingsDialog: bomb blast radius
	+ SettingsDialog:
		+ Break into N Liner/ExponentialSliderControl
			+ Init'd with:
				+ CurrentValue
				+ Max and Min
				+ std::function for OnValueChanged(float newValue)
		+ Find solution to ugly slider value rounding
			+ Calc tick_size == (Max-Min)/100, floored to round float increment ... see doc'n on floats
			+ Then calc # ticks == floor((Max-Min)/tick_size)
		+ Re-set default values to round values
	+ Tool cursors: cursor should change when mouse down
		+ Remove up and down from hierarchy - no cursors in hierarchy (other than mCurrent), and ModulateCursor()
		  takes vector
		+ Do own up and down at:
			+ Smash
			+ Grab (times 2: positive and negative)
		+ Pin, instead, does not change
			+ Undo its dual cursors
		+ ToolController class, called directly by MainFrame
			+ Has GameController shared_ptr
			+ SetTool(tool enum from ToolController)
			+ OnMouseDown/Up/etc.()
			+ RC Bomb detection via events is still left to MainFrame
			+ Tool class:
				+ ToolController has pointer to the current tool; might be null
				+ ShowCurrentCursor(): shows the current cursor; invoked by ToolController at end of initialization
				  to show the first cursor, and might be invoked via ToolController by MainFrame in the future
				  to re-show cursor after having stolen it
			+ Test:
				+ Shift up and down detection
	+ View control smoothing: test with restart from last target for faster convergence
	+ Up MaxStrength
	+ See why waves change when settings dialog is opened and closed
		+ Problem with ocean depth: value on exit looks like current - min == 180
		+ First of all, need to set slider ticks based on current values upon opening of dialog
		+ Then, see if floor at linear control should be round
	+ Fix ambient light increments
	+ When wind is zero waves don't move - need to change wave height and phase separately
	+ Changing the height of the bumps of the ground
		+ Allow the minimum seabed height to be 0
	+ Being able to drop the sea floor much further down than 500m or so too, like 10km
	+ World settings: number of clouds, wind
	+ SettingsDialog: also sound options
		+ Turn on/off sinking music
		+ Stress sounds on/off
		+ Break sounds on/off
		+ Two volume controls for music and sounds (all but music)
	+ ShipLoadDialog: revised FileDialog for loading ships showing previews of ships (*)
		+ ShipPreview
			+ <scaled ImageData, ShipMetadata>
			+ Loaded like ShipDefinition, taking width (from dialog)
		+ ShipPreviewPanel
			+ Now empty
			+ SetDirectory(std::filesystem::path)
				+ Just log for now
		+ ShipLoadDialog
			+ Directory tree on the left
				+ https://docs.wxwidgets.org/3.0/classwx_generic_dir_ctrl.html
			+ PreviewPanel in main area
				+ Figure out size math and number of cols
			+ void Open()
				+ Load vals from UIPreferences
				+ Call ShipPreviewPanel::Open()
					+ Start thread
				+ Then, call ShipPreviewPanel::Close()
					+ Stop thread
			+ Resize:
				+ Set min size for dir tree and for preview panel
			+ Combo:
				+ Last N from UIPreferences
				+ OnSelection:
					+ Tell DirCtrl
						+ See if it generates DirSelected event
						+ If not, tell also PreviewPanel
				+ Nothing to do with current dir
			+ When dir tree chooses, call ShipPreviewPanel::SetDirectory
			+ When ship is loaded, call UIPreferences::AddShipLoadDirectory
			+ No use as modal, do with Open() which returns opt<path>
			+ Hitting OK with preview just selected
		+ UIPreferences
			+ Created by main frame and passed around as shared_ptr
			+ Loads and Saves to uncustomizable file path
			+ Also has defaults, as initialization values set at cctor
			+ cctor:
				+ Set defaults
				+ Load
					+ No exceptions, if anything broken => keep defaults
					+ Filter and keep only existing paths
			+ dctor:
				+ Save
					+ No exceptions, if anything broken => silent
			+ AddShipLoadDirectory:
				+ Check if already there
					+ If yes: move first
					+ If not: add first
		+ ShipPreviewPanel
			+ Thread
				+ Figure out how to hook Show()
			+ Redo with custom events for thread-to-panel
			+ Other thread messages
		+ ShipPreviewControl
			+ Catch double-click event and fire ShipFileSelectedEvent
				+ ShipFileSelectedEvent registered to by ShipFileDialog, which uses it as "Ok"
			+ Trim at load
			+ Show:
				+ Name
				+ Dimensions:
					+ Metres: "160 m"
				+ Year
					+ Fill-in years @ ships
				+ Author
			+ Border when selected
				+ See wxPanel border
				+ If doesn't work, try DC
				+ If doesn't work, try Matrioska
		+ Cleanup source/Ships directory (make .dat's)
		+ Test:
			+ Super-minimize
			+ Image preview hits selection border? No
			+ ShipLoadDialog does not catch ShipFileChosen event
			+ Closing dialog when still loading images does not resume loading upon open
				+ ...and now test changing dir back to orig one while thread is loading
			+ Ugly flickering at re-open
				+ See if can avoid refreshing when not visible
				+ Due to Yield? No
			+ Run under debugger to see if there are assert's
		+ Test on two other Windows'
	+ SettingsDialog: tooltips at Simulation Quality (tradeoff) and Stiffness (instability)
		+ Use "Attention" icon
		+ wxToolTip
		+ SQ: Higher values improve the rigidity of simulated structures, at the expense of longer computation times
		+ S:  Higher values cause physical instability but provide for a nice effect!
		+ See if global settings are really needed
	+ Menu entries for "Home Page (GameJolt)/Code Page (GitHub)"
		+ wxLaunchDefaultBrowser
	+ SettingsDialog: add tooltips at each setting (*)
		+ Explanations and units
		+ Do on panel, slider, label, and textbox
			+ Or remove tooltip from icon altogether, do just standalone panel tooltip & standalone icon w/no tooltip
		+ Do also on various checkboxes in SettingsDialog
	+ PreferencesDialog:
		+ Nuke UISettings and move its setting in UIPreferences
			+ Also remove it from SettingsDialog altogether
		+ Plug into MainFrame
		+ Tooltip at ScreenshotsDir
		+ Tooltip at StartupDialog
	+ Ship Descriptions (*)
		+ ShipMetadata: description
			+ opt<string> member
			+ json load
		+ ShipDescriptionDialog
			+ Modal usage
			+ HTML control
			+ MakeHtml
			+ cctor takes bool ShipMetadata const &, isAutomatic, sh_ptr<UIPreferences>
				- If automatic, checkbox with "Don't show description when ships are loaded"
					- With tooltip about UIPreferences
		+ MainFrame: at LoadShip
			+ If gameController reports successful load, check UIPreferences and eventually create
			  ShipDescriptionDialog (automatic=true) and DoModal()
		+ Integrate in ShipLoadDialog
			+ 'i' button enabled when a ship with description is selected
			+ ShipLoadDialog needs to get ShipMetadata
		+ Checkbox at PreferencesDialog for auto-show
		+ Test:
			+ Select and later load .shp w/no description
			+ Select and later load .png w/no description
			+ Checkbox
				+ @ ShipDescription window
				+ @ PreferencesDialog
	+ floatingsandbox.com:
		+ Links menu
	+ SettingsDialog: make slider textboxes editable (*)
		+ Test MaxBurningParticles, Clouds, and Stars
	+ Adjustable zoom increments
		+ Under UIPreferences
		+ See if can use Smoothstep for...smoothing
			+ @ Controls
				+ Fix mouse wheel zoom
			+ @ Smoothed params
		+ Finalize ParameterSmoothing
		+ Fix unit tests
	+ StatusText/TextLayer replacement (*)
		! Slot-ification of text in text layer, with exhausted slots scrolling up
		+ Replace GameLib::StatusText with new TextLayer class
			+ Owned by GameController
			+ Talks directly to TextRenderContext (see below)
			+ Two sets of methods:
				+ 1: State-modifying:
					+ TextLayer::SetStatusTextes()/Enable
					+ TextLayer::AddEphemeralText(lines[], float lifetimeSeconds)
						+ Standard fade-in/stay/fade-out
						+ Handles slots and their rotation
				+ 2: void Update()
					+ Does things againts TextRenderContext, which will be rendered autonomously later by TextRenderContext
		+ TextLayer takes shared_ptr<TextRenderContext> in cctor
			+ Given by GameController, who takes it from RenderContext
			! RenderContext will forfait wrapping of text API's
		+ TextRenderContext cares about single-line texts only
			+ Make sure multiple-line support is not for perf
			+ API exposed:
				+ AddText:
					- text (1 line)
					- Justification
						- TopLeft, TopRight, BottomLeft, BottomRight
						- Implicit: l/r/t/b (screen-)margins
					- offsetScreenX
						- Meant to be distance from horizontal component of justification
						- Margin is added implicitly
						- For effects
					- offsetScreenY
						- Meant to be distance from vertical component of justification
						- Margin is added implicitly
						- Also provides getter for (screen-)height of line for font, and getter for fixed (screen-)v inset between lines
					- alpha
					- font
				+ UpdateText: different versions for:
					+ text only
					+ alpha only
					+ offsets only
				+ RemoveText
			+ Cleanup:
				+ Nuke old API
				+ Remove RenderContext's forwarding of API's
			+ Optimize alpha+offset update
		+ GameController:
			+ Use mTextLayer::ephemeral text for tsunami
			+ Nuke StatusText
				+ Also source files
			+ Expose DisplayLoadedLastPlayedSettingsNotification()
	+ SettingsManager: save settings, defaults, and real-time changes (*)
		+ Spec:
			+ Game starts always with default settings; user has the ability though to load named settings and to load
			  the last-played settings
			+ Changing settings in the GUI puts them in effect immediately
				+ ...and GameController will smooth them
			+ Loaded settings go to GameController
				+ ...and GameController will smooth them
			+ Dialog:
				+ Control values are meant to always be in sync with real game params
					+ Handlers enforce values immediately
		+ Plan:
			+ Standard paths: http://docs.wxwidgets.org/3.1/classwx_standard_paths.html#a4752213ef4d7bdc71170b9e5c3691f0f
				+ Via StandardSystemPaths class
			+ ResourceLoader::GetThemeSettingsRootFilepath()
			+ Settings framework
			+ OceanFloor:
				+ OceanFloorTerrain
					+ Has unique_buffer<float>
					+ other notebook methods
				+ OceanFloor contains and owns OceanFloorTerrain
					+ Needs it as a member as it exposes reference to it
				+ OceanFloor cctor needs to take default OceanFloorTerrain as && from outside, i.e.
				  from World who takes it from GameController as &&
					+ GameController provides the initial one loaded via
					  OceanFloorTerrain::LoadFromImage(ResourceManager::path of default system one)
				+ GameController::Reset():
					+ First takes current terrain, via World
					+ Then, passes it back to World's cctor, as &&
				+ Crash when reloading after having written last sample
				+ IGameController (and OceanFloor):
					+ Get[OceanFloor]Terrain() const -> OceanFloorTerrain const &
					+ Set[OceanFloor]Terrain(OceanFloorTerrain const &)
				+ Test:
					+ Default terrain at beginning
						+ Double-check interpolation we do at image->terrain algo
					+ Precision of adjusted terrain
					+ Reset: maintains manually-adjusted terrain
			+ FloatingSandbox/SettingsManager.h
				+ BaseSetting specialization for OceanFloorTerrain
					+ Does it need OceanFloorTerrain to expose Load(...istream...) ?
				+ Static factory maker
				+ Massage name to make it lower-case and underscore-separated
			+ Run unit tests in Debug
			+ MainFrame:
				+ Creates shared_ptr<SettingsManager> after it has all storages (GC, SoundController, etc.)
				+ Menu: "Reload last played settings"
					+ Only enabled if "last played settings" exists
				+ Save last-played settings on exit
					+ If UI Preferences say so
					+ Verify ocean floor
				+ Fix crash
				+ Fix Preferences Dialog
			+ SettingsDialog:
				+ Frame:
					+ See if appears in Taskbar
					+ Minimize
					+ Background
					+ Icon
					+ Cancel in OnClose
				+ Hookup settings
					+ Make ReadSettings(Settings const & settings)
				+ Get rid of mSoundController
				+ Take IGameControllerSettingsOptions
				+ Change standard bottom buttons
					+ Add "Restore Defaults", see paper
				+ New "Settings Management" tab:
					+ Keep entries sorted
						+ @ Insert
						+ @ Remove
					+ Catch FS exceptions, & OnPersistenceError(msg)
					+ Fix overwrite
					+ Test:
						+ Replace (overwrite)
							+ Via replace button
							+ Via save
						+ Delete
							+ First
							+ Mid
							+ Last
						+ Insert
							+ First
							+ Mid
							+ Last (need to nuke LastPlayed for test)
				+ "Restore Default Terrain" button
					+ "Adjusts the jaggedness of the ocean floor irregularities."
					  -> "Adjusts the contrast of the user-drawn ocean floor profile"
				+ Tooltips on buttons
				+ Float on Parent issue: clicking back moves it back
					+ See if may use wxSTAY_ON_TOP, & if that is also broken with colour picker
			+ Visual notification when last settings loaded
				+ 1) Need boolean returned from SettingsManager
				+ 2) Do StatusText replacement (*)
				+ 3) Do notification (@GameController)
			+ Data\Themes:
				+ Ocean of Lava
					+ See PM's suggestion on Discord
				+ Marianas Trench
					+ https://clasticdetritus.files.wordpress.com/2008/11/profile-mariana.jpg
					+ Fix sudden ocean floor:
						+ ParameterSmoother has SetImmediate(.)
							+ Stops smoothing, updates mTargetValue with clamped value, and sets
							- Unit tests, w/subsequent Update() call which should be nop
						+ I/GameController has also SetOceanDepthImmediate(.)
						+ BaseSettingsManager has two enforcers, second one is "Immediate"
							+ Exposes new EnforceDirtySettings"Immediate"(.)
							+ EnforceDefaultsAndLastModifiedSettings(.) calls "Immediate"
							+ Unit tests, verify each is called only when expected and not when not expected
						+ All callers of (Base)SettingsManager::EnforceDirtySettings(.) should check whether they need
						  to call EnforceDirtySettings"Immediate"(.) instead
							+ SettingsDialog: all but OnLiveSettingsChanged(.)
						+ SettingsManager populates second "Immediate" set of enforcers
				+ See if need bold for system settings
					+ Need wxListCtrl
		+ Small rearc:
			+ SettingsManager:
				+ From:
					! void LoadPersistedSettings(key, settings &)
					! void LoadAndEnforceLastPlayedSettings()
				+ To:
					! void LoadPersistedSettings(key, settings &) // only loaded dirty on output
					+ void EnforceDefaultsAndPersistedSettings(key) -> Settings (all clean)
					+ void EnforceDefaultsAndLastModifiedSettings() -> void
						+ Just calls above w/standard key
			+ See why ocean floor settings appear to be superimposed
				+ It's just OceanDepth for one, and custom for other
			+ Have two different "load" buttons:
				+ 1) "Apply Settings": "Loads the settings and applies them on top of the current settings." (i.e. current behavior)
				+ 2) "Revert to Settings": "Reverts all settings to the saved settings." (i.e. enforce {Defaults+Loaded} rather than just Loaded)
			+ Make "last-played" really "Last-Modified"; i.e.:
				+ Settings.h/cpp:
					+ Rename
					+ Rename in key
				+ Rename in menu
				+ Rename in *find*
		+ Run unit tests in debug
	+ Save ocean floor terrain and load it at startup
	+ ShipLoadDialog: ship preview database/cache
		+ Prep:
			+ ShipDefinitionFile:
				+ Load(png V shp)
				+ IsShipDefinitionFile(png V shp)
			+ ShipPreview:
				+ Load: based off ShipDefinitionFile::Load implementation
				+ Has path of preview image file ("preview image file path"), not preview image file itself
					+ Also exposes LoadPreviewImage() to load preview image on-demand
			+ ImageData::MakeCopy() -> unique_ptr
		+ Cleanup:
			+ Also version check @ header
			+ Min files is 10
			+ Header: also store sizeof(int) & check at load
			+ Comment on initial streak - what optimizes
			+ Base DB class: primitives for de/serializing RgbaImageData
		+ ShipPreviewDirectoryManager:
			+ Has PersistedPreviewImageDatabase to manage loaded DB (evt empty),
			  and NewPreviewImageDatabase to manage new DB
				+ Both derive from abstract PreviewImageDatabase w/definitions
				+ In PreviewImageDatabase.cpp/.h
				+ PersistedPreviewImageDatabase: used to manage an existing DB
					+ Key is preview image file filename
					+ Value is:
						+ last modified
						+ offset & size
					+ static Load(db filename) -> ShipPreviewDatabase
						+ If no db file exists => constructed as empty (empty index map)
						+ open file
						+ Populate ordered map (index) from file index:
							+ key: preview image file filename
							+ value:
								+ last modified
								+ offset & size
						+ private cctor(ordered_map, stream)
					+ private cctor(ordered_map, stream): stores members
					+ Get(preview image file filename, last modified) -> uq_ptr<ImageData>
						+ If has data for it in map & last modified is valid: load from db;
						  else: return null
				+ NewPreviewImageDatabase: used to manage a new DB
					+ Key is preview image file filename
					+ Value is:
						+ last modified
						+ uq_ptr<ImageData>
					+ public cctor(): initializes empty index map (ordered map)
					+ Add(preview image file filename, last modified, uq_ptr<ImageData> (nullptr if no change from old DB))
						! invoked always, even for unchanged preview images
						+ check if not already in map => error
						+ if not deprecated: store in index:
							+ key: preview image file filename
							+ value:
								+ last modified
								+ uq_ptr<Image> (nullptr if no change from old DB)
					+ Commit(db filename, PersistedPreviewImageDatabase const & oldDb, isNewCompleted)
						! All exceptions here are silently caught and commit is (cleanly) aborted
						+ if new is empty or (new is deprecated and old not empty) => nop (return)
						+ Enforce min # of entries, if completed
						+ initialize empty "new persisted index" (same index as PersistedPreviewImageDatabase, they're friends)
						+ 1) Copy from old DB as long as possible:
							+ start_copy_offset = 0
							+ end_copy_offset = header size
							+ for each index position in both indices:
								+ if keys match and image data in new is null:
									+ copy (increment end_copy_offset)
									+ update new persisted index
								+ else: break
							+ if full match w/old one: return
							+ copy start_copy_offset->end_copy_offset
						+ open tmp output file for w; truncate
						+ 2) Save own
							+ for each index position in continuation of this::index:
								+ if uq_ptr<Image> is null:
									+ copy from old appending to file
									+ update new persisted index
								+ else:
									+ append image to file
									+ update new persisted index
						+ 3) Save new persisted index
			+ API:
				+ static factory (folder path) -> uq_ptr(self)
					+ load existing database (PersistedPreviewImageDatabase::Load)
					+ passes db to private cctor
				+ private cctor(vector<filepath> &&, PersistedPreviewImageDatabase &&)
					+ stores both as const
				+ Enumerate: makes (sorted) list of filepath's
				+ LoadPreviewImage(ship preview) -> image
					+ Algo:
						+ get last modified of preview image file
							- if error => mark new DB as deprecated; return error
						+ if oldImageDatabase::Get(preview image filename, last modified):
							+ newImageDatabase::Add(preview image filename, last modified, nullptr)
							+ return image
						+ else:
							+ Load image
								- if error => mark new DB as deprecated; return error
							+ newImageDatabase::Add(preview image filename, last modified, image::copy)
							+ return image
				+ Commit(isCompleted)
					+ CachedPreviewImageDatabase::Commit(..., isCompleted)
					+ Close old DB
					+ delete old file, rename tmp file
		+ Unit tests
		+ changes.txt
		+ Manual & perf test
			+ Full
			+ Half
			+ Broken ship
			+ Repaired ship
	+ ShipLoadDialog toolbar (*): 
		+ Toolbar:
			+ Above preview window
			+ Move "Info" button here
			+ Flip H and V, Rotate 90 CCW (toggle buttons, wxBitmapToggleButton)
				+ UI
					+ ForGame: three toggle buttons
					+ ForShipBuilder: password-protected
						+ Update enabled just like we do for info
						+ Open popup when clicked: ~"This ship is password-protected for editing."
					+ Wider search box
				+ Given as ShipLoadSpecifications to ShipFactory, hence must be returned by ShipLoadDialog to caller
				+ FS::MainFrame handles ShipLoadSpecifications
					+ Should also have UIPreferencesManager remember ShipLoadSpecs at LastShipLoadedFilePath, instead of just file path
				+ SB::MainFrame deals with ShipLoadSpecifications - but only stores path
					+ ShipLoadDialog templated on enum - ForGame, ForShipBuilder
				+ ShipLayers class (@ existing Layers.cpp/h), with Flip() methods applied to all layers
					+ Class
						+ Flip, Rotate
					+ Used at ShipDefinition
					+ Used at ShipLayers also @ ShipBuilder::Model
					+ Unit tests
						+ Flip
						+ Rotate
				+ ShipFactory uses it
				+ Tests:
					+ ShipLoadDialog:
						+ ForGame: flips, rotates
						+ ForShipBuilder: shows password protection
					+ Main: reload this ship, reload previous ship
					+ Last ship specs saved and then loaded in preferences
			+ Sort method, as:
				+ BitmapButton, showing currently-selected sorting method
					+ When clicking on it, popup appears with horizonal buttons
						+ Icons:
							+ Name ("A/Z")
							+ Date added (clock?)
							+ Year built ("1912" w/e.g. "2" over "3")
							+ HD/Elec/... (ribbon)
					+ When a button is selected, popup disappears amd BitmapButton icon changes to selected one
				+ Thin button with either up or down arrow, thin horizontally but as tall as previous BitmapButton
					+ Clicking on it toggles asc/desc for sorting, and bitmap
				+ By: Name, Date added, Year Built, HD/Elec/0
					~ Date added: see after install if file creation dates are still originals
				+ Sorting impl @ PreviewWindow:
					+ Selection is by ShipId, not index
						+ Assigned at creation, taken by thread as well
							+ DirectorySnapshot must store them
						+ Adjust to new DirectorySnapshot:
							+ ResetInfoTiles()
							+ Thread's directory scan
							+ Main Thread's handling of PreviewReady
							+ Main Thread's handling of PreviewError
						+ Helper methods:
							+ GetInfoTileIndex(size_t ShipId) -> size_t
					+ Vector of info tiles is assumed to be always sorted by the currently-selected method
						+ Change InfoTile: needs to become agnostic of own position in grid, which also needs to be recalc'd a) at each new InfoTile, and b) at each change of sorting
						+ Replace those members with functions that go to and from linear position in InfoTile vector to VirtualRect
						+ Do strongly-typed ship file ID
					+ Do sorting						
						+ Has std::function "sort predicate" member, memoized by SetSortMethod/Direction()
							+ Make non-metadata tiles (e.g. errors) always appear at end - do not use direction here
							+ By name
								+ Case-insensitive
							+ By year
								+ No year goes to end
								+ Same year: by name (case insensitive); same name: by ship ID
									+ By name and by ship ID: should not honor direction
							+ By features
								+ InfoTile: FeatureScore member, populated at InfoTile preview ready
								+ Same feature score: by name (case insensitive); same name: by ship ID
									- By name and by ship ID: should not honor direction
							+ By last modified
								+ LastModified is new attrib of ship definition file serialization @ shp2
									+ PortableTimestamp type
										+ From std::filesystem::path
										+ From now()
									+ Returned by ShipPreview
									+ New format: in ShipAttributes:
										+ Serializer::Save: take Now()
											+ Write new ShipAttributes tag
										+ Deserializer::Load: read from new tag; if not found => from file
										+ Unit tests
											+ Load: both formats
									+ Other de-serializers: read from file
								+ Same last modified: by name (case insensitive); same name: by ship ID
									+ By name and by ship ID: should not honor direction
						+ Initial DirectorySnapshot sorting should be invariant from sort direction
							+ Or else won't match if changed in-between
						+ Need to sort at:
							+ Sortmethod change
							+ InfoTile preview ready																
							+ InfoTile preview error
							+ ResortInfoTile(infoTileIndex)
							+ For insert to work, initial InfoTiles must already be fully sorted by predicate
						+ At each sort, need to call EnsureTileIsVisible

			+ Move search here
			+ Move "Ok/Cancel" buttons below next to dir dropdown (taking place of "search")
		+ Tests:
			+ Sorting:
				+ Last modified: E2E
				+ Slow population
					+ Do artificial 100ms sleep @ thread, with various sorting methods
				+ Year built: the string sorting that we do matches year numeric
				+ Preview error
				+ Search: goes from selected onwards - in right order and always down
			+ Test on old Dell

+ Gfx:
	+ Do ropes with two endpoints (000xxx)
		+ Throw exception if doesn't find two endpoints
		+ Algo:
			+ Step 1: build vector<PointInfo> & Matrix<opt<pointIndex>> & vector<RopeInfo>
			+ Step 2: visit RopeInfos and add to PointInfo's and SpringInfo's
			+ Step 3: visit PointMatrix & ...
		+ Starting perf:
			+ Default ship: 14.1/14.3
			+ Ropes test: 12.2/12.3
		+ Need to always use color when rendering springs:
			+ Spring::Type (Hull, Rope)
				+ No exposed, just IsHull() & IsRope()
				+ Make it a bit flag
			+ Separate RenderContext method for Ropes, stored in separate Element (RopeElement, structurally == SpringElement)
				+ Upper bound for # of spring ropes given # of points in connected component:
					+ N
					+ Upper bound of 'normal' springs doesn't change
			+ Render: draw ropes after springs and triangles (we want them on top of triangles!), still by connected component
				+ Use own program
		+ Ending perf:
			+ Default ship: 14.2
			+ Ropes test: 12.3
		+ Don't make triangles of 3 rope points if at least one is connected to ropes only
			+ Fix Base III?
		+ Flip order of rendering when structure: triangles first, then ropes
			+ Need private subparts of Render()
		+ Ending perf:
			+ Default ship: 14.5
			+ Ropes test: 12.3
		+ Add ropes to Titanic
			+ Make wood non-hull
		+ Fix unit tests
		+ Make max(fixedSizeVector) == 9
			+ Not for triangles - generated rope points will never participate in triangles
		+ Material/Rope rearc:
			+ MaterialDatabase
				+ Loads itself from json
					+ From ResourceLoader invoked by GameController at init'n
				+ Guarantees:
					+ Exactly one material with isRope=true
					+ Color is #000000
					+ No colors clash, and no colors fall within rope range
				+ Replace in GameController, ResourceLoader
				+ Remove ropeMaterial kung-fu @ Ship::Create and use material->IsRope
				+ GameController also gives rope renderColour to RenderContext at cctor
					+ Which sets shader's hardcoded parameter
	+ Try light diffusion rearc:
		+ No more at C++, but rather in OpenGL as in the following example (written for ShipTriangles only but valid also for springs
		  and points):
			+ Prerequisite: draw ship triangles by connected component (see above)
			+ Turn off diffusion
			+ For each component: pass array of all lamps in that component; each lamp has {x, y, intensity};
			+ Draw each connected component N times (use additive blending), once for each lamp,
			  each time passing the single lamp properties as uniform to shaders,
			  which calculate distance and do final light blending
				+ Check right way of doing blending
		+ REJECTED: perf was awful; this multiple-pass way of doing it hurts too much

	+ Texture mapping:
		+ UploadLandAndWaterStart()/./End()
			+ Just specify land y and water y
			+ Impl:
				+ y:
					+ To LandBuffer
					+ To WaterBuffer
			+ RenderLand()
			+ RenderWater()
		+ Land (sand)
			+ bottom is not anymore a param but it's filled by RenderLadn(.) with +/- mWorldHeight/2
				+ only param is x and y (world y)
			+ texture coordinates are world coordinates
			+ Magic number is based on desired tile world size
		+ Water
			+ Use "water transparency" uniform in shader that sets alpha value in result of texture
			+ Make texture stretch wrt vertical height of water strip
			+ Change map, this one's ugly
		+ Clouds
			+ Use N textures, each has own rectangular size
			+ RenderContext loads all available textures and uses them for the clouds, modulo
				+ ResourceLoader::LoadTexturesRgba(prefix)
					+ initProgressSink lambda
			+ GameParameters.NumberOfClouds (constants)
			+ World takes numberOfClouds and allocates clouds buffer with random values
			+ Then, RenderContext::RenderCloudsStart()/./End()
				+ Buffer contains virtualX and virtualY, and scale
				+ RenderContext::RenderCloud() makes rectangles (in world coords) based off formula
			+ Clouds stencil:
				+ Draw waterbuffer without texture, but reverse stencil op
		+ Ship, using second image
			+ Load ship == image or .shp (JSON)
			+ First, try naively with just point colors
				+ Doesn't work, as structural image has too little resolution
			+ RenderContext is given optional texture image (by GameController) via
			  RenderContext::AddShip(iShip, opt<ImageData>)
			  + Requires RenderContext::ResetWorld()
				+ Simply clears vector of ShipRenderContext()
					+ ShipRenderContext contains everything ship-related
						+ Rename springs and triangles to "Elements"
						+ Touch points with outside world:
							+ Parameters (booleans, render factors)
							+ OrthoMatrix
							+ Helpers
				+ No need to reset others (land, water, clouds) as their numbers, positions, and data will be given
				  at the next Render() from scratch
					+ But it could easily by re-creating uq_ptr<XYZRenderContext()>
				+ Call from GameController
			  + Adds ship with opt<ImageData> in arg
				+ If specd, cctor creates <OpenGLTexture mElementTexture> and uploads immediately
				+ mShipTextureCoordinatesVBO and other texture machinery is created at startup anyway (if any)
				+ No need for std::optional<ImageData> TextureImageData
			  + Remembers if ship has texture via mElementTexture
			  + Catch exceptions at all interactions of MainFrame with GameController, and display DialogBox
			  + ResourceLoader::LoadShipDefinition: need to make paths abs wrt .shp path
			  + Refactor to World::CreateShip() -> ID -> Ship::Create()
			  + Land and Water texture names: do own, not from array
			  + Always unbind texture2d after a render
			+ Also, later, RenderContext is also given textureCoords,
			  i.e. a buffer of texture X's and Y's (i.e. initial points' coords) for
			  each of the ship points (i.e. aligned with the point buffer which will be continuosly uploaded)
			  + TextureCoords created by Ship::Create (always), stored into Ship, and given to RenderContext
			    (which uploads it, always) once and for all at the same time as colors (i.e. when IsPointCountDirty)
			+ If a texture is associated with the ship, RenderContext uses a different shader for ShipTriangles
			+ Krafting:
				+ Y offset for initial drop
				+ Remove one layer of hull from bottom, but see how much it bends afterwards

	+ Draw stressed springs with their own hardcoded texture (1D, 3 pixels: red, red/white, red) of a reddish line with "hot" centre
		+ https://stackoverflow.com/questions/17866308/texture-a-line-in-opengl
		+ Make it a 2D with semicircle around T,L corner
			+ textureCoords are inputPos
	+ Fix springs showing up around texture from structure
		+ Make test .shp with three masses and a rope
	+ Draw points:
		+ Ship uses RenderContext::UploadPoint(elementIndex), only for !deleted points
		+ Then, glDrawElements(GL_POINT)
		+ Nuke PointProgram as it's dupe now
	+ RenderContext:
		+ Get rid of pre-generated texture names and create on-demand
			+ Test!
		+ See if can describe point, color, and texture VBOs at init
	+ Should draw each connected component at once
	+ ShipTexture: Experiment with different min/mag filters
		+ Try mipmaps, should help make the Titanic artifacts disappear
			+ OpenGLGame::UploadMipmappedTexture(imageData) -> void
				+ Does base and all the dimensions down to 1x1, using floored extents
				+ Algo: take avg of each square of points, including alpha
			+ Use GL_LINEAR_MIPMAP_LINEAR
			+ See https://www.khronos.org/opengl/wiki/Texture
			+ Then nuke ImageData stored in RenderContext's
			+ Use at:
				+ Ship
				+ Remove from Land? Test w/out and see if border
			+ Test perf
	+ VectorField rendering
		+ Final cleanups:
			+ Check all vector fields wrt deleted points
			+ RenderContext: initialize vector render mode to None
			+ Make vector field render mode changeable in SettingsDialog, Render tab
			+ Add length adjustment as render parameter, multiplied by RenderContext before passing to ship
				+ No dialog adjustment needed yet
	+ ShaderManager
		+ WetColor, LightColor: make them static hardcoded params
		+ Use in and out, and 130
		+ Replace all shaders
			+ RenderContext
				+ Use "in" as prefix of inputs
				+ glEnableVertexArrays: all at top, as they have nothing to do with VBOs
					+ ShaderMgr enables all the used ones
					+ Ship/RenderContext Code only disables zero when it's not used
			+ ShipContext
				+ Ship/RenderContext code only disables zero when it's not used
				+ Remove unnecessary bind's for VBO's that source dedicated attributes
		+ Get rid of vector_arrows shader, use matte
			+ Will need to re-bind attribute (GenericPosition or VectorPosition=0) to vectors VBO
			+ Deep cleanup
				+ enums
				+ shader
		+ Replace glBufferData with glBufferSubData when size does not change; at Ship only:
			+ Point positions, color, water
			+ Check perf before and after:
				+ Pre: 26.6
				+ Post: 27.3
	+ Fullscreen:
		+ ESC to go out, menu option/F11 to fullscreen again
		+ Add to changes
		+ Text at RenderContext
			+ Do Render:: move
			+ Render::Font
				+ Loads itself like TextureDatabase, with IProgress
				+ Owned by Render::TextRenderContext, created at cctor
					+ Render::TextRenderContext owned by Render::RenderContext, which fw's all calls to it
				+ Has method to calc pixel size given char* and size_t
				+ Has method to append vertices given char* and size_t
					+ Returns # of vertices appended
			+ TextRenderContext
			+ TextLayer:
				+ Owned by GameController, which FW's to it
				+ SetEnabled(bool)
			+ Debug:
				+ glCheckError macro at GameOpenGL.h
					+ Make it inline
					+ Use it at RenderContext and ShipRenderContext setup and rendering, instead of various checks
			+ Cleanup Font.h
			+ Add & change StatusText font
			+ See response to Toggle Status Text
			+ Do better initial text (invoke at MainFrame cctor)
			+ Update AboutBox and tell guy
			+ Check perf
			+ Perf optimizations:
				+ Precalcd stuff in FontMetadata, indexed by char
	+ Option to enable drawing of force vectors for each point
		+ Ship::Update() takes also RenderContext const &, so can check if need to save force buffer
			+ Points::SaveForceBufferForVectorRender()
		+ Copied right before integration
	+ Orphaned points
		+ Idea: always draw orphaned points - those that come after destruction
		+ Orphaned point == points with 0 connected springs
		+ We unify ephemeral points uploading and rendering with ship points (either debug or orphan) uploading and rendering
			+ Plane ID is enough to keep them on separate planes
		+ Verify first that connectivity visit really assigns plane IDs also to orphaned points
		+ Impl:
			+ We must first stop deleting points just because springs are deleted
				+ Though should still delete them at Destroy() and Bomb(), for example
			+ Unify non-ephemeral and ephemeral points in element VBO
				+ Need hint from Points on whether or not ephemerals will follow
			+ ShipRenderContext:
				+ Nuke RenderEphemeralPoints and its structs and members
				+ Have just one single RenderPoints
					+ Always invoked, except when DebugShipRenderMode is not None and not Points
					  (i.e. when it's Springs, EdgeSprings, etc. but not Points)
		+ Test L'n'F'
		+ Cleanup:
			+ Ship: generation of air bubbles: atm we don't generate air bubbles for orphaned points; see if this should change instead
	+ Bug: bombs et al fade more rapidly than ship when ambient light goes away
	+ Make font white inversely to ambient light
	+ Stars at night
		+ Render:
			+ Need to be done at clouds, w/water stencil
		+ Physics::Stars
			+ Update(GameParams) -- recalcs if # changed
			+ Upload(RenderContext)
			+ Managed by world
		+ Test ambient light -> transparency curve
		+ Test customizability
		+ Compare with screenshot
		+ Check performance
			+ FPS: 28.4
			+ PerfAnalysis
	+ Add world end markers
		+ Add texture (square,repeatable in both directions)
		+ RenderContext::init:
			+ Don't load in atlas
			+ Make it repeated
		+ Final step @ RenderContext::Render
			+ Checks first which sides, if any, have to be drawn
			+ Renders quad for each side
				+ Width is in NDC
				+ alpha = 0.5 (in shader)
	+ (Retry) Use CPU and GPU in parallel
		+ Finalize render (glFlush) before render step, not after
			+ Research glFlush()
			+ By invoking glFlush() and SwapBuffers() in MainFrame, before Render()
	+ Test using gl_TexCoord to pass texture coords from vertex to fragment
	+ Selector to change color of (intaken) water
	+ Clouds in perspective (*): should relay perspective when moving camera up and down
		+ Distribute Z layers
		+ Do Y strata
			+ 3 strata, from NDCy=0.3 to NDCy=0.9
		+ Storm clouds
			+ z = 0
			+ random y
			+ test
		+ Cloud dynamics
			+ Redo explosion atlas
			+ Assign initial phases
			+ Growth progress needs to be incremental (or else wind speed changes are visible)
			+ Adjust velocity (slower) and make it depend on cloud speed
			+ Test using separate texture
		+ Textures:
			+ Clouds 2 and 9 are dupes
			+ Cloud 3 is truncated @ left
			+ New clouds
		+ Test:
			+ Mariana's Trench
	+ Incandescence: heat overlay more integrated in game play (*):
		+ New enum: HeatRenderMode (@ DebugShip, FlameRenderMode, etc.):
			+ Incandescence (default if calibration says it's ok)
			+ HeatOverlay
			+ None (else if calibration says it's not ok)
		+ Impl:
			+ Enum
			+ Replace DrawHeatOverlay boolean
				+ Turn HeatTransparency into HeatSensitivity, for both shaders
				+ ShipRenderContext:
					+ RenderParams
					+ Getters/Setters
					+ Shader Program
				+ I/GameController
			+ Shaders:
				+ #define w/#error
				+ Replaces black with alpha=0
					+ If it would also glow in the dark, it'd be awesome!
			+ Temperature upload when HeatRenderMode != None
			+ Calibration: Incandescence is default if calibration says it's ok, otherwise it's None
				+ Render score 
				+ Test old Dell for CPU score
					+ No noticeable CPU impact, but huge rendering impact
			+ SettingsDialog
				+ Move to render tab, in own section - radio and slider
				+ HeatSensitivity enabled depending on HeatRenderMode
		+ Perf:
			+ Before:
				+ Upload: 0.03/0.04
				+ Render: 5.20
			+ Try with vec3 downgrade
				+ If OK: change also type of lightColor and waterColor (both vec3 instead of vec4)
			+ Now:
				+ Upload: 0.04
				+ Render: 5.47 -> 5.41
		+ ShipRenderContext: rearc shaders & reactions to param changes
			! Goals: avoid settings params to a gazillion of shaders which we don't need
			+ RenderParameters: AreShipStructureRenderModeSelectorsDirty
				+ Set when DebugShipRenderMode or HeatRenderMode (or ...?) change
			+ Specific ProgramType members for ship structure
				+ mShipStructureXYZShader
			+ ProcessParameterChanges:
				+ When RenderParameters::AreShipStructureRenderModeSelectorsDirty:
					+ ApplyShipStructureRenderModeChanges()
						+ SelectShipShaders()
							+ Sets various mShipStructureXYZShader based on selectors
					+ Invoke ApplyViewModelChanges(), ApplyWaterContrastChanges(), Apply.... (all the ones that affect ship structure shaders)
			+ ApplyViewModelChanges(), ApplyWaterContrastChanges(), Apply...():
				+ Only set changes for mShipStructureXYZShader shaders
			+ RenderDraw:
				+ Use mShipStructureXYZShader members instead of hardcoded programs
			+ Full test:
				+ All debug modes times heat render modes
				+ Parameter changes followed by shader changes
					+ Water params, ViewModel params,
			+ Run ApiTrace
		+ changelist
			+ "...incandescence is now visible..."
	+ Night vision (*): ship is just not affected by ambient light
		+ New float setting: ShipAmbientLightSensitivity: 0.0 => fully visible at night; 1.0 => completely dark at night
			+ Formula: Param::EffectiveAmbientLightIntensity = (1.0 - ShipAmbientLightSensitivity) + ShipAmbientLightSensitivity * EffectiveAmbientLightIntensity
			+ RenderParameters
		+ SettingsDialog (under normal "Rendering" section)
		+ ShipRenderContext:
			+ Upon Effective?/AmbientLightIntensity change *AND* upon change of this new render setting: set effective ambient light intensity
		+ Test
		+ changelist
	+ Continuous auto-focus (*)
		! Spec:
			- Orchestrated by GameController's ViewManager by taking "optimal" AABB from World (which takes union of "optimal" AABB's from each ship)
			  and giving it to RenderContext, which adjusts ViewModel based on it				
				- At each simulation step
			- Preferences setting for auto-focus (default is on)
				- Also toggable at "Controls" menu
			- Also works as "auto-focus at load"
				- Or at least, funcs that calc zoom and pan based on AABBs is reused (by same ViewManager) in order to calc auto-focus at load
			- Full spec:
				- Orchestrated by ViewManager, member of GameController
					- Is given (externally-owned) references to RenderContext& and NotificationLayer&, managing all communication to these wrt view params
					- Owns view parameter smoothers						
					- GameController forwards view parameter changes to it
						- And ViewManager orchestrates talk with its own smoothers
				- Given resulting AABBs by GameController at own Update(), called after World::Update
				- Communicates activation and (also unsolicited) de-activation via new event handler, subscribed by:
					- MainFrame for option
					- GameController for notification texture
						- Can't do it itself via own NofificationLayer?
				- When user changes view params, we add offset to cumulative offset, which is then added to final result of auto-focus
					- So if user e.g. zooms out, the whole auto-focus is zoomed out
		+ Impl:
			+ Phase 1: ViewManager extraction
				+ Parameter smoothers: simplify by simply using convergence algo, coeff between 0.05 and 0.1
			+ Phase 2: rough auto-focus
				+ Make it so that World may be asked for AABBSet right after adding ship
				+ ViewManager::Update takes AABBSet
				+ AABBSet/visible world math
			+ Phase 3: improve auto-focus
				+ Try with continuous adjustments
				+ Calculations by ViewModel are on view model params being smoothed towards target; may lead to ghost offenses
					+ Need to make calculations based on target values; may test with "Immediate"
				+ See if can use tolerance to make adjustments less continuous
					X Decide if user may select tolerance - MAY BE NOT
				+ Simplify auto-zoom and pan calc's
			+ Phase 4: user's offsets
				! Cannot user smoothers' values when calculating auto-focus, unless we downscale them by user's offsets - which could have changed
					! This is because we want to calculate auto-focus and panning on the "screen" without user's offsets
				+ Need to store auto-focus zoom and camera pos - without user's offsets - and use those for calculating auto-focus
					+ Need to initialize them at auto-focus enable - with current smoothers' values
				+ Double-check math
				+ Fix user offset pile-up issue everywhere
					+ Do at update, eroding along direction, without crossing 1.0/origin
						+ Pan
							+ Erode x and y independently
						+ Zoom
				+ Autozoom-on-load:
					+ "Auto-zoom on load" setting moves to ViewManager
					+ ViewManager::OnNewShip(AABB...): if "auto-zoom on load" is on and no auto-focus: invoke AutoFocus(AABB...)
						+ Fix invocation without auto-focus session
							+ Just plain calc zoom and pan
							+ Fix issue: subsequent announcement generates resize hence OnViewModelUpdated() sets smoothers to current RenderContext values,
							  which are still way before convergence
								+ Used to work because of auto-focus doing SetValueImmediate()
								+ Reclamp
						+ Reset user offsets at FocusOnShip(), ResetView()
						+ Invoke from GameController
							+ See why first load doesn't focus
							+ Decide if we still want "ship reload" to NOT do auto-zoom
								+ Also decide whether we still don't want first load to do auto-zoom
								+ Test by turning off auto-focus
								+ Fix GameController accordingly
					+ ViewManager::AutoFocus: if auto-focus not set: invoke (private) DoAutoFocus() [; else: pointless as subsequent Update() will invoke DoAutoFocus()]
						+ DoAutoFocus(AABB...) contains implementation of zoom+pan
							+ Invoked also by Update()
			+ Clouds: better effect: clouds' NDC y should flatten quicker for lower CAM y - now it flattens linearly 
				+ Test storm
				+ Exponential: ste precalc'd member(s) @ Clouds::UploadStart()
			+ Test with auto-zoom filling-in larger sub-window
			+ Try other auto-focus algo
				+ 1: calc zoom as min zoom to ensure four quadrants
				+ 2: calc pan to center that
				+ New current *targets* of user offsets
					+ Or better: use SessionData->CurrentAutoFocusXXX
				X Try using current *ephemeral value* instead of targets
				+ If OK:
					+ Cleanup
					+ Update explanation/comment
			X Test faster convergence
			+ Do test w/goodyear
			+ Phase 5: enabling/disabling
				+ Main UI
					+ "Auto-Focus on Load"
						+ UIPreferencesManager
						+ Checkbox menu item 
							+ Tells to UIPreferencesManager
						+ PreferencesDialog
							+ Tells to UIPreferencesManager
						+ MainFrame::Reconciliate
					+ "Continuous Auto-Focus"
						+ UIPreferencesManager
						+ Checkbox menu item 
							+ Tells to UIPreferencesManager
							+ Then calls MainFrame::Reconciliate()
						+ PreferencesDialog
							+ Tells to UIPreferencesManager
						+ MainFrame::Reconciliate
						+ ESC to exit it
							+ Invoke Reconciliate()
					+ "Reset View"
					+ Reset view:
						+ Smooth
						+ Nuke FocusOnShip
						+ ResetView->...->ViewManager::ResetView
							+ If !auto-focus:
								FocusOnShip
							+ Else:
								zero offsets
							+ Leave ViewManager::FocusOnShip
					+ Test:
						+ Save of "Auto-Focus on Load"
						+ Save of "Continuous Auto-Focus"
				+ NotificationLayer
					+ Texture
					+ TextureLayer
					+ Pass NotificationLayer& to ViewManager::cctor
					+ ViewManager toggling it
					+ Test: at startup, honors saved value
						+ Off
						+ On
			+ Fix "pulsating zoom" issue
				+ Do more tests and see if really perfection
				+ If perfection:
					+ Cleanup
					+ Test with zoom first, like it used to be
			+ Thanos fix
			+ Phase 6: tuning
				+ Immediate pan: done smoothly in all cases?
				+ See if need different zoom and pan speeds, for "focus on ship" case
				X Try stateful threshold for cam Y; once through, no threshold
					X At least we damp initial waves
				+ Play with threshold algos
					+ CameraY Smoothstep route
						+ Test based on NDC (smoothstep on NDC fraction) rather than world
							+ Commit first
				+ If not ok: nuke threshold code
					+ But do keep updating mAutoFocus->CurrentXXX
			+ Remove every-other-frame thing
			+ Test for user offset accumulation problem, which is due to calculated pan being "too much", so user offset has to first counterbalance that before being able to make a difference:
				+ Clamp auto-focus only, *then* continue
			+ Cleanup:
				+ See if can nuke ParameterSmoother::IsSmoothing
				+ Move focus and pan calc'n out so may be reused by CenterOnShip
				+ See if can nuke local variables for "newAutoFocusXXX" and use mAutoFocus->CurrrentXXX instead
				+ See if still need all ViewModel methods (World<->Ndc)
				+ Icon				
				+ Take care of initial auto-zoom
			+ See if can do AutoFocus once every N frames
		+ Check if we were updating smoothers during pause
		+ Tests:
			+ Loading ship which has no frontiers: check behavior for all combinations of autofocus/autozoom
			+ Load under pause
			+ See perf impact on old Dell - UNNOTICEABLE!
	+ Structural Tension View (*)		
		! Spec:
			! Another "advanced rendering" setting
			! When enabled:
				! Zero out Tension (new float) at each point
				! At existing UpdateStrains:
					! Calculate "tension" for each spring (0.0 @ rest length, 1.0 @ breaking length) and add to endpoints
				! Average each point's tension across its own springs
			! Shader "variants" for each of the ship drawing shaders, mapping this new Tension float to color from Pac0's tension color map
		+ Code:
			+ SettingsDialog
			+ Points::UploadAttributes
			+ Ship::Update: prolog and epilog, all conditional to DebugShipRenderMode
				+ Ship::Update takes ShipDebugRenderMode
			+ Springs::UpdateStrains
				+ Private templated helper
			+ Render:
				+ Do first with simple shader superimposed to texture
					+ ShipRenderContext
					+ Shader
						+ Blue should show up more
					+ Try with max instead of sum
						+ Get rid of normalization if ok
		+ If nice, make better:
			! Spec:
				! Orthogonal flag, not ShipDebugRenderModeType
					! Goes to Ship::Update instead of ShipDebugRenderMode
				! Do with new #define which modifies ship_element.glslinc
				! Multiply spring/rope/triangle shaders by "_with_tension"
			+ Impl:
				+ ShipDebugRenderModeType -> new StressRenderModeType
					+ GameTypes
					+ SettingsManager
					+ SettingsDialog
						+ Under "Rendering"
				+ Ship::Update(...) takes StressRenderModeType - and whole call chain
				+ Shaders rearc:
					+ ShaderTypes: undo old, make new
					+ Nuke new "tension" shaders x 3
					+ RenderContext::param get/set for StressRenderModeType
					+ RenderContext::UploadShipPointStressAsync
						+ ShipRenderContext VBO/buffer & upload
					+ Shaders: (everything that has head now gets an extra "_tension" variant): (., heatoverlay, incandescence) x (., tension)
						+ ship_points_color
						+ ship_ropes
						+ ship_springs_color
						+ ship_springs_texture
						+ ship_triangles_color
						+ ship_triangles_texture
					+ ShipRenderContext:
						+ Set params at all new shaders
						+ Use right shaders for combo of ShipDebugRenderMode and ShipTensionRenderMode
				+ Test if stress map should be self-lighted, like heatmap
					+ Pay attention to ShipRenderContext::ApplyEffectiveAmbientLightIntensityChanges
			+ Test:
				+ All combinations of shaders
		+ On a separate topic: strength shader: sample only alpha from texture
			+ And may be other shaders as well?


+ Gfx Optimizations:
	+ Try without buffer population:
		+ Point has vec2f * const mPosition and vec2f * const mColour, pointing into two fixed buffers
			+ vectors are packed (static_assert on contiguous 2 or 3)
			+ Point does not live in PointerContainer but in std::uq_ptr<Point>[]
				+ Delete does nothing (Destroy does relationships though), just marks it
		+ Point also has mElementIndex, queried by springs and triangles when rendering themselves
			+ Can make Ship::Render const again, then
		+ Pointers to fixed buffers (as arrays of vectors) are owned by Ship and
		  are given by Ship to RenderContext at each Render via
		  RenderContext::UploadVertices(vec2f*, vec3f*, count)
		+ RenderContext usage of two buffers at each DrawElements:
			glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
			glVertexAttribPointer(vertexPositionAttribute, 3,  GL_FLOAT, false, 0, 0);
			glEnableVertexAttribArray(vertexPositionAttribute);
			glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);
			glVertexAttribPointer(vertexColorAttribute, 4, GL_FLOAT, false, 0, 0);
			glEnableVertexAttribArray(vertexColorAttribute);
		+ Point's vector pointers are populated by Point::Rebase(buf1, buf2),
		  invoked by Ship at construction
			+ Rebase() uses mPointIndex (rename of mElementIndex) to calc pointers
		+ Try: could also use buffer with mLight and mWater (uploaded each time to GPU as well) to be used by V->F shader
		  to blend fragColor with two fixed colors (water blended before ambient light, light after)
			+ F shader needs to start doing ambient light now, rather than point
			+ Need Point::CalculateWaterColorIntensity() (clamps and copies mWater to buffer),
			  and a dummy Point::FinalizeLightColorIntensity() (dummy because mLight is already finalized)
			  + or do clamp in shader, so use mWater and mLight straight from buffer, no CalculateX() needed
			+ If we put light and water in shader, then we don't need to reupload color buffer each time
		+ Bonus: also test GPU interpolation of mLight and mWater by emitting them at vertex
	+ Plan:
		+ 0: Test with additional mLight and mWater uploaded to RenderContext (same Point struct), and fragment shader doing math
			+ F Shader needs params: ambientLightIntensity; constants: waterColor, lightColor
			+ Remove point color calculation
			+ Check perf:
				+ Before: 16
				+ After: 14.1
				+ Keep in mind that we're adding to the buffer, while later we'll remove the colors
			+ Also test bonus: GPU interpolation of mLight and mWater by emitting them at vertex
		+ 1: if OK: PointCore struct (@GameLib) with {position, light, water}, based into Point
			+ Separate color buffer:
				+ Color struct (vec3f) has static_assert's for alignments
				+ Created by Ship::Create(), moved into Ship member (ElementRepository<vec3f>)
				+ Uploaded one-shot at first Ship::Render()
					+ via RenderContext::UploadShipPointColors(vec3f *, size_t elementCount):
						+ Uploads to GPU right away, with GL_STATIC_DRAW
						+ Stores size (mShipElementCount) for later assert
			+ Check perf: 14.2
			+ Commit
			+ Separate PointCore buffer:
				+ PointCore struct has static_assert's for alignments
				+ Created by Ship::Create(), moved into Ship member (ElementRepository)
					+ Points have already been based, at cctor by Ship::Create()
				+ Uploaded at each Ship::Render()
					+ via RenderContext::UploadShipPoints(PointCore *, size_t elementCount):
						+ Asserts size same as color buffer (mShipElementCount)
						+ Then uploads to GPU right away, with GL_STREAMING_DRAW
		+ Final:
			+ Nuke Point::CalculateColour
			+ Also do light/water color blending at ship *point* fragment shader
	+ Only keep separate color buffer and water/light done in F shader; point disembodiment was not a good idea

	+ Pack vertex attributes @ other shaders:
		+ clouds
		+ text_ndc
		+ FPS: 28.2/28.4

	+ Reduce # of bind VBO calls by delaying upload of buffers we own until we bind the VBO for drawing
		+ Land at RenderContext::UploadLandAndWaterEnd/RenderLand
		+ Also disable vertex attribute index zero once
		+ Test all ship shaders with 2 connected components
		+ FPS: 28.5

	+ Use MapBuffer when we know the sizes in advance, eventually re-allocating GPU buffer when the size changes
		+ Clouds
			+ Rename middle "RenderCloud" as "UploadCloud"
			+ Rename SharedAttribute1 as SharedAttribute0, et al
		+ Land, Water
			+ Also make clouds, land, and water use disjoint vertex attributes, so can bind once at each XYZStart()
			  before mapping buffer (and subsequently describe, when needed)
			  + Water, matte_water: use vec3 WaterAttribute
				+ Shaders
				+ RenderCore
				+ Description, once at initialization
				+ Disable 0 before running program
			  + Clouds: use vec4 SharedAttribute0
				+ Shaders
				+ Bind, allocate, and map at RenderStart()
				+ Description at Render() after unmapping buffer
				+ Enable 0 before running program, after description as usual
			  + Land: use vec2 SharedAttribute1
				+ Shaders
				+ Bind, allocate, and map at RenderStart()
				+ Description of SharedAttribute1 at Render() after unmapping buffer
				+ Disable 0 before running program
		+ FPS: 28.1/28.3/28.4
	+ Now, compare with replacing MapBuffer with BufferSubData
		+ Copy exe first
		+ Just this:
			+ Replace mXYZMappedBuffer with std::unique_ptr<XYZ[]>
			+ (Re)allocate buffer whenever we (re)allocated GPU buffer
			+ Remove MapBuffer call
			+ Replace UnmapBuffer call with BufferSubData
		+ FPS: 28.2/28.3/28.4
	+ Get full perf, including other laptops
	+ Texture atlas:
		+ Spec:
			+ Atlas is built on-the-fly, completely independently from texture DB, via a separate
			  component (TextureAtlasBuilder) that is given multiple TextureFrame's and eventually spits out TextureAtlas
			+ TextureAtlas:
				+ Contains:
					+ image: consumed by GameOpenGL helper for mipmapping
					+ metadata: used by GameOpenGL helper for mipmapping, owned by RenderContext (for clouds, land, and water)
					  and (by reference) by ShipRenderContext (for GenericTextures)
				+ Structure:
					+ ImageData Texture
					+ TextureAtlasMetadata Metadata:
						+ TextureAtlasFrameMetadata:
							+ box in atlas (i.e. texture coords, as 2xvec2f)
							+ TextureFrameMetadata
						+ vector<TextureAtlasFrameMetadata> / anything else addressable via TextureFrameId (see above)
			+ Separate mipmapper helper in GameOpenGL takes ImageData (by move) and TextureAtlasMetadata
		+ Impl:
			+ Phase 1: Clouds
				+ TextureAtlas
				+ ResourceLoader::SaveImage
				+ Resize all clouds to powers of two
					+ Test look & feel
				+ RenderContext:
					+ Cctor: create atlas and add just Clouds
					+ Upload texture - w/no mipmap for the time being
					+ Store Metadata (by value) and handle
					+ Use Atlas metadata at UploadClouds()
				+ Test 1
				+ Get rid of need to use TextureRenderManager at RenderContext for clouds
				+ Draw all clouds together at once
					+ Need triangles
				+ RenderContext:
					+ Call GameOpenGL mipmap helper moving Texture and passing Metadata
				+ Test 2
					+ FPS: 28.5/28.6/28.7
			+ Phase 2: Generic Textures
				+ Resize all generic textures to powers of two
					+ Pin
					+ RC Bomb
					+ RC Bomb Ping
					+ Timer Bomb
					+ Timer Bomb Defuse
					+ Timer Bomb Explosion
					+ Timer Bomb Fuse
					+ RC Bomb Explosion
					+ Timer Bomb Explosion
					+ Test look & feel
					+ Fix timer bomb issue
				+ Fix texture coordinates in atlas to be between 0.5/dim and 1-0.5/dim
					+ Test it first simply at current generic texture upload
					+ See Moleskine
					+ Do in atlas UV coordinate generation
				+ RenderContext:
					+ Cctor: add entire database to atlas minus land and water
						+ Make builder stateful
					+ Pass Metadata and texture handle to ShipRenderContext
					+ Bind:
						+ Atlas before clouds
						+ Land, Water before land and water
				+ ShipRenderContext must take from RenderContext:
					+ Atlas texture handle (&), for binding it at GenericTextures
						+ At least until we do Z and GenericTextures moves up to RenderContext
					+ metadata (&)
				+ ShipRenderContext:
					+ Bind atlas at GenericTextures
					+ Use box in atlas at Generic Textures upload
					+ Modify GenericTexture to run once for all textures (still for each connected component until Z)
						+ Populate quads directly in connected component GenTexElement vector
							+ Make room as needed (emplace_back)
							+ Store max size among all connected components in SRC member
						+ Upload connected component GenTexElement vector at RenderGenericTextures()
							+ Realloc buffer if new max size != m allocated max size
							+ Then always BufferSubData
						+ Test with multiple connected components
					+ Nuke TextureRenderManager member and cctor arg
					+ Cleanup RenderContext's upload of textures
			+ Remove test saving of atlas
	+ Figure out what's most expensive with perf analysis and noinline
		+ Only triangles: 42fps
		+ Triangles and ropes: 42fps
		+ Only springs: 32fps
		+ Is it stenciling, flushed at Ship::RenderEnd()?
			+ With no stenciling: FPS: 29.4/29.5
	+ Enable stenciling only when needed
		+ FPS: 29.0
	+ Try Render1/Update1/Render2/Update2
		+ @ GameController and down
		+ No improvements
	+ All textures: test changing GL_LINEAR_MIPMAP_LINEAR to:
		+ GL_LINEAR_MIPMAP_NEAREST
		+ At:
			+ Land and Water
			+ Atlas
	+ In texture or structure mode, draw only springs that are visible
		+ i.e. springs with # of triangles < 2
		+ Impl:
			+ Springs:
				+ New buffer: SuperTrianglesCount - type: ElementCount
					+ Publicly exposed
					+ Populated via argument at Springs:Add
						+ Calc'd by ShipBuilder via Triangles below, during component springs discovery
					+ Decremented via Springs::RemoveSuperTriangle() // no args
			+ Triangles:
				+ New buffer: ComponentSprings - type: std::array<ElementIndex, 3>
					+ Publicly exposed
					+ Populated via argument (of type std::array<ElementIndex, 3>) at Triangles:Add
						+ Calc'd by ShipBuilder
					+ Never changed
					+ Used by Ship::TrianglesDestroyHandler() to decrement count for each component spring
			+ Triangle destroy: remove self from springs
			+ Springs destroy: remove self from super triangles
			+ ShipBuilder:
				+ Adjust to new
				+ Also take care of traverse springs
			+ New ShipRenderMode: EdgeSprings only
				+ ShipRenderContext: treated exactly like SpringsOnly
				+ Springs::Render: used to decide what to upload
			+ Springs::UploadElements: in all modes except SpringsOnly, upload only springs with # of super triangles < 2
				+ Re-enable TODOTEST code
			+ Ship::Render() has to remember what ShipRenderMode was used last time, so to consider elements dirty
			  also when ShipRenderMode has changed

	+ See if can use multiple texture units
		+ Bind once atlas, land, and water at cctor, to each unit
		+ Change shaders to have one single texture sampler param, and set uniform locations to texture unit
		+ Do only for clouds, generic texture, land, and water
			+ Revert RenderContext.cpp, ShipRenderContext.cpp, TextRenderContext.cpp
			+ Fonts and ship stay as before, they use texture unit 0 - SharedTexture
			+ Shaders
			+ Remember to activate texture unit 0 before binding, at:
				+ Ship texture, stressed spring texture, font
		+ Fix: land, generic
		+ : test
		+ Replace calls to glActiveTexture with ShaderManager::ActivateTexture(parameter)
		+ Fix/Recheck progress bar
		+ Redo perf FPS measurement
	+ Z buffer:
		+ Rationale: more connected components => slower (multiple batches); try to draw one single batch then, using Z buffer and depth test
		+ Spec:
			+ Assign Z based on cousin of connected component ID (named "Plane ID", uint32_t)
				+ All points have PlaneId
					+ Can we revert ShipId and ConnectedComponentId to start from zero and having None=max?
						+ Yes, no one used NoneConnectedComponentId
						+ When we need stuff on top we can always use member variable with max plane ID and/or the total
						  count of ships
						+ If so, Plane ID starts from zero
					+ Own buffer (it'll have to be uploaded to GPU)
				+ Points that belong to a connected component also have ConnectedComponentId
					+ What doesn't have a ConnectedComponentId?
						+ ConnectedComponentId is used for:
							+ Frontier (possibly?)
								+ In this case we don't want to assign them to "cables" (0-triangle edges a.k.a.
								  0-SuperTriangle springs), nor to standalone points
							+ ForceFields that spring from a point
								+ But we can get rid of this and just explode all over the place, after all
								  explosions travel through air
							+ Not by light diffusion algo, see below
					+ We keep ConnectedComponentIds for future use, but do the frontier-type propagation, i.e.
					  we don't propagate them through "cables" nor assign them to standalone points; all of these
					  won't have a ConnectedComponentId at all
					+ So, what doesn't have a ConnectedComponentId?
						- "strings"
						- standalone points
				+ Assignment of PlaneId is done via the same connectivity visit used for assigning ConnectedComponentId's,
				  but we assign "single-spring paths" to the origin's PlaneId and don't propagate to solid body again
					+ So we draw as separate two pieces that are connected solely by a "cable" (**)
					+ Also rope triangles must be assigned to the origin's PlaneId
					+ Propagation algo: don't propagate if coming from a spring with zero SuperTriangles to a spring
					  with >0 SuperTriangles, unless these are all rope triangles
						+ New "IsRope" property of Triangle, pop'd by ShipBuilder; new buffer
				+ Light diffusion algo follows PlaneId's, instead of ConnectedComponentId's, as it's really about planes
				+ We assign Z after orthomatrix - in NDC - and thus positive is near
			+ We only enable Z test and writing to Z buffer at RenderContext before doing ships
				+ And later, if we move GenericTexture to RenderContext, also when we do generic textures
		+ Figure out range of Z:
			+ World: -1000 -> -1  ==> NDC: +1 -> -1
			+ We assign Z after orthomatrix - in NDC - and thus positive is near
			+ After matrix it's NDC: [-1, +1] (far, near)
			+ When given to fragment shader it's [0,+1], but we don't care anymore at this moment, as we calc Z in vertex shader!
		+ Mapping of <ShipId, PlaneId> to Z in NDC:
			+ Normal: ShipId=0 and PlaneId=0 are furthest
		+ Plan:
			+ Branch
			+ Preliminaries:
				+ Test explosions without connected component ID constraint; if ok, eradicate connected component IDs
				  from ForceFields
				+ Test perspective with hardcoded z=-1 at triangle shaders and z=-999 at springs, and see if it makes any difference
					+ Undo afterwards
				+ Do test images:
					+ Get problematic # of CC's first, with AM bomb on Titanic: 6,000
					+ ConnectedComponentsTestShip1: 8192 CC's, 33280 points, 49152 springs
					+ ConnectedComponentsTestShip2: 1 CC, 36588 points, 47882 springs
				+ Get initial perf:
					+ Default: 30.8
					+ ConnectedComponentsTestShip1: 3.10
					+ ConnectedComponentsTestShip2: 11.6
			+ Step 1:
				+ Add "PlaneID"
					+ GameType
						+ Same integral type as ConnectedComponentId
						+ Change ShipId, ConnectedComponentId, PlaneId to start from zero and have None=max (see @Spec above)
					+ Points: new buffer
				+ Points: add connected springs' "other endpoint"
					+ As part of Network
					+ Test fixed_size_vector::erase_first with/lambda
						+ Check assembly with unit tests
					+ Populated by whatever populates ConnSprings now (ShipBuilder or Points::Add)
					+ Nuke Springs::GetOtherEndpointIndex
					+ Write off work item from elsewhere in this file
				+ Run in debug and validate
					+ Revert to Render::uploading ConnCompId's
					+ Test crash w/Goliath
				+ Check perf
			+ Step 2:
				+ Connectivity visit:
					+ New PlaneId propagation (see @Spec above and Moleskine)
					+ Change ConnectedComponentId propagation to match frontier style (i.e. not on strings)
				+ Light diffusion algo now follows PlaneIds (see @Spec above and Moleskine)
				+ All the other things that currently require a ConnectedComponentId for rendering purposes:
					+ Bombs: substitute ConnCompId with PlaneId
					+ PinnedPoints: substitute ConnCompId with PlaneId
					+ Triangles: no ConnCompId nor PlaneId
					+ Spring: no ConnCompId, just PlaneId
					+ Ephemeral particles (check all Points::CreateXYZEphemeralParticle(...))
				+ Render: upload PlaneId instead of ConnectedComponentId
				+ Do ad-hoc tests to validate assignment of plane IDs and connected component IDs
				+ Run in debug and validate
				+ Commit
			+ Step 3:
				+ Ship/RenderContext: UploadPlaneIds(..., maxMaxPlaneId)
					+ Send to GPU right away, in buffer mapped to shared vertex attribute
				+ Test
				+ Commit
			+ Step 4:
				+ Enable Z test and writing to Z buffer:
					+ At RenderContext before doing ships, and disable afterwards
						+ Need World to invoke RenderShipsStart()/End() before going through individual ships
					+ Also clear Z buffer at canvas clear
					+ glEnable(GL_DEPTH_TEST);
					+ glDepthMask(GL_TRUE); // This at initialization
					+ glDepthFunc(GL_LESS); // This at initialization
				+ Test
					+ Also FPS: 32.0 - MIRACLE?!?!?
				+ Commit
			+ Step 5:
				+ Ship/RenderContext: PlaneID->Z calculations
					+ OrthoMatrix:
						+ Rename RenderContext's as "GlobalOrthoMatrix"
						+ Ship has own per-layer, calc'd (and set as uniform) at:
							+ private ShipRenderContext::OnViewModelUpdated()
								+ Invoked at:
									+ UpdateCanvas/Zoom/Cam (use struct - @ parent - with all params)
										+ What about visible world w/h?
									+ Changed nShips at RenderContext::RenderShipsStart()
										+ via ShipRenderContext::UpdateNumberOfShips(nShips)
									+ Changed MaxMaxPlaneId at UploadPlaneIds(...) call
				+ RenderContext ans ShipRenderContext: change OnXYZUpdated/UpdateXYX pattern: no args
				+ Test
				+ Commit
			+ Step 6:
				+ ShipRenderContext:
					+ See if can get rid of optionality of ship's texture
					+ Make dedicated shaders for each layer:
						+ Current => New:
							- Ropes: ShipRopes => ShipRopes
							- Triangles:
								- ShipTrianglesTexture: if !debug && RenderMode==Texture
								- ShipTrianglesColor: otherwise
								=> ShipTrianglesTexture, ShipTrianglesColor
							  & Springs:
								- ShipTrianglesTexture: if !debug && RenderMode==Texture
								- ShipTrianglesColor: otherwise
								=> ShipTrianglesTexture, ShipTrianglesColor
							- StressedSprings: ShipStressedSprings => ShipStressedSprings
							- Points: ShipTrianglesColor => ShipPointsColor (copy)
							- GenTex: GenericTextures => ShipGenericTextures (rename)
							- Vectors: Matte => ShipMatte (copy)
					+ Complete: assign per-layer ortho matrices
					+ Test & commit
			+ Step 7:
				+ Do actual ship ortho matrix calculation at ViewModel::CalculateShipOrthoMatrix
					+ See Moleskine for calc'ns
				+ All ship shaders take new vertex attribute and calc Z via OrthoMatrix
					+ Test first with triangles layer
					+ Do all other layers and shaders next
				+ Test all layers
				+ ShipRenderContext::UploadXYZElement() do not take anymore connected component ID
					+ Dismantle ShipRenderContext connected component tracking; store everything in buffers and/or upload directly
						+ cctor:
							+ // Elements:
								+ Reserve vectors w/maxes from old func
								+ Create VBO's
					+ Ship: nuke mConnectedComponentSizes
					+ Ship::Render:
						+ Nuke connected component empty check
						+ if mIsStructureDirty or debug mode changed:
							+ Upload parts individually
				+ Do ship triangles correct sorting
					+ Store bool owned_by_point in Points::ConnectedTriangles (see MOLESKINE)
						+ Store it sorted
					+ Replace Triangles::UploadElements() with Triangles::UploadElements<TIndices>(TIndices const &, ...)
					+ Ship:
						+ Populate std::vector<ElementIndex> at ConnectivityVisit with owned triangle indices only
							+ vector reserved at cctor
						+ ::Render(): still when mIsStructureDirty: Triangles::UploadElements(mIndices)
				+ Verify old behavior (ship triangles in texture mode are drawn incorrectly):
					+ With Titanic's back flag
					+ Temp triangles upload in old order
					+ Temp no springs draw
				+ Verify new behavior: OK
				+ Put back ShipRenderContext's Springs rendering
				+ Commit
			+ Step 8:
				+ Issues:
					+ Ropes jumping ahead (when new connected components come up)
						+ Due to incorrect planeID direction on Z axis: higher plane ID (recipient of string
						  assigned to previous (lower) plane ID) must be nearer (than string and its solid body)
					+ (Edge) springs countoured with background
						+ Testable with Titanic funnel
						+ Solution: draw triangles before all
					+ Ropes and anti-aliasing issue:
						+ Option 1: draw ropes *after* triangles and springs, but still in current layer (farther)
						- Option 2: see https://stackoverflow.com/questions/30426178/lines-appear-segmented-after-enabling-depth-testing:
							- Draw ropes first (in invoke order) with Z write off (Z test is irrelevant, as it'd be the first)
								- BUT: if there's no Z write then there's no Z test among ropes, hence
								  they'd cover each other wrongly
							- Draw everything else with Z write (and Z test) on
					+ Piece of rope appears to belong to higher connected component
						+ Was to be expected - after all last segment of rope is between two points that have
						  two different plane IDs, hence a part of the last segment will be visible
						+ Possible solution is to stop doing the "smart" string plane propagation altogether
					+ When pieces belong to same plane, (edge) springs are drawn in disagreement with triangles
					  (e.g. triangles invisible but their edge springs visible)
						+ Option 1: springs are drawn in layer Z-behind
						- Option 2: depth-sort springs as well
					+ After we start drawing ropes temporally after triangles (because of anti-aliasing issue):
						+ Ropes are now occluded by transparent (texture) triangles from same plane
							+ This is because ropes layer is Z-behind triangles layer
							+ Option 1: alpha test in shader
					+ Same plane: covering is now more random
						+ Analyze visit pattern
						+ Try with deque
						+ Try with old-style visit (step 9 below)
						+ Try following raster visit using per-plane indices in final vector
							+ 1: ConnectivityVisit: populate N+1 vector with # of triangles per plane
							+ 2: Triangles::Upload: take it and send endpoints to ShipRenderContext
							+ Test
							+ If ok:
								+ Add # of owned triangles to each point (new buffer)
									+ Init to 0 at Points::Add
									+ Update count at Points::Add/RemoveConnectedTriangles
									+ Use it @ ConnectivityVisit instead of counting triangles
				+ Undefine flood rendering
				+ See if need to and can make alpha threshold higher, to eliminate artifacts around ropes close to their endpoints on
				  Titanic's funnels
				+ Test texture mode
				+ Test structure mode
					+ See if loss of ropes over structure is ugly; if we can live without it, remove conditions and dual
					  rope rendering
				+ Test full RenderMode x DebugRenderMode matrix:
					+ Texture, ...
					+ Structure, ...
				+ Test stressed springs
				+ Commit
			+ Step 9: cleanup:
				+ ConnectivityVisit: redo visit from L to R and thus simplify ortho matrix
				+ Remove commented-out connectivity visit
				+ Commit
			+ Step 10: generic textures
				+ GenericTextures: is now own pass that uses own plane IDs as input for Z's in shader
					+ Upload plane IDs instead of conn comp IDs
						+ Fix at all calls from:
							+ Bombs
							+ Points::UploadEphemeralPoints
								+ The texture ones can now pass real plane ID, fix call chain up to caller
							+ PinnedPoint
					+ Fix grow problem at ShipRenderContext
					+ For now keep doing per-plane partitioning of textures for depth-sorting; we'll try alternatives later
					+ Pass PlaneID into gen tex shader (which must NOT take point's vertex attrib)
					+ Try without padding?
					+ That TODO for moving allocation of vertex buffer
						+ And rename of member: mGenericTextureRenderPolygonVertexAllocatedSize
				+ Test
					+ Gen textures are correctly covered by things (ropes, triangles, gen textures) in nearer plane,
					  and correctly cover things (ropes, triangles, gen textures) in further plane
					+ Test bombs - different planes
					+ Test pinned points - different planes
					+ Test eph particles - different planes
				+ Commit
			+ Step 11: vectors
				+ Add PlaneID to vectors
				+ Test & commit
			+ Step 12: ephemeral points
				+ EphemeralPoints: is now own pass that uses plane IDs as input for Z's in shader
				+ When eph particles are created (e.g. at Points::CreateEphemeralParticleDebris()), we write to the planeId buffer but
				  don't re-upload it; should mark plane ID buffer as dirty, but at two different segments, and then blindly
				  invoke UploadPlaneIdsIfDirty() from ship
				+ Test: eph points from multiple parts
				+ Commit
		+ Tests:
			+ Do perf analysis to catch low-hanging fruit
			+ Run in Debug
			+ Post perf test
				+ Benchmark:
					+ Orig:
						+ Default: 30.8
						+ ConnectedComponentsTestShip1: 3.10
						+ ConnectedComponentsTestShip2: 11.6
					+ New:
						+ Default: 29.1/29.5
						+ ConnectedComponentsTestShip1: 10.4/10.6
						+ ConnectedComponentsTestShip2: 10.8/11.1

				+ Gradual reduction to smithereens (anti-matter bomb w/Titanic)
					+ Check whether slowness during gradual decomposition - due to conn visit - is acceptable
		+ Cleanups:
			+ Points: order connected triangles so that owned are first
				+ Might be best done @ insert
				+ ConnectivityVisit::population of triangle indices: cut short connected triangles' visit as soon
				  as isAtOwner==false
			+ Light spread on surface changes abruptly when piece is cut; see if it makes sense for diffuse
			  to only light points whose plane ID is behind lamp (thus planeID<=lampPlaneID)
		+ Optimizations to try:
			+ PlaneID's being float's to start with
				+ ...as long as we don't need bucketization for GenericTextures' depth-sorting

		+ See if drawing springs & triangles at separate depths also helps generally with render speed, even for one single
		  connected component (for springs' fragment shader - may be it takes shortcuts if it knows it's behind)
	+ Use VAO's (*)
		+ Branch
		+ New OpenGLObject w/deleter
		+ Stars
			+ ShaderManager: allow for reusing numeric values
				+ UTs
			+ BoundedVector
				+ UTs
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test
		+ Clouds
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test
		+ Land
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute name)
			+ Test
		+ Move vertex attribute enabling out of shader manager and, for now, to where it is described
		+ Ocean and rest of RenderContext
			+ Use BoundedVector and handle GPU buffer (re-)allocation
			+ Shader (new vertex attribute names)
			+ Test
		+ Verify asm for Upload->emplace_back
			+ @ Stars::Upload
		+ TextLayer
			+ Test
			+ Then, move upload to VBO right after creating vertices
			+ Test
		+ Ship:
			+ GenericTextures
				+ Code
				+ Shaders
				+ Test
					+ Different planes
				+ Commit
			+ Vectors
				+ Code
				+ Shaders
				+ Test
				+ Commit
			+ Ship:
				+ One per "input configuration" + vertex element array
					+ Make sure to bind element array indices to the VAOs
				+ Have to repeat descriptions
				= Code
					+ Do explicit element array binding :-(
					+ Reduce VAOs
						+ To 1; nuke DescribePointVBOs()
					+ Reduce other calls
						+ LineWidth
						+ Texture activation and binding
				+ Shaders
				+ Test
				+ Commit
			+ Cleanup:
				+ RenderCore.h/cpp: remove unused attributes and other TODOs
		+ Get new FPS
		+ Merge
	+ Misc OpenGL Optimizations (*)
		+ Try all of these in isolation, or building on the previous one if the previous one is a clear winner
		+ Try STREAM with ship VBO buffers (apparently should do it without even testing!)
			+ RenderContext:
				+ Water, Land, Clouds
			+ ShipRenderContext:
				+ Mutable point attributes (pos, light, water)
		+ Try orphaning VBO
			+ RenderContext:
				= Water, Land, Clouds
			+ ShipRenderContext:
				= Mutable point attributes (pos, light, water)
			+ Figure out if should do null+subdata vs data
			+ Verdict: no detectable improvement
		+ Try with single VBO for elements, appending stuff to it
			+ Test:
				+ Dynamics between structureDirty changes and debugShipModeRender changes
			+ See if can cleanup enforced order between triangles and others
		+ ShipRenderEnd(): see if using the same shader for triangles and springs buys us anything
			+ Not really
	+ Vertex Buffer Optimization (*): reduce number of vertex attributes for ship shaders
		+ We've already confirmed that one less attribute vertex sends FPS frpom 29 to 30
		+ At this moment, all Ship shaders - except for stressed springs - have the following inputs:
			in vec2 inShipPointPosition;
			in float inShipPointLight;   *
			in float inShipPointWater;
			in vec4 inShipPointColor;    *
			in float inShipPointPlaneId; *
		+ Test 1: Light + PlaneId
			+ Requires "float planeID" work item first
			+ Code
				+ Points: make struct, with comment on "rendering performance"
			+ Shaders
			+ Test
			+ See FPS: 29.3/29.7/29.9/30.8
			+ If good:
				+ Commit
		+ Undo V->F shader in/out packing which we did at TrianglesTexture
			+ And move wetness calculation into vertex shader for all
			+ See if there are other shaders as well
			+ See if want to keep it:
				+ FPS: 29.8/29.9/
		+ Test 2: += Water + Pad
			+ Code
				+ Note: includes workBuffer copy @ WaterDynamics!
				+ GameTypes:Add to PointAttributeGroup1
				+ Points:
					+ Remove buffer
					+ Change getter & setter
					+ Wo workbuffer copy (replace water one)
				+ Ship::WaterDynamics
					+ Use PointAttributeGroup1.Water instead of Water
				+ RenderContext:
					+ Nuke upload water vector
				+ ShipRenderContext:
					+ Nuke upload water vector
					+ Describe new vertex attribute
					+ Nuke RenderCore::AttributeType
					+ Shaders
			+ Test
			+ Get FPS
				- Make sure laptop is quiet
			+ New Perf Analysis
			+ Commit if good
		+ Test 3: other shaders
			+ None
		+ Test 4: Bas' idea
			+ Revert to before Test 1
				+ ...but keep shaders
			+ Do interleaving just at ShipRenderContext
			+ Test:
				+ Light
				+ Water
				+ Vectors
			+ Check assembly
			+ Unbind VBO
			+ Check FPS:
				+ 30.0/30.4/31.1/31.2 (supercharged)/31.7
			+ Commit
		+ Test 5:
			+ ShipRenderContext: use MappedBuffer
				+ GameOpenGLMappedBuffer<TElement, WRITE_ONLY>
					+ Map(size)
					+ emplace_back(...)
						- w/assert that is mapped
					+ Unmap()
					+ ~()
						+ Unmap if mapped
					+ Remove that ugly GameOpenGLObject()
				+ Use where we upload temporarily to local buffer:
					+ Clouds
					+ Land and Ocean
				+ Check if good and, if so, commit
					+ 30.25/30.3/30.4/31.0/31.15
		+ Test 6:
			+ See if can also interleave Position and TextureCoordinates
				+ Name the other "AttributeGroup2"
					+ Fix all
				+ Make new "AttributeGroup1"
					+ Uploaded straight at ShipRenderContext::UploadPointMutableAttributes()
				+ Shaders
			+ Check perf:
				+ FPS: 30.7/30.7/30.8/30.9/32.0
				+ U/R: 193%
			+ Commit
		+ Do perf analysis
	+ Points' buffer perf improvement
		! Test perf: allocate (and thus upload) Points' mutable attributes in one single buffer
		+ Changes to Buffer:
			+ Hierarchy with two Buffers:
				+ 1:
					+ static size_t CalculateByteSize(size_t elements)
						+ Also use at UTs
					+ cctor that takes shader_ptr<uint8_t *>, byte offset, et al
					+ No swap(.)
					+ Add UTs
				+ 2:
					+ Like now (makes and owns own buffer)
					+ Yes swap(.)
						+ Add UT
		+ Replace Points' individual buffers with:
			+ 0: ElementContainer(SysSpecifics::make_aligned_float_element_count(.))
				+ Move logic out of ElementContainer
			+ Undo changes to containers
			+ ElementContainer:
				+ See if iterator could be the range iterator
					+ If so, add one for buffer
					+ If so, use the one for buffer @ 2 places in Ship_Interactions.cpp
			+ 1: mMutableAttributesBuffer == unique_aligned_buffer, SysSpecifics::make_unique_aligned_buffer...(byte size)
				+ Calc total byte size via Buffer<T>::CalculateByteSize(size_t elements)
			+ 2: Buffers offseted to three portions, using sums of Buffer::CalculateByteSize(.) for previous
		+ Then do a single upload
		+ Perf: has decreased!
	+ Try interleaving Update's with Render's
		! First, quick and dirty: do at stars, clouds, ocean
		+ GameController:
			+ Nuke Update() and Render()
				+ 1) Update: used by step-by-step
					+ Replace with GC::PulseUpdate()
						+ Sets mIsPulseUpdateSet
						+ RunGameIteration(.) checks it together w/pause, and always clears it
				+ 2) Render: OnPaint
					+ Should not be needed anymore, nuke it
			+ 3) Replace implementation of RunGameIteration(.)
				+ Incorporate (and then nuke) inline the implementations of InternalUpdate and InternalRender
					+ i.e. end up calling World::Update and World::Render directly, one after the other
			+ 4) Test
				+ Normal
				+ Pause, step-by-step
				+ Resize, minimize/maximize, fullscreen/nofullscreen
		+ 5) GameChronometer
			+ using std::steady_clock
			+ Use
		+ World:
			+ Replace Update(...) and Render(...) with
			  UpdateAndRender(..., bool doUpdate, GameChronometer::duration & updateElapsedTime, bool doRender, GameChronometer::duration & renderElapsedTime)
			  + GC passes mTotalUpdateDuration& & friend&
			  + For now as-is
		+ Test
		+ Make status text in millis
		+ Perf improvements:
			+ Start: Default: FPS=30.0, U/R=22.x/10.x, pause:R=21.5; Ball of Iron: FPS=49.0-50.0-55.0F, U/R=5.x/14.x, pause:R=19.9
			+ First: move RenderStart at beginning and see if it's worse
				+ Test on all boxes
					+ Samsung: 90/11
			+ Call World::UpdateAndRender just once
			+ World::UpdateAndRender(.):
				+ Remove doRender arg
				+ Interleave at:
					+ Sky
					+ Ocean
			+ Advanced:
				+ Breakup sky rendering:
					+ Update+Render Stars
					+ Update ...
					+ Render Clouds
	+ Parallelize OpenGL:
		+ Start:
			+ Dell: U:21-23 R:11 (SWP:0.6 SHP:7.7) - 30.9 FPS
			+ Samsung: U:93-94 R:11-12 (SWP:1.1 SHP:3.5) - 9.4 FPS
			+ HP: U:45-46 R:13.4-15 (SWP:1.1 SHP:4.5) - 16.9 FPS
			+ Dario:
				- 2011: U:14 R:7.36 - 45.28 FPS
				- 2015: U:10.95 R:4.50 - 61.23 FPS
				- 2020: U:9.08 R:6.69 - 64 FPS
		+ Spec:
			+ Rendering runs entirely on separate thread
				+ Context & SwapBuffers need to be made current in this thread
		+ Impl:
			+ Branch
			+ 0: Take measurements: UPL=30 R=13
			+ 1: Split whole chain as Update(), RenderUpload(), and RenderDraw()
				+ GameController retains current API: RunGameIteration() // Do same state machine, invoking (optionally) Update() and (always) RenderUpload()
					+ RenderContext::UpdateStart()
						+ Wait for RenderUploadEnd // CPU buffers are then free to be used
					+--- World, etc. Update()
					+ RenderContext::UpdateEnd()
						+ Nop
					+ RenderContext::RenderStart()
						+ Cleanup an eventual pending RenderUploadEnd - may be left behind if this cycle did not
						  do an Update
					+ RenderContext::RenderUploadStart()
						+ Wait for RenderDraw // GPU buffers are then free to be used
					+--- World, etc. RenderUpload()
					+ RenderContext::RenderUploadEnd()
						+ Store TaskCompletionIndicator as RenderUploadEnd
					+ RenderContext::RenderDraw()
						+------------------ Do all rendering, including SwapBuffers
						+ Store TaskCompletionIndicator as RenderDraw
					+ RenderContext::RenderEnd()
						+ Nop
				+ Add time measurements => Extended Status Text
					+ Render stats: split into upload_time (including driving loops) and draw_time
			+ 2: Take measurements UPD=22.3 UPL=0.34 DRW=10.45
			+ 3: Introduce ThreadTask, Re-implement RenderContext partially (1)
				+ Intake ThreadTask
					+ Make unit tests
				+ Temporarily maim World::RenderUpload() and RenderContext::Draw() to do only Stars and Clouds
				+ MainFrame: pass OpenGL context management lambdas down to RenderContext::cctor
					+ MainFrame: no more making context current, & call RebindContext @ second bind
					+ "RebindContext" RenderContext & IGameController methods & param names, taking lambda
						+ Call it from MainFrame
					+ Invoke them @ RenderContext
						+ Figure when to do initial bind, from SpringLab
					+ RebindContext
					+ Test
				+ Implement multi-threaded RenderContext
					+ RenderContext::cttor() (copy from SpringLab)
					+ RenderContext::needed uploads (copy from SpringLab)
						+ Stars
						+ Clouds
						+ Break RenderContext progress into smaller chunks for each progress report
							+ Furhter break textures' initializations
					+ RenderContext::Draw()
					+ ViewModel getters and setters (zoom, camera, ...) (copy from SpringLab)
					+ All sync points from above
					+ Add measurement of 2 wait times
				+ Do TextRenderContext
					+ TextLayer & TextContext:
						+ Split update & render into Update & RenderDraw
						+ TextLayer only touches TextRenderContext::mLines @ TextLayer::Update(), not earlier
							+ @ TextLayer::StatusText: like now, but not touching TextRenderContext::mLines
							+ @ TextLayer::AddEphemeralTextLine: buffer lines
							+ @ TextLayer::Update: collect all dirtinesses/buffered and send them to TextRenderContext::mLines
							+ @ TextRenderContext::RenderDraw: mLines -> VBOs, draw
					+ Redo logic: NotificationLayer + NotificationRenderContext; Update, RenderUpload, RenderDraw
						+ Do
						+ Undo changes for NDC
						+ Make sure vertex buffers are recalc'd immediately upon canvas size change
						+ NotifLayer: separate uploads (& dirtyness) by font
						+ Test:
							+ Canvas resize
							+ Reset during ephemeral lines
					+ Print also 2 wait durations in extended status text
				+ Take measurements: UPL=0.16 DRW=1.60 W(UPL=0.09 DRW=0.09)
				+ Test
					+ Verify exceptions during RenderContext::cctor are rethrown, e.g. shader syntax error
			+ 4: Continue RenderContext Implementation (2)
				+ World::RenderUpload() and RenderContext::Draw(): re-enable OceanSurface and OceanFloor
				+ Redo measurements
					+ Re-check NotificationLayer code and two waits
					+ Do other probed KPI: last update duration
				+ Check numbers, especially for land
				+ Test setters for ViewModel (with "dirty" flag)
				+ Try other strategy for setters (queued and waited), see if stutters
					+ AmbientLight
						+ Also at NotificationRenderContext
			+ Check on other laptops
				+ Verify wait times ~= 0
				+ Check stuttering
			+ 4b: All setters
				+ Nuke GameDispatcher from RenderContext
					+ ToolController::Update: gets effective ambient light intensity from GameController and,
					  if different than mCurrent, acts on it
				+ Improve "dirty flag" strategy
				+ Flat sky color
			+ 5: Continue RenderContext Implementation (3)
				+ Storm
				+ Rain
				+ Lightnings
					! Always uploaded (like clouds), but most of the times empty
				+ Issue with cam moving
				+ WorldBorder
				+ FireExtinguisher, HeatBlasterFlame
					+ Make sure GameController uploads them at RenderUpload() time
				! Upload & Render for all
			+ 6: Continue RenderContext Implementation (4): Ship
				+ Prep:
					+ RenderContext: enable all
						+ AddShip: queued and waited (does OpenGL)
					+ World: enable all
					+ Ship:
						+ No uploads
					+ ShipRenderContext:
						+ No render
					+ UploadShipStart, UploadShipEnd: comment out content
				+ Run APITrace
				+ Ship:
					+ ViewModel strategy: mAreOrthoMatricesDirty/ApplyOrthoMatricesChanges
						+ UploadStart: ViewModel update for max plane ID
						+ SetShipCount
						+ OnViewModelUpdated
					+ UploadPointMutableAttributes: move group1 buffer uploading to beginning of Draw()
					+ UploadPointMutableAttributesEnd: move group2 buffer uploading to beginning of Draw()
					+ UploadPointColors: asynchronous
					+ UploadPointTemperature: asynchronous
					+ Elements
						+ UploadElementsEnd: set dirty flag, and move (conditional) load to beginning of Draw()
							+ See if can avoid allocating buffer: use allocated VBO vertex buffer size
							+ May get rid of "finalizeEphemerals" flag as we upload anyway at beginning of draw,
							  well after ephemerals are (eventually) loaded
				+ GenericMipMappedTextures, AirBubbles
				+ ElementEphemeralPoints
				+ CrossesOfLight
					+ Upload
				+ AMBombImplosion
					+ Upload
						+ Redo quad as with "radius"?
					+ Centralize radius calculation at AMBomb - pass to Ship::PhysicsHandler
					+ Longer pause between pre-implosion and implosion
					+ Debug series of radii produced
					+ Stronger implosion force
					+ Shader
				+ Sparkles
				+ Vectors
					+ VectorColor setter strategy:
						+ mIsVectorArrowColorDirty, but NO Apply...Changes()
						+ Set color param in own Render method, if (mIsVectorArrowColorDirty)
					+ Use different vector colors
					+ See if vectors are reset when we stop uploading
				+ Explosions
				+ Highlights
					+ Re-enable upload
				+ See again issue with cam movement (via mouse pan) & ocean borders
					+ All settings are in new RenderSettings struct, including ViewModel
						+ Each setting that also requires OpenGL updates:
							+ Also has a boolean
							+ Draw(): still checks if individual settings are dirty, and if so, does updates
					+ RenderContext::Draw: copy struct into another member, on main thread
						+ Or, see if can copy in capture, & pass into Draw() lambda
						+ Draw: use second struct recursively down - never reference mRenderSettings
							+ Second struct passed to ShipRenderContext as arg of its Draw()
						+ RenderContext::Draw(params) invokes ProcessSettingChanges(settings) without clearing dirty flags,
						  and later ShipRenderContext::Draw(settings) also invokes its own ProcessSettingChanges(settings)
					+ Effective/AmbientLightIntensity:
						+ RenderContext::SetAmbientLightIntensity & storm update:
							+ mRenderSettings.EffectiveAmbientLightIntensity recalcd immediately, via RenderContext::CalculateEffectiveAmbientLightIntensity,
							  & mRenderSettings.IsEffectiveAmbientLightIntensityDirty=true
				+ Flames
					+ Re-enable upload
					+ mIsWindSpeedMagnitudeAverageDirty, ApplyWindSpeedMagnitudeAverageChanges
						+ Picked up (when dirty) at PrepareRenderFlames(.), together with buffers
						+ Also at Lightnings
					+ Buffers
					+ FlameSizeAdjustment: keep as-is, confirming that it's only used for Ship::UploadFlames()
						+ Setting is in new RenderContext section that has upload-only settings, or settings that
						  are used to calculate RenderParameter values immediately
						+ RenderContext::SetFlameSizeAdjustment(): - store; call all ships' UpdateFlameSizeAdjustment(adj)
						  which calculates those two vals and stores them in the Ship's corresponding section
							+ UpdateFlameSizeAdjustment also called by cctor on raw cctor arg
						+ Move AmbientLightIntensity storage here
					+ "TakeSnapshotAndClear()"
					+ Test: wider flame
				+ StressedSprings
				+ Fix render stats
					+ RenderContext passes a new instance of RenderStats to all of Ship::Draw,
					  and then stores in own member, of type std::atomic
					+ @ Use: get local copy
			+ 6b: All setters
				+ ShipRenderContext setters
					+ FlatLampLightColor
					+ ShowStressedSprings
					+ WaterColor (default color; derivation from ocean rendering settings)
					+ WaterContrast: used at Ship::Render (for params), so member @ RenderParameters w/IsDirty
					+ WaterLevelOfDetail: used at Ship::Render (for params), so member @ RenderParameters w/IsDirty
					+ VectorFieldRenderMode: pure storage, so member @ RenderContext and that's it
					+ VectorLengthAdjustment: only at Update, so member @ RenderContext and used when forwarding Upload to ship (like now)
					+ DrawHeatOverlay
					+ HeatOverlayTransparency
					+ DebugShipRenderMode
				+ RenderContext setters
					+ OceanTransparency
					+ OceanDarkeningRate
					+ All ocean rendering settings (render mode, colors, texture index)
					+ ShowShipThroughOcean (simply in RenderParams, used only by Render)
					= Land parameters & texture index (exactly like ocean, but without WaterColor complication)
			+ 7: Complete RenderContext Implementation (5)
				+ Reset: queued and waited (ShipRenderContext destructor does OpenGL)
				+ Screenshot: queued and waited, like SpringLab
				+ Destructor:
					+ Make sure thread member is first, so its destructor gets called first
					  waiting for pending operations
					+ Split off WorldRenderContext
							! RenderContext owns ShaderManager and WorldRenderContext and Ships and NotificationContext
							! WorldRenderContext has ShaderManager reference like Ship, and copies own
							  texture metadata (passed on by RenderContext via cctor)
							! WorldRenderContext exposes detailed init and upload and draw methods
						+ Initialization:
							+ Textures:
								+ Those textures that are exclusively for the world get moved
								  to WorldRenderContext (Clouds, world)
							+ RenderContext::cctor:
								+ Invoke both own and WorldRenderContext's initializations
							+ Make sure ambient light intensity gets calculated
							+ Make sure world border gets calculated
								+ Via WorldRenderContext::ProcessParameterChanges
							+ WorldRenderContext cctor also gets reference - and does own init'n - to:
								+ Generic textures
								+ mUploadedNoiseTexturesManager (like NotificationRenderContext below) for
								  setting noise textures as needed
						+ Hook all Upload() calls
						+ Hook all Render calls
						+ RenderContext::ApplyParamChanges:
							+ maintain those that affect two tools and generals
							+ invoke child contexts'
							+ Make sure world border gets calculated
								+ Via WorldRenderContext::ProcessParameterChanges
					+ Split off GlobalRenderContext for 2 generic textures, for explosion textures, for noise textures
						+ Pass then to child contexts as needed
					+ Move out 2 tools to NotificationRenderContext
						+ And do ProcessParameterChanges(.) on it
							+ And thus get rid of RenderContext::ApplyEffectiveAmbientLightIntensityChanges
						+ And have own initialization method, invoked after RenderContext::InitializeGenericTextures,
						  that does own part of RenderContext::InitializeGenericTextures, which takes
						  mUploadedNoiseTexturesManager for setting noise textures as needed
					+ Do correct destroy sequence
			+ Tests:
				+ Number of stars changes
				+ Number of clouds changes
				+ Debug ship render mode
			+ Perf on other laptops:
				+ Samsung:
					- FPS: 10.5
					- UPD: 94.7 (W=0.00) UPL: (W=0.01 + 0.32)
					- RND: 3.07 (3.10) (MT=0.01)
				+ HP:
					- FPS: 20.7
					- UPD: 47.3 (W=0.01) UPL: (W=0.00 + 0.24)
					- RND: 4.00 (3.84) (MT=0.04)
				+ Dario:
					- 2011: U:14 R:7.36 - 45.28 FPS	=> U:14.86 R:25.25 - 39.32 FPS
					- 2015: U:10.95 R:4.50 - 61.23 FPS => U:9.57 R:5.75 - 64.08 FPS
					- 2020: U:9.08 R:6.69 - 64 FPS => U:8.46 R:4.82 - 62 FPS
			+ Cleanup:
				+ Move uploading of 2 tools @ GameController from RenderContext to NotifLayer
				+ GameController: see if we need to do render control smoothing before RenderUpload() (i.e. whether
				  anything at Upload() needs current ViewModel params), or if instead it's enough to do that before RenderDraw()
				+ Remove PerfStats' obsolete members
				+ Test with OpenGL uploads all up-front
					+ Perf before:
						- UPL: W=0.0-0.5 + 0.16
						- RND: 16.6-22.6 (MT=5 / 3.77-8.33)
					+ New perf stat: portion of Render that is purely upload
						+ Display
					+ Perf after:
						- UPL: W=0.0-0.5 + 0.16
						- RND: 13.4-22.6 (MT=10 / 5.77-8.33)
				+ Run debug
				+ Do APITrace, including shutdown
					+ Reduce calls
						+ Start: 97, 101 when status text updated
						+ Move out glPolygonMode
							+ Use RenderParameters::IsDebugSgipRenderModeDirty
								+ Setter @ RenderContext, never give to Ship
								+ Process @ render
							+ Test
						+ if all glBindVertexBuffer always end with zero, do once at end of Prepare
						+ If all glBindVertexArray always end with zero, do once at end of Draw
						+ Better rain parameter setting
							+ Test rain
						+ @ ShipRenderContext::RenderDrawFlames: VBO bind is not needed
							+ Test flames & wind
					+ Check shutdown
				+ Test:
					+ Screenshot-taking (w/Storm & lightnings)
					+ World border
					+ Stressed springs
				+ Do NotificationRenderContext::UltraViolentModeIndicator
					+ In generic non-mipmapped atlas, with atlas passed by RenderContext to NotificationRenderContext
					+ NotifRenderContext has vector of notification textures vertices
					+ Redo icon with better spacing between U and bliksem
					+ Test ambient light darkening
				+ TaskThread optimization for single-core boxes
					+ Verify no overhead anymore
			+ changes.txt
	X See timeBeginPeriod() for vSync

+ Dynamics
	+ Try half of the relaxation iterations
		+ Might need to adjust stiffness
	+ Adjust springs stiffness
		+ Test other values:
			+ 0.1 => should break faster : YES
			+ 1.7: explodes
		+ Test with same strain also for compression
			+ And force at 0.0058
		+ Test with slightly higher stiffness - see if less bending but same breaking
	+ Realistification:
		+ Ship::Damp: damping 3 times at end should have the same effect
		+ Exploding ship:
			+ Check if higher damp factor helps: was 0.5, now 0.8
		+ Spring equilibrium:
			+ Find right overshooting factor (may be slightly smaller)
			+ Compare behavior with old game
				+ Steel Ball and broken default ship in old game: explodes? yes
	+ Test completely force-driven dynamics:
		+ Create branch
		+ Each iteration (test initially with 1 iteration per step; then see with more, but scale dt)
			+ Apply forces:
				+ For each spring:
					+ Spring force (Stooke's law - need k, try fixed at first)
					+ Damping (try along spring first - like now)
					+ see https://www.scss.tcd.ie/Michael.Manzke/CS7057/cs7057-1516-14-MassSpringSystems-mm.pdf for equations
			+ For each point:
				+ Gravity (with buoyance)
				+ Drag
			+ Apply verlet integration
			+ Zero force
			+ ...do tension strain check...
			+ ...electrical and water...
		+ Improve:
			+ Masses
			+ Gamma - from original (NOT from original, doesn't work)
			+ Better grab force:
				+ Have optional<float force, vec2f position>; at each iteration, if not none:
					- Do force spreading with force/NumIterations
				+ Also, all non-static GameParameters initialized at cctor in cpp
				+ Check ropes afterwards
			+ Collision with sea floor and (original) "bounce"
				+ v += adjusted Pos - pre-adjusted Pos
				+ Double-check new V
			+ Make SimulationStep a templated constant (double and float)
			+ Clean up code
		+ Perf:
			+ Get baseline:
				+ FPS: 15.8
				+ GameController::DoStep: 44.98%
					- UpdateDynamics: 32.96%
						- UpdateSpringForces: 15.33%
						- UpdatePointForces: 8.51%
							- GetWaterHeight: 5.24%
							- fminf: 1.23%
						- SeaFloorCollisions: 5.40%
							- GetOceanFloorHeight: 3.69%
						- Integrate: 3.71%
					- BalancePressure: 5.70%
					- GravitateWater: 4.30%
				+ MainFrame::Render: 46.67%
			+ Do constants
				+ FPS: 16.15
			+ Do Spring.XYZFactor/s
				+ See if can get rid of dt parameter in funcs
				+ FPS: 16.25
			+ Do Point.MassFactor
				+ const calc'd at cctor via GameParameters::dt and GameParameters::numIterations
				+ See if can get rid of dt parameter in funcs
				+ FPS: 16.50
			+ Do cached WaterHeight and ocean floor height
				+ Also useful for LeakWater()
				+ If period chosen wisely (< expected ship world width), saves on calculations
				+ Physics::WaterSurface class, only visible by World, which exposes own getters
					+ cctor(): allocate buffer
					+ Update(currentTime, gameParameters): populate buffer
					+ GetWaterHeight(x):
						+ Convert x to absolute sample index, via dx and taking floor
						+ Interpolate height between asi%buffer_size and (asi+1)%buffer_size
				+ At end:
					+ Remove gameParameters from World::GetWaterHeight and cleanup World.h
				+ Optimize
			+ Get baseline:
				+ FPS: 17.0/17.2
				+ GameController::DoStep: 41.85%
					- UpdateDynamics: 28.10%
						- UpdateSpringForces: 13.90%
						- UpdatePointForces: 5.87%
						- HandleCollisionsWithSeaFloor: 4.27%
						- Integrate: 4.24%
					- BalancePressure: 6.47%
					- GravitateWater: 4.88%
					- LeakWater: 0.22%
				+ MainFrame::Render: 48.99%
			+ Test fma in Integrate()
				+ check assembly: REJECTED, it's function call!
			+ UpdateSpringForces:
				+ Don't check for IsDeleted, but just set coeff's to zero for deleted springs
				+ FPS: 17.4/17.5
			+ Spring::WaterPermeability
				+ Set to 0.0 if hull spring or deleted, else 1.0f
					+ Set at cctor
					+ Set to 0.0 at Destroy() ("...avoid draining water to destroyed points...")
				+ Remove two if's at BalancePressure and GravitateWater
				+ FPS: 17.3/17.5
	+ Set springs' K in material
		+ Multiplies with C (0.8) in Spring::CalculateStiffnessCoefficient()
		+ Fix Titanic masts
			+ See if need to increase iterations
			+ Testing wood: 1.10 to 1.15
		+ Fix ropes (they don't move as fluid and continuous as before)
			+ Test with own K for ropes (start with half K)
		+ Change exponential of StrengthAdjustment, for expanded small values
			+ 0.001+((exp(x/70)-1)/2.3)^3.4
			+ Verify inverted formula
			+ finalize default StrengthAdjustment: 0.03421?
	+ Pin points
		+ Point::TogglePin():
			+ If pinning: set MassFactor to zero, and set velocity to zero
			+ If unpinning: recalc MassFactor (using same helper used at cctor)
		+ The entire search is implemented by Points
			+ Together with isPinned (used at search to avoid pinning pinned point), also maintains
			  stack of pinned point indices
				+ Toggle: find topmost point in stack merely within radius; if found -> toggle it & remove from stack
				  & mark as dirty for re-upload and return true;
				  + else: find closest non-pinned point;
					+ if found: toggle it & add to stack & mark as dirty for re-upload & return true
					+ else: return false
				+ Destroy: also remove from stack, if there
					+ And if there, mark as dirty for re-upload
		+ Given that connected component changes affect rendering of pinned points:
			+ Move stack and mArePinnedPointsDirty back into ship, together with search logic
				+ Points gets back Pin() and Unpin()
				+ Ship::Destroy as well
			+ Pinned points are uploaded by decision of Ship
				+ Decision: if mAreElementsDirty || mArePinnedPointsDirty
				+ Ship does start & end & points
		+ ShipRenderContext: draw pinned points using texture (centered)
			+ Ship uploads coordinates and ConnectedComponentID of point
			+ ShipRenderContext: behave exactly as with StressedSprings (i.e. reset at ElementsStart()), as
			  we're sure we'll re-upload pinned points when elements are dirty
				+ Rename as "Elements"
				+ Do with buffer
				+ Calc bounding box, centered over point, like clouds
			+ Render(): draw at very end of each connected component render, after stressed springs
			+ Redo cursor and move to \textures
		+ Tool just toggles:
			+ Ship checks if exists pinned point in radius: if yes, unpin; else, pin
			+ Returns true if points belongs to ship, so to stop search by World
			+ Cursor is a pin
		+ ShipRenderContext::UploadPinnedPoint(): do pinned point insertion at end of own connected component
		+ Texture:
			+ lighter
			+ plug hole
		+ Fix crash when loading Titanic
		+ Max 64 pins
			+ CircularList
				+ Add() is templated on OnRemoved() handler
					+ When over, older are removed
				+ Unit tests
			+ Constant at GameParameters
		+ Spring deletion at stress: also unpin endpoint if the endpoint has no more springs attached to it
			+ Requires global destroy handler above
			+ Do at Ship::SpringDestroyHandler
		+ SoundController reacts to IGameHandler event (true/false) with two sounds (Pin/Unpin)
			+ Random choices, Over/Underwater - NO material
				+ Update sink event
			+ Do sounds:
				+ 4 pin
				+ 4 pin underwater
				+ 4 unpin
				+ 4 unpin underwater
	+ Find sweet spot of stiffness and strength between bending and more strength for pinning
		+ stiff: 0.500750
		+ strength: 0.006200
			    0.005376
		+ pinning: fine (can't pin when it's very fast)
		+ wood: 2.0 (titanic masts like before)
		+ new titanic structure
	+ Cosmetics:
		+ Explain Spring's coefficients (in terms of fractionXYZ* of return-to-rest-length, etc.)
		+ Rename Points::MassFactor as IntegrationFactor and explain
	+ Is Verlet implemented right?
	+ Review parallel calculation, it suffers from races
		+ Also See if can continue queueing tasks without waiting for all blocks of chunks
	+ Bombs:
		+ Spec:
			+ Placed and removed with similar tool as Point Pinning
			+ Two types of bombs: timer and remote controlled
			+ A bomb explodes when:
				+ Its timer times out or the remote control is triggered
				+ The point it's attached to is destroyed
				+ A point or spring in the "neighborhood" (a separate, small radius) is destroyed (includes nearby explosion)
			+ When one or more bombs are detonated, ship needs to know only position, connected component ID, and blast radius,
			  not even point index
				+ Thus (exploded) bombs are independent from lifetime of point that they were attached to,
				  allowing ship to destroy point immediately at first step of detonation, for example
				  if we have multiple-step detonations
				+ By not using point index we allow explosions to affect multiple connected components (of same ship though)
			+ Bomb decides for itself when it's to be deleted, and Bombs consequently removes it from
			  collection (and from point indirectly via Bomb::Destroy which, if attached to point, calls Points::Detach)

		+ Impl:
			+ Final test
			+ TEST: bombs are attached to springs instead of points
				+ Move isAttached buffer from Points to Springs
				+ Move mass trick to springs
				+ Bomb position becomes positionA and positionB (bomb attached across)
					+ Also BlastHandler argument is positionA and positionB
					+ Blast calculated's by ship from middle point
				+ inline Springs::GetPointA/BPosition(Points const &)
				+ Points::SetMassToMaterial(float ~offset)
				+ Restructure positionA and positionB:
					+ Freeze position and rotation offset, not positionA and positionB
				+ Fix calculation of alpha - check just zero
			+ TEST: lead-in: continuate ping counter, just different velocity and different translation to frame index
			+ TEST: 360 rotation
			+ Fix mass augmentation
				+ Also update springs' coefficients
			+ Fix blast flipping
			+ TEST: run in debug
			+ FIX: first blast handler is so small that it doesn't find point in radius
				+ Go linearly from 0.6 to BlastRadius
				+ At end, re-enable texture frame for explosions
			+ FIX: ContinuousSound start while paused issue
				+ DesiredState
			+ FIX: TimerBomb x,y offsets
				+ Restore cursor hotspot
				+ Add temporarily fixed world offset at ShipRenderContext
					+ Desired center: 147, 228 off 300, 300 => +3, -78 over 12.0, 12.0 makes 0.12, -3.12

			+ Bomb base class, w/type enum
				+ Update(OnBombExplosionStep(position, radius)) -> bool = 0:
					+ Runs state machine with local clock
						+ Advances animations (textures of bombs, sounds via events)
					+ Invokes handler for each explosion step
					+ Returns false when needs to be deleted
				+ GetRenderFrameIndex() -> size_t
					+ Specialized for state machines
				+ NeighborhoodDisturbed() = 0
					+ Invoked when needs to explode because own or near point is disturbed
			+ Two subclasses - TimerBomb and RCBomb
				+ RCBomb:
					+ RCBomb::Detonate(): input to state machine
					+ Update():
						+ Basics
						+ Explosion
					+ Finalize GetArea(): decide if new enlarged explosion looks good
					+ NeighborhoodDisturbed()
						+ Equivalent to RCDetonate()
				+ TimerBomb:
					+ Update(): state machine
						+ Sparkles: sort frames by distance on fuse and do random choice on sliding window
						+ Add a base frame of bomb with no fuse
							+ Rename all frames
							+ Fix calculation of base frame count at Update()
						+ Smoke:
							+ 3 sequential frames
					+ NeighborhoodDisturbed()
						+ Explodes only if state machine duration < own time left
			+ Bombs class
				+ Not ElementContainer, just manager
				+ cctor takes shared_ptr<IGameEventHandler>, ExplosionHandler, Points &
				+ Update(OnBombExplosion(position, radius)) -> void
					+ Runs through all bombs and invokes ::Update() on each
					+ Removes a bomb if its Update() returns false
						+ Detach it if attached
				+ ToggleTimer/RCBombAt(position)
					+ same logic as pinned points
					+ returns boolean
				+ DetonateRCBombs()
					+ Calls Detonate() at each RCBomb
				+ Upload(RenderContext)
					+ Always upload all bombs, each w/current render frame index
				+ OnPointDestroyed(idx)
					+ For each bomb:
						+ If bomb is attached to this point:
							+ Detach bomb from point
						+ If bomb within (new, smaller) radius from point:
							+ Call bomb->NeighborhoodDisturbed()
				+ OnSpringDestroyed(idx)
					+ Bombs also takes Springs
					+ For each bomb:
						+ If bomb within radius (new GameParameters parameter, smaller) from spring mid-point:
							+ Call bomb->NeighborhoodDisturbed()

			+ Points also has bool HasBombAttached buffer for interactions & lookups, just like pinned points
				+ Also changes mass (just at point, for gravity only...)
				+ Flag and mass change is done at Points::AttachBomb()/Points::DetachBomb()

			+ Events:
				+ OnRCBombPlaced/Removed(size, underwater): used by MainFrame to enable/disable detonation menu item
					+ Also invoked when explodes
				+ OnTimerBombPlaced/Removed(size, underwater): used by SoundController to start/stop and set volume
				  of timer bomb sound
					+ Also invoked when explodes
				+ OnBombDetonated(size): used by SoundController
				+ OnRCBombPing(size): used by SoundController

			+ Ship implements:
				+ ToggleTimer/RCBombAt(position)
					+ FW to Bombs
				+ DetonateRCBombs()
					+ FW to Bombs
				+ @Update(): invokes Bombs::Update() w/handler
					+ After spring stress check, so explosion is visible before it breaks things up
				+ @Render(): invokes Bombs::Upload(RenderContext)
				+ Ship::PointDestroyHandler:
					+ Bombs::OnPointDestroyed(idx)
				+ Ship::SpringDestroyHandler:
					+ Bombs::OnSpringDestroyed(idx)

			+ RenderContext:
				+ RenderContext:
					+ Load textures
						+ RC bomb
						+ Timer bomb
						+ Make sure textures are sorted by index
							+ First index for multi-frame is 0 in filename as well
					+ Forward calls
				+ ShipRenderContext
					+ Buffers just like pinned points
					+ Render
			+ MainFrame/Tool:
				+ Register for events and process OnRCBombPlaced/Removed() to enable
				  Detonate menu item
				+ Load 2 cursors
					+ Set hotspot
			+ SoundController:
				+ Event handlers

			+ Media:
				+ TimerBomb cursor
				+ RCBomb cursor
				+ TimerBomb textures:
					+ Bases w/different fuse lengths
						+ With fuse burning, separate unlighted frames
					+ Explosion frames
				+ RCBomb textures:
					+ Base
					+ Pings
					+ Center
					+ Explosion frames
				+ Bomb explosion sounds
					+ N1 normal, N2 underwater
				+ RCBomb ping sounds
					+ 1 normal, 1 underwater
				+ TimerBomb fuse sound
					+ 1 fast, 1 slow
				+ Timerbomb defused sound ("sizzle")
				+ Bomb placed sounds
					+ N1 normal, N2 underwater
				+ Bomb removed sounds
					+ N1 normal, N2 underwater

		+ Bomb explosions: see if better done with force fields
			+ At each explosion frame: radial forces, centered at center, strongest at radius=f(expl frame)

		+ 3rd type of bomb: anti-matter bomb
			+ [Do after texture json]
			+ When it explodes: first sucks everything in, then evertyhing out
				+ Controllable also via ultra-violent mode
				+ Uses "ForceFields" (rename of "ToolForces": applied at each iteration of UpdateMechanicalDynamics and then cleared)
				  for suck-in
					+ ForceFields.cpp/h
					+ Move swirl, grab, bomb explosion to this one
			+ Requires ExplosionType argument at Ship::BlastHandler, or new BlastHandler altogether
				+ Or see if easy to move BombBlaster inside bomb (i.e. explosion code is in bomb's state machine)
				+ Or another way
			+ Plan:
				+ Media:
					+ Sound: continuous (3 choir tones)
					+ Sound: implosion_one (FM)
					+ Sound: implosion_two (whirring, up)
					+ Sound: explosion
						+ Choir with delayed repetitions
						+ First choir is mixed with electronic thud
						+ More emphasys on initial explosion
						+ Redo eventually, with long LFO
					+ Texture: armor
						+ Diagonal arms as well?
					+ Texture: ball, empty
					+ Texture: ball, cloud content
					+ Cursor
				+ Texture DB:
					+ Textures.js
					+ New groups in enum
				+ Sound controller:
					+ New additive continuous sound (like fuse) with random choices and volumes for each
					+ Others
				+ Bomb::IPhysicsHandler
					+ Implemented by Ship
					+ Passed to Bombs and stored as GameEventHandler (i.e. *)
					+ Test 2 old bombs
					+ Create force fields
				+ ForceFields
					+ Move DrawTo and Swirl
						+ Test
						+ Clear ToolForce's
					+ Commit
					+ PreImplosion
					+ Implosion
						+ Trim sound and shorten state machine interval to match
						+ Test coriolis - angular F depending on V of point
						+ Test with angular F being stronger when closer to center
						+ Test with mass-independent accelerations (divide forces by mass)
						+ Test with progress moving along 1/(x-a)
						+ Multiplier for ultra-violent mode
						+ Cleanup force field
					+ Explosion
						+ Add to centrifugal

			+ Lower volume of all breaking/stress (passive) sounds
				+ class GameSound : sf::Sound
					+ setVolume
					+ setMasterVolume
					+ setMuted
						+ each sets volume immediately, no checks
					+ Test:
						+ master volume changes only affects currently-playing category
						+ master volume changes affect future sounds
						+ play farewell sound affects currently playing
						+ play farewell sound affects future music
				+ Find another version of volume sum
				+ Then test again break and stress sounds for volumne
				+ Need to mark CurrentlyPlayingSounds as expendable or not

			+ Animation:
				+ Cloud rotation slows down during pre-implosion, down to a halt
				+ Then starts slowly again from the other way around, with v=square of progress
				+ Cross of light
			+ Misc:
				+ Can get rid of deletion checks in force fields?
				+ Test fuse's (slow and fast) sounds for new ContinuousSound architecture
				+ Prevent removal if not in containment (i.e. if detonated already)
					+ Bomb::MayBeRemoved()
					+ Test with all 3
	+ Swirl tool
		+ Force applied is r * AngularForce; AngularForce==m*AngularAcceleration
			+ CW; if Shift -> CCW
		+ Cursors
		+ Need own sound - replicate Draw infrastructure and use different drill
	+ Fix power bar room at all cursors
		+ Try: MakeCursors: make non-transparent pixels green or red, multiplying
	+ Saw
		+ Spec:
			+ Deletes springs (and affected triangles) that cross the *path* of the tool
			+ Continuous sound, overwater and underwater, depending on where x,y is
		+ Impl:
			+ Media:
				+ Cursor up and down
				+ Sound
			+ Events:
				+ Need boolean true/false for sawing
			+ Tool:
				+ L-Down:
					+ prevMousePos = mouse X, Y
					+ Fire event (asking GameController for game event handler)
					+ Set new cursor
				+ L-Up:
					+ Reset prevMousePos
					+ Fire event (asking GameController for game event handler)
					+ Set new cursor
				+ Move: if l-down:
					+ if has prevMousePos:
						+ GameController->Saw(prevMousePos, current)
					+ prevMousePos = current
			+ Ship:
				+ Do EnumFlags class in EnumFlags.h
					+ Use it 2 X in Springs
				+ Make sure Spring::Destroy only deletes triangles that share one edge with the spring
					= Nuke Point::Breach and do everything instead in Ship's destroy handler, driven off
					  Springs::DestroyOptions
				+ Test whether should fire the Break event even if only springs are deleted
					+ For points we fire the event in the ship's PointDestroyHandler; if we
					  want to fire now from ship's SpringDestroyHandler, we must be told whether
					  the spring destruction comes from a point destruction or not: FromPointDestroy vs FromSpringDestroy
					  + If we do this, we can now also remove firing of break from within Springs::UpdateStrains,
					    as the ship's SpringDestroyHandler would be invoked with FromSpringDestroy
				+ Use Geometry::Segment::TestIntersect()
					+ Also add to it GetAngle...
						+ Move from Texture Rotation
					+ Move also AABB to Geometry
			+ SoundController: new continuous sound
				+ Also underwater
	+ Ultra-violent flag: very strong Draw and Swirl forces
	+ Buoyancy redesign:
		+ test with hack what would happen if all non-hull materials were 1/nth of the mass
		+ python script: allow empty cells (skip cols if != index)
			+ Make template more compact
		+ Regenerate template
		+ Re-check bomb weight
		+ Regenerate template
		+ If ok:
			+ Before unhack: fix ships:
				+ Do Masts and investigate mass effect on breakage
				+ Fix Titanic:
					+ Lighter rudder
					+ Also generally Lighter?
					+ Stronger under funnels (make tin stronger?)
					+ Make it break
						+ Study tension based off mass
							+ Solve integral manually
							+ Do tests
						+ Softer again under funnels
					+ Fix mast
					+ Glass breaks immediately
				+ Fix Base III: make it float
					+ Larger base, boat-shaped
					+ See if it's cooler if it floats more (another floating level)
					+ See with thicker columns (make a new one and call it Base II)
				+ Fix default ship: just lighter
				+ Fix cargo ship
					+ Y offset
				+ Fix Carnival - lighter
				+ Fix Krafting - no sudden stress
			+ Rewrite buoyancy code - use WaterMass
			+ Change materials
				+ No Mass but object with:
					+ nominalMass
					+ density
				+ Springs: get mass from points, not from material
				+ Add density = [copy from current hack] 1/6th for hull, 1/(6*10or4)
				+ Material loading: just store mass*density at mass
			+ Redo Materials Template
			+ Watch out for strength: it was (/ mass * 1000)
			+ Fix strength adjust
				+ Fix max, min
					+ Rethink exponential slider: takes also midpoint (1.0 for us) and then it's two exp curves
		+ Add to change list
	+ Fix buoyancy
		+ Maintain trick with which hull points don't feel buoyancy (or else wood hull would never sink)
		+ Adjust gravity force though
		+ See perf (orig was 3.36%)
		+ Cleanup old
		+ Commit
	+ Make collisions with sea floor more dramatic
		+ Bounce velocity with specular vector
	+ Ephemeral Particles:
		+ Spec:
			+ Carve out fixed-size room at tail of Points for ephemeral particles
				+ Each has own lifetime
			+ Ephemeral particles cannot be deleted
			+ Rendering: via:
				+ ShipRenderContext::UploadEphemeralParticlePoints (e.g. for points)
					+ Just indexes
					+ Color/alpha portion of buffer has to be uploaded first
				+ ShipRenderContext::UploadGenericTexture (e.g. for bubbles)
					+ Need to also support alphaTransparency
			+ Ephemeral particles are drawn with own color, including alpha going to transparent as lifetime increases
				+ Test first perf impact of using vec4f for point colors
					+ If sucks a lot, will need new extra buffer just for points' alpha
						+ Also this buffer is segmented
				+ Ephemeral portion of entire points color buffer needs to be reloaded at each Upload()
				  or UploadEphemeralParticles() (2*)
					+ Use glSubBufferData
					+ If we go for separate alpha buffer: also do for ephemeral portion of alpha buffer
		+ Impl:
			+ Test vec4f for colors
				+ Points
				+ ShipBuilder
				+ RenderContext/ShipRenderContext
				+ Shaders
			+ Set max eph particles to 1024
			+ Points allocs extra room
				+ Also stores ship point count and start index
			+ Points has new buffers:
				+ EphemeralType (uint8 enum)
					+ None (set at non-ephemeral and at dead ephemerals)
					+ Debris
					+ Sparkle
					+ AirBubble
					+ Smoke
				+ EphemeralStartTime (clock point)
				+ EphemeralMaxLifetime (std::chrono::milliseconds)
				+ private:
					+ EphemeralState: union of public structs (much like ElectricalElements::ElementState)
						+ Debris: {}
						+ Sparkle: {}
						+ AirBubble: {}
						+ Smoke: {}
					+ Buffer<EphemeralState> mEphemeralStateBuffer;

			+ Ship: limit point range:
				+ @ destroy tool, @ bombs explosions, and @ anything else that destroys point: do not destroy ephemeral points
				+ @ toggle bombs: do not attach to ephemeral points
				+ For all of these: use Points::NonEphemeralPoints iterator, or check EphemeralType != None, depending on the case

			+ Points::CreateEphemeralParticleDebris:
				+ Args:
					+ Position, Velocity
					+ MaxLifetime
					+ Material *
						+ Requires MaterialDatabase to be handy at invoker of CreateEphemeralParticleDebris
							+ Ship must take a DB by value at cctor
						+ Though Debris uses spring's material
				+ Impl:
					+ Find first expired particle; if not found, pick the oldest
						+ Requires mFreeEphemeralParticleSearchStartIndex
						+ In private ElementIndex FindFreeEphemeralParticle()
							+ sets mFreeEphemeralParticleSearchStartIndex
					+ Store Color, Position, Velocity
					+ Store Mass
					+ Do any other initializations that we do at Points::Add(...)
					+ Store MaxLifetime, and zero lifetime
					+ Set mAreEphemeralParticlesDirty = true

			+ Points::UpdateEphemeralParticles(clockNow):
				+ For each point, check lifetime vs max lifetime
				+ If time has expired (now):
					+ No need to mark as deleted to hide them, EphemeralType==None suffices to prevent them from being rendered
					+ Reset velocity and integration factor of expired particles to avoid drifting
						+ Rename Points::Pin/Unpin() to Freeze/Thaw()
					+ Set EphemeralType to None
					+ Set mAreEphemeralParticlesDirty = true
				+ Else: do per-type state machine, with dispatch coded in method depending on type, invoking
				  per-type state machine method; for example:
					+ Those that are points:
						+ Calc remaining life
						+ Update alpha either in (portion of) color buffer or in (portion of) alpha buffer
					+ Those that are textures:
						+ Calc remaining life

			+ Points::UploadEphemeralParticles():
				+ 1) Upload portion of color buffer/alpha buffer specific to ephemeral particles
				+ 2) If mAreEphemeralParticlesDirty:
					+ RenderContext::EphemeralPointUploadStart()
				+ 3) For all ephemeral points with EphemeralType != None: use dispatch coded in method depending on type, invoking
				     per-type upload method; for example:
					+ Those that are points:
						+ Add point index to a buffer
					+ Those that are textures:
						+ Call directly ShipRenderContext::UploadGenericTexture(...)
				+ 4) If mAreEphemeralParticlesDirty:
					+ RenderContext::EphemeralPointUploadEnd()
					+ Set mAreEphemeralParticlesDirty = false

			+ Ship::UpdateEphemeralParticles(clockNow):
				+ Calls Points::UpdateEphemeralParticles(clockNow)
				+ Emits ephemeral particles from emitters (e.g. smoke)
					+ For now empty
		+ Cleanup:
			+ See if can control debris generation via GameParameters, which must be made available at
			  Ship::SpringDestroyHandler
		+ Tests:
			+ Pin ephemeral particle
			+ Many connected components
	+ Do debris each time a spring breaks
		+ Look'n'feel:
			+ Points of the color of the spring's material
				+ Actually, points of the spring's material
		+ At Ship::SpringDestroyHandler()
			+ Choose 0, 1, or 2 debris // Experiment
			+ For each:
				+ Material = spring's material
				+ Position = midpoint of spring
				+ Velocity = point on circle as:
					+ Radius: random in [1, 5] // Experiment
					+ Angle: random in [0, 2PI]
				+ MaxLifetime = from GameParameters static const, plus random factor in [0.5-1.0]
		+ Debris:
			+ Update:
				+ Update color's alpha based off remaining lifetime, linear
			+ Upload:
				+ Just store index in buffer

		+ Test look'n'feel and finalize constants
	+ Ocean depth bitmaps
		+ OceanFloor cctor takes ResourceLoader
		+ ResourceLoader used by ocean floor to load image
		+ OceanFloor translates image into float[] with raw pixel y's
		+ At update, raw pixel y's are normalized/enhanced with new GameParameters constant
		+ Test
	+ Slider for "simulation quality", affecting num of mechanical simulation iterations
		+ Update GameParameters - Points and Springs might have to recalc things on changes
			+ Ship
			+ Points
			+ Springs
		+ Fix: invoke points.updategameparams
		+ SettingsDialog: under mechanics tab
		+ Requires extended status text w/measurements
		+ See what to do with stiffness setting: max 1.0f? Leave it
	+ Fix ephemeral particles
		+ Pass also "now" all over the place
			+ End put back UpdateEphemeralParticles where it was
		+ Just single vector of PointIndex, no connected components
		+ Make ephemeral particles' update based on simulation clock, not wall clock
			+ "now" passed everywhere really has to become a "simulationNow" float
		+ Test
		+ Finalize constants
	+ Do chainsaw sparkles with Ephemeral Particles
		+ At Ship::Chainsaw for each broken spring
		+ Initial particle dynamics:
			+ Position: midpoint of spring
			+ Velocity: radial vector:
				+ Butterfly perpendicular to *direction of sawing*, not spring
				+ Magnitude: uniformly random in range
			+ Number: per Update step: uniform random centered around SparkleDensity (ratio over 10, initially) (from GameParameters, adjustable)
			+ Color:
				+ Metal: brightest red to bright red
				+ Else: base material's render color
			+ Finalize parameters
			+ Final test
	+ Add cloth material
		+ Test, basically rope-like but no rope
			+ Low stiffness, hight strength
		+ If fine:
			+ Make it for all basic colors
			+ Structural Template:
				+ Cloth and Rope on same row
				- Redo
			+ Cloth sound
			+ Make ship with Dutch and Italian flags
	+ Buoyancy rearc
		+ Double-fix for rope/buoyancy/hull unhack and fast-falling wet rope/cloth
		+ First of all, test with Integrate taking into account max(water, 1.0) for mass
			+ At integrate
			+ At spring relaxation, for spring masses
				+ NOPE: here it hurts; wet springs really don't break at all
			+ Check reality-ness
				+ Problem: ship sinks very slowly
					+ Due to: mp>>Mw: v=g*dt; mp<<Mw: v=0
		+ Introduce volumetric fill: fraction of 1m3 that is filled by material
			+ Also: fraction of 1m3 that may be filled with water
			+ Also: volume of displaced water
			+ Default: 1.0
			+ Explicitly set to low value at:
				+ Rope, Cloth
				+ All Hull's (zero)
			+ Remove Points::Buoyancy
			+ Use volumetric fill at:
				+ UpdatePointForces()
				+ Integrate() (temporarily - becomes IntegrationFactor again, but re-calc'd explicitly at each step)

		+ Reintroduce water absorption
			+ High absorption at ropes and cloth
			+ Points buffer
			+ Use it at UpdateWaterIntake

		+ Test look'n'feel
			+ Test for less bouncy crashes: springs using wet mass, again
				+ No, worse
			+ Existing ships
				+ Pay attention to crashes onto sea floor
			+ Rope
				+ WaterRestitution
				+ Fast-falling-when-wet bug
				+ Buoyancy/sinking
			+ Cloth
				+ WaterRestitution
				+ Fast-falling-when-wet bug
				+ Buoyancy/sinking

		+ Now, optimize:
			+ Points::UpdateTotalMass(): calculates:
				+ (New) IntegrationFactor (vec2)
				+ TotalMass (for UpdatePointForces())
			+ Invoke at Ship::UpdateMechanicalDynamics before all
			+ Then, undo changes at Integrate()
			+ Then, use new quantities at UpdatePointForces()
			+ Test:
				+ Changes to Simulation Quality are picked up
				+ Bombs' extra mass

		+ Cleanup TODO's at Ship (SpringForces attempt)
		+ Points::UploadForceBuffer: decide length
		+ Update materials.md docs with new properties, including water
		+ Update ShipAnalyzer for correct buoyancy-adjusted mass
	+ Improve light diffusion
		+ Use real distance
		+ No more non-linear behavior

	+ Add "Low-Dimmed Lights" and "Medium-", and "Portholes"
		+ New Electrical Property of Lamp ("Luminescence") at ElectricalMaterial
		+ New Lamp property at ElectricalElements
			+ Consumed by DiffuseLight
		+ Use at Queen of Unova
	+ Wind and cloth
		+ Step 1: Points has WindReceptivity buffer, for now set at Add(.) to 1.0 if material is one of cloth
		+ UpdatePointForces:
			+ Add wind force vector to overwater points, multiplied by WindReceptivity
				+ From mParentWorld.GetCurrentWindForce()
					+ Step 1: GameParameters.WindDirection * GameParameters.WindSpeed
					+ Will become erratic later on
		+ Test with new flag (Iceland) attached to FlagShip
		+ Step 2: new StructuralMaterial property: WindReceptivity
			+ Optional in json (default=0.0), only set for cloth
			+ Update guide
		+ Step 3: erratic behavior of wind
			+ GameParameters::WindSpeed becomes WindSpeedBase
			+ World::UpdateWind(): implements state machine and calcs current wind force
				+ Incorporate gust adjustment
				+ See if we need to up force a bit for fater response
					+ See first w/64 fps first if more respondent - skinnier test ship
				+ Use short running average to smooth transitions (minimally)
					+ Make it 4
					+ Get rid of intermediate states
				+ Do piecewise state machine, w/various prob types
					+ Gust transitions are still poisson, but not their duration
		+ Step 4:
			+ See interaction of wind on waves
				+ Hi-freq sine whose amplitude is normally zero unless wind force over base
		+ Add all wind settings to SettingsDialog
			+ Include global flag
		+ Sound:
			+ Layered like waves:
				+ 1 continuous sound
					+ Triggered by abs threshold, 30
				+ 1 one-shot sound (Gust)
					+ Triggered by abs threshold && force > .9*Max
			+ IEventHandlers::OnWindForce...(zero, base, max)
			+ Do more gusts
			+ Fix initial ramp up
				+ RunningAverage::Fill(float)
				+ Remove log message @ SoundController
			+ Remove probe
			+ Make sound's volume change inertial
		+ Add probe for wind force
		+ Step 5: implications of low wind settings
		+ Test:
			+ SettingsDialog:
				+ Dealing with negative wind
					+ See ripples
				+ Gust adjustment
				+ Modulation off
		+ Try:
			+ Debris and Sparkles created with WindReceptivity=1.0
			+ Rope has small WindReceptivity
		+ SettingsDialog: expose "Play Wind Sound"
			+ Test
		+ Re-dimension wind force
			+ Try default being -24
				+ Flip Flagship
			+ Say it's km/sec and transform to F (m/sec, w/air mass) in ApplyForce
			+ Eventually adjust receptivity of cloth and rope
			+ If ok:
				+ Also change receptivity of sparkles and debris
				+ Test
			+ Test Sailship 1
			+ Increase strength of cloth to avoid stress at Flagship
		+ Check with wind speed = 0 - divisions by zero!
			+ Wind
			+ Water
			+ Sound?
		+ Test another re-dimension:
			+ Fw = 1/2 rho v2 A
		+ Test perf
			+ Do perf analysis to rule out sound
		+ Rearc: Wind exports speed (vector & magnitudes), in km/h
			+ Ship calcs force
			+ Calc & adjust sound factors
			+ Test:
				+ Force on cloth
					+ Lower receptivity
				+ Force on Titanic's cables
				+ Sound
					+ Lower curve
				+ Waves
					+ Make them faster
				+ Clouds
				+ Max settings
		+ Cloth:
			+ Less heavy
				+ Up strength by same factor
			+ Less stiff
				+ No
		+ Do SailShip 2
			+ Larger sail?
			+ Cleanup texture
			+ Add ropes
			+ Finish structure
	+ Decay (rust)
		+ Spec:
			+ Over time, *wet* points and springs get decayed (grey), and strength lowers
			+ GameParameters: DecayAcceler8r controls how quickly
				- 0  = +INF == never
				- 1  = 5m (default)
				- 10 = 10s
			+ Low-frequency Ship update does job
		+ Impl:
			+ Points: new Decay float buffer
				+ Init as 1.0
					+ Idea is that Ship::DecayStructure sends it asymptotically to 0.0
			+ Springs: new MaterialStrength float buffer
				+ Init with material strength, same as Strength
				+ Getter const
			+ Points: ConnectedSprings structure contains size_t with # of springs owned by the point
				+ Update at Add/RemoveConnectedSpring
					+ And make owned first, non-owned next
				+ Clone same to triangles - remove isAtOwner flag there
			+ FastLog2 benchmarks
			+ Commit
			+ Ship::LowFrequencyUpdate()
				+ Invoked by Ship::Update
				+ Checks whether currentSimTime >= lastLowFrequencyUpdateSimTime + GameParameters::LowFrequencySimulationStepTimeDuration<float>
				+ Does:
					+ Ship::RotPoints() -> decay
						+ alpha = (10^-5)^(f(Acceler8r)/300) (~total decay in 300/f(RotAcceler8r) steps)
							+ Accel = 1 => 300 steps (5 mins)
							+ Accel = 10 => 30 steps (30  secs)
							+ Accel = 0 => +INF steps
							+ Come up with reasonable min, max
						+ for each point p:
							+ beta = alpha * log(1 + p.water) (beta << 1)
							+ if p.isLeaking: beta *= 5.0
							+ p.SetDecay(decay *= (1.0 - beta))
								+ Check assembly for p.SetXYZ() vs p.GetXYZ()*=y !

						+ Points.MarkDecayBufferAsDirty()

					+ Ship::DecaySprings() -> strength
						+ for each spring: strength = material's strength * avg of two endpoints' decay
						+ Check assembly
					+ Spread out the two calls
						+ Check with large ship if stutters
					+ Do RotPoints at SimulationStepSequence%4 and DecaySprings at SimulationStepSequence%5
						+ Change visit sequence number to SimulationStepSequenceNumber
							+ Double-check first
							+ Type (SequenceNumber, never zero) and variable (SimulationStepSequenceNumber
			+ (Ship)RenderContext:
				+ UploadDecayBuffer
					+ Just like upload plane ID, opportunistic
					+ Interleaves in attribute group 2, at the place of padding
				+ Shaders:
					+ Group2: vec3 -> vec4
					+ Triangle, Spring, Ropes, and Point shaders give value to fragment shader
					+ Fragment shader uses it for:
						+ Pre-test: triangle shader: just display white*decay
						+ Production:
							+ Blend with rot color == l(brown) + (1-l)(green), with l==lightness
					+ Do also at ship_color shader
			+ Less stress sounds when really decayed
			+ Ship::Render:
				+ Points::UploadAttributes
					+ Now also uploads Decay buffer @ //mutable attributes// if dirty, and of course resets flag
			+ SettingsDialog:
				+ RotAcceler8r
				+ Debug option for rendering decay
			+ Debug option for rendering decay
				+ Make 1 single layer
			+ Scrub tool
				+ Cleans when moves (sends decay back to 1.0)
					+ Along trajectory, magnitude dependent from distance between tool and point
				+ Icon: sponge
					+ Make separate down and up
				+ Sound: scrub, with movement (based off feedback from GameController, like saw)
				+ Better sounds with vector directions
				+ Help
	+ Repair tool
		+ 1) No Points::Destroy/Delete, but Detach()
			+ Points::Detach(.), also at Handler
			+ No IsDeleted() checks anymore, anywhere
			+ Whenever we used to delete, we now detach and inject velocity
				+ Encapsulate debris' randomness in Ship::ChooseRadialVelocity(rnd coeffs)
			+ Bombs::OnPoint"Detached"
			+ At these places should only consider non-ephemerals and non-expired ephemerals
				+ Ship::Get/QueryNearestPointAt
				+ PinnedPoints::Toggle:
			+ Ship should have EphemeralPointExpired handler
				+ Calls PinnedPoints::OnEphemeralPointExpired
			+ Decide what to do with event handlers - destroy and/or detach
				+ Points invokes OnDestroy at DestroyEphemeralParticle
				+ Ship::DetachHandler invokes OnPointDetached at DetachHandler *iff* really ended up detaching anything
					+ Points::Detach does not invoke anymore OnDetach directly, only ship handler does
					+ OnPointDetached/Attached: make aggregations
					+ SoundController::OnPointDetached: use break
			+ Check steady clock
			+ Test in Debug mode:
				+ Bombs neighborhood
				+ Destroy
				+ Destroy AirBubble
				+ PinnedPoints:
					+ AirBubble
					+ Remaining at point
					+ Destroyed
					+ On ephemeral that becomes expired
			+ If pinned points OK: remove TODOTEST for OnSpringDeleted
			+ Check perf
				+ 29.9/30.0
			+ Commit (to new branch)
		+ Do perf analysis with many air bubbles
			+ Make sure we don't make OpenGL calls for the zero-size gentex vectors
			+ Check perf impact of single GenTex draw call
				+ Mapbuffer & copy all
				+ Get rid of maxMaxPlaneId for gentex's
				+ Test:
					+ Bombs cover each other
		+ Run in Debug
		+ Check flood tool change (Tool::Initialize - verify sound starts)
		+ 2) Maintain factory connections
			+ Not electricals (at least for now)
			+ Points:
				+ AddFactoryConnectedSpring(...)
					+ -> ConnectSpring(...)
				+ Connect/DisconnectSpring(...)
					+ assert it's in factory-connected springs
				+ See if connecting-spring-kung-fu should be done by struct itself
				+ FactoryIsLeaking
			+ Springs:
				+ FactorySuperTriangles
			+ Other factory connections as necessary by restore algo
			+ Springs::Restore
				+ Undo deletion
				+ Call SpringRestoreHandler
			+ Ship::PointDetachHandler:
				+ See if it's true that we don't need to destroy triangles
			+ Springs::Restore
			+ Ship::SpringRestoreHandler(s)
				+ Add others to self
					+ Copy factory supertriangles
				+ Add self to others
					+ Connect self to endpoints
					+ Add self to each supertriangle's subsprings
				+ Set IsStructureDirty=true
			+ Triangles::Restore
				+ Undo deletion
				+ Call TriangleRestoreHandler
			+ Ship::TriangleRestoreHandler(t):
				+ Add t to its endpoints
				+ Fire Attach event
				+ Set IsStructureDirty=true
			+ Update invariants verification
		+ Commit
		+ Try changing Points::GetMass to Points::GetAugmentedStructuralMass
		+ Move tolerance check _after_ movement
			+ Movement is still only done if not within tolerance
				+ And changes distance
		+ 3) Repair tool and action
			+ Repair(Pr):
				+ for each s in Pr.FactorySprings:
					+ if s.IsDeleted:
						+ if s.length <= s.restLength: // Restore
							+ Springs::Restore(s)
							+ Try with force instead of velocity
						+ else: // Attract endpoint
							+ Points.GetForce(s.OtherEndpoint) += c * <normal>(Pr.Position - OtherEndpoint.Position)
							+ Try with force instead of velocity
				+ for each t in Pr.FactoryTriangles:
					+ if t.IsDeleted:
						+ If all t.FactorySubSprings are !Deleted:
							+ Triangles::Restore(t)
				+ Restore endpoints' IsLeaking
					+ Only for endpoints that now have all of their factory springs
				+ Decide on:
					+ Radius
					+ Force
					+ Ultra-violent mode effect
			+ Test pinned points now
			+ RepairStructureTool:
				+ repair_structure_cursor_up/down.png: wrench
					+ multiple frames for different rotations
					+ sync with sound
					+ do other 22.5-degree frames
				+ Adjust cursor hotpoints
			+ SoundController:
				+ RepairTool sound
				+ OnRepair
					+ Sounds:
						+ Metal
						+ Cable
						+ Cloth
						+ Glass
						+ Wood
						+ X2 (underwater!)
						+ Lower volume
		+ Parameters:
			+ Remove repair force adjustment from GameParameters
	+ Also dry points should rot, albeit very slowly
		+ ...and also do "rust_receptivity" material property
		+ Rotting factor: (inner water + (isUnderwater ? 0.1 : 0.0)) * material.rust_receptivity
			+ 0.2
		+ Do stainless steel materials
			+ Test ball half/half in "New Materials Balls.png"
		+ Add new property to materials guide
		+ See general speed of rotting
	+ Make waves with Shallow Water Equations
		+ Implement
			+ Rename to OceanSurface
			+ Step 1: basic SWE with reflecting boundaries
				+ cctor: wave initialization
				+ Update:
					+ SWE update -> next buffers
					+ NextHeightBuffer + Wind gust sines -> mSamples
					+ Swap buffers
			+ Step 2: perturbation tool
				+ OceanSurface::AdjustTo
			+ Rearc:
				+ Basal waves
					+ Params:
						+ Width (wavelength)
						+ Height
						+ Period (=> speed=Wavelength/Period)
					+ Impl:
						+ Funcs:
							+ sin
						+ Composition of SWE and basal:
							+ add
						+ Wave width is "WaveWidthAdjust"
							+ fraction of MaxWidth - MinWidth(H)
							+ MinWidth(H) = 6*H
							+ 1.0 means "max width" = f(height)
						+ Wavelength and period correlated:
							+ Change period into speed (m/s) = S
							+ S = 1/sqrt(2PiL/g)
							+ Adjustment makes +/- 50%
								+ Speed is never zero
								+ See if need to adjust percentage bands to avoid "almost still" waves or too slow waves
								  or too fast waves
						+ Actual wave speed = speed * direction(wind speed) + wind speed * factor
							+ With speed > 0
						+ Multiple components:
							+ Two components:
								+ 2nd component has sin phase with very slow period
						+ Find good initial conditions
							+ Need "as if" wind was 40, but not simply 2x as wind=100 makes wind'=200
					+ Controls:
						+ WidthAdjust, Height, Period (>0)
				+ SWEs
					+ Tool
						+ Tool does no smoothing
						+ OceanSurface implements trajectory
							+ Delay rate must itself depend on delta H
						+ Test max delta H
						+ Find correct falling water speed
						+ Check if average water depth increases
					+ Cursor: set arrows at same positions as adjust terrain cursor
					+ Tsunami
						+ GameParameters: "TsunamiArrivalTime", mins
							+ Min = 0 => no tsunamis
							+ Max = 15
							+ Settings Dialog, under "Wave Phenomena"
								+ Tooltip: "...disables automatic generation of..."
						+ Tools menu entry - w/no accelerator key
						+ OceanSurface:
							+ Tsunami-specific StateMachine member, std::optional
							+ When not set:
								+ Run choosing until chosen
									+ Do not trigger within first 1 minute
								+ TriggerTsunami() when triggered
							+ void TriggerTsunami():
								+ Emplace state machine
								+ Test if slower rise (not fall) makes better long-run wave
								+ Fire "OnTsunamiTriggered" event
							+ State machine
								+ Height = 105 (5%)
								+ See if need custom fall rate
									+ If so, new state machine altogether
							+ Publish "OnTsunamiTriggered" event
								+ Break IGameEventHandler into smaller pieces
									+ Do separate one for hi-freq events
								+ Ship takes GameEventDispatcher directly
								+ GameController registers for OnTsunamiTriggered and runs TsunamiNotificationStateMachine
									+ TsunamiNotificationStateMachine: private class, cctor takes:
										+ TextRenderContext (for text)
										+ RenderContext (for shaking)
										+ bool Update(): when returns false, GameController nukes it
									+ Text
									+ Shaking
								+ SoundController:
									+ Tsunami sound, one-shot (overridable): rumbling + siren + background SOS
							+ UI preferences: show tsunami notifications checkbox
								+ UIPreferencesManager:
									+ It's a test for SettingsManager
									+ Replaces UIPreferences
										+ Also given to ShipLoadDialog et al
									+ Also acts as storage for some of them (those not owned by GameController)
									+ Exposes setters and getters for all (like SettingsManager)
									+ Takes GameController at cctor
										+ And gives it GameController's owned properties after having loaded them
									+ Tooltip: say "visual notifications"
										+ We keep sound
									+ Test entire preferences dialog
									+ Test tsunami notifications
					+ Rogue waves
						+ GameParameters: "RogueWaveArrivalTime", mins
							+ Min = 0 => no rogue waves
							+ Settings Dialog, under "Wave Phenomena"
								+ Tooltip: "...disables automatic generation of..."
						+ Tools menu entry - w/no accelerator key
						+ OceanSurface:
							+ RogueWave-specific StateMachine member, std::optional
							+ When not set:
								+ Run choosing until chosen
								+ TriggerRogueWave() when triggered
							+ void TriggerRogueWave():
								+ Take Wind & calc right locus index based off direction
							+ State machine
								+ Height = 101 (1%)
								+ See if need custom fall rate
					+ Re-check exponential distribution
						+ And make helper at GameRandomEngine that takes CDF
					+ Test with basal waves added to SWE height field, instead of added to samples
					+ Test with 3 samples being modified at SWEWaveStateMachine
					+ Test with SWE with double's to see if long-running wave is better
				+ SettingsDialog:
					+ "Wind and Waves" tab
						+ Static box for basal waves
						+ Tooltips
					+ Run in Debug
			+ Final touches:
				+ Cursor
				+ WaveMaker:
					+ Double-check hotspot
					+ Tool sound
						+ Continuous with fade-in and fade-out
						+ Fix restart while fading-in
						+ Better sound
						+ See linear fade-out again
				+ See if can stop making reflective boundaries with height field=0
				+ Smooth some other parameters
					+ Ocean depth, ocean bumpiness, ocean detail
				+ SWE boundary conditions: try 5 bc samples, damping heights and braking down linearly
				+ Try with other formulation of SWEs
				+ Optimize alpha changing for text
				+ Reduce world width
				+ Cap interactive height
			+ Optimizations:
				+ FPS before: 28.6/28.6/28.7/29.5/29.6/
				+ 1: Basal wave params and abnormal wave CDFs calc'd only at GameParameters changes
					+ Test all param changes
					+ Test tsunami notifications
				+ UR/Ratio: 220/230
				+ 2: Pre-calc'd funcs (sin)
					+ Arg needs to become current_arg/2PI
				+ 3: Samples: advance x's with sums, no multiplications
					+ Take into account current_arg/2PI
				+ 4: Anomaly choosing done only at scheduled (wallclock) times, every ~0.5 sec
					+ AnomalyTriggerSampleInterval = 500ms
					+ Adjust exponential coefficients
						+ If we want 1 tsunami every TsunamiRate * 60.0f second, we want 1/(TsunamiRate * 60.0f) tsunami
						  every second, and thus we want 1/(TsunamiRate * 60.0f * 1s / AnomalyTriggerSampleInterval) every interval
						+ Double-check wind while you're at it
					+ Verify rates
				+ FPS: 30/30.15; UR/Ratio: 206
				+ 5a: See if both advections are really needed
				+ 6: Two field updates in one, so that we have a single loop
					+ Then, check assembly
				+ FPS after: 30.4/30.6; UR/Ratio: 218
			+ See to reduce flattening of waves
				+ Test lower offset
				+ Try again with height offset
				+ View values
			+ Check width of tsunami wave
			+ Retry damping boundary conditions
				+ Between advection and update
				+ Test first in visible world
				+ Finalize
			+ Merge
	+ Heat and Combustion
		+ Spec:
			+ Integration of Decay with Combustion:
				+ Combustion also is a source of decay
				+ Springs should get weak based off decay, independently from source
				+ It is really 3 distinct processes:
					+ 1a: Point rotting:
						+ Low-frequency
						+ water + isLeaking => decay
					+ 1b: Point combustion:
						+ Any frequency (combustion state machine update frequency)
						+ combustion y/n => decay
					+ 2: Spring decay
						+ Low-frequency
						+ p.decay => s.strength
							+ Use both endpoints' decay
						+ Impl:
							+ Springs::Decay(Points const &)
								+ For each spring: strength = material's strength * avg of two endpoints' decay
									+ float buffer: MaterialStrength
			+ Rendering of flames:
				+ Need depth-sorting:
					+ Ship has heap of indices of burning points
						+ Ordering of heap: plane ID
						+ Heap created from scratch at connectivity visit
						+ Heap updated by Points's combustion state machine update (heap passed by Ship) when points start
						  or stop burning
						+ Heap used by Points's Upload() (heap passed by Ship)
		+ Impl:
			+ Properties and Materials:
				+ New StructuralMaterial properties:
						+ Ignition temperature (T)
						+ Melting temperature (T)
						+ Thermal conductivity
						+ Specific Heat
						+ Combustion type (Combustion, Explosion)
					+ Add all of them via script, with switches based off material type
						+ Thermal conductivity: see https://en.wikipedia.org/wiki/Thermal_conductivity#Units
						+ Then, manual tune
					+ Add all of them to guide
				+ Points:
					+ MaterialIgnitionTemperature
					+ Temperature/Buffer
					+ CombustionState/Buffer
				+ Springs:
					+ MaterialMeltingTemperature (avg of two endpoints, calcd at Add())
					+ MaterialThermalConductivity (avg of two endpoints, calcd at Add())
				+ Renames:
					+ Points::TotalMass -> "CurrentMass" (and UpdateTotalMasses)
						+ TODO: rethink this one; "Mass" contains augmentation nowadays
					+ Springs::Stiffness -> "MaterialStiffness"
					+ Springs::Coefficients -> "CurrentCoefficients"
					+ Springs::StiffnessCoefficient -> "CurrentStiffnessCoefficient"
					+ Springs::DampingCoefficient -> "CurrentDampingCoefficient"
					+ Springs::Strength -> "CurrentStrength"
					+ Springs::GetMaterialStrength
					+ See whether all "current" should go and become _just_
			+ Heat overlay:
				+ Ship/RenderContext flag
				+ SettingsDialog
				+ Ship::Render: when flag set, upload heat buffer (much like we do w/Decay)
					+ Ship/RenderContext UploadHeat
						+ Maintains dirty flag and exposes MarkTempBufAsDirty - exactly like decay - which is invoked by:
							+ Heat propagation
				+ Ship/RenderContext render
					+ Rendering:
						+ RenderCore enums
					+ Shaders:
						+ Do point, spring, and triangle shaders
							+ Do second, richer version of main ones - "...WithTemperature..." - that completely
							  replace the first ones when the heat overlay is activated
								+ Texture
								+ Color
							+ Parameter setting
						+ Use temperature buffer (of floats) to produce "temperature color" as:
							+ tint3 = mix(c1, c2, some f of temperature ~= 1-e^(-paramHeatContrast*T)) // see https://en.wikipedia.org/wiki/Incandescence#/media/File:Example_incandescence_colors_(temperature_range_550_-_1300_C).svg
						+ Make it glow in the night
						+ Use function (in include) to apply heat overlay
							+ Nuke static params 4 colors
						+ Try multi-band gradient
					+ Transparency at SettingsDialog
						+ "Render" section under "Heat"
						+ Figure out right default value
			+ Physics update:
				+ Ship::Update:
					+ @Beginning: either call Springs::UpdateParameters(params, points) or call
					  Springs::UpdateDecayAndTemperatureAndParameters(params, points), depending on simulation step
						+ Springs::UpdateParameters(params, points):
							+ iff params updated: UpdateDecayAndTemperatureAndParameters(params, points)
						+ Test:
							+ Stress and break (Titanic)
							+ Mass augmentation
							+ Repair (restore)
							+ Param changes
						+ Springs::UpdateDecayAndTemperatureAndParameters(params, points):
							+ Assumption: Decay and Temperature have changed (Parameters not necessarily)
							+ (Params, P.Temperature, P.Mass) -> StiffnessCoefficient
							+ (Params, P.Mass) -> DampingCoefficient
							+ (Params, P.Decay, P.Temperature) -> S.Strength
								+ Params are needed to include StrengthAdjustment and NumMechanicalDynamicsIterationsAdjustment
								  in "current" strength
								+ Add "MaterialStrength", and use "Strength" for strain
									+ Check for all current uses of Strength and replace with MaterialStrength
								+ Since we're touching this: factor in Strength the other things that we calculate at
								  UpdateStrains, namely:
									+ StrengthAdjustment, NumMechanicalDynamicsIterationsAdjustment
									+ Rest Length
							+ Flip burning and melting point in metals
						+ Nuke Ship::DecaySprings and, with it, Springs::Set(Current)Strength
						+ Cleanup low-frequency schedule now that DecaySprings is gone
							+ Change frequency altogether to 7*6
						+ Verify assembly: hopefully no call to UpdateForDTP(...springIndex...) from UpdateForDTP(all)
					+ Later on: Ship::UpdateHeatDynamics:
						+ At one slot: call Ship::PropagateHeat()
							+ Propagation and dissipation
								+ New global constants: AirTemperature, WaterTemperature
								+ Use specific dt's calc's as constexpr's in UpdateTemperature based off frequency of steps
								+ Dissipation: use air or water temp, depending on whether it's above water or below
									+ Exaggerate water dissipation, so that smothered fire does not rekindle immediately
										+ First, double-check calculations, however
							+ Cleanup TODO's (and do we have a useless step frequency constant now?) to keep it at each step
						+ At another slot: call Points::UpdateCombustionStateMachineLowFrequency(...)
							+ For each point:
								+ If it's not combusting:
									+ Check combustion transition
										+ Notify
										+ Choose random max development
								+ Else (it's combusting):
									+ Check exhaustion transition
										+ Notify (boolean for water-caused)
									+ Do decay: burn rate (i.e. decay speed) ~= structural mass (the lower the mass, the faster decays)
										+ Verify default, min, and max
									+ No temperature and no raise and lower flames, done below at Points::UpdateCombustingPoints()
								+ Water (both underwater and flood) should apply regardless of state
								+ Do phased ignitions (N at a time)
									+ Run low-frequency state machine M times for 1/Mth of the points each time
									+ Choose number of promoted randomly = N
										+ Find right N: depends on M
									+ At each step: choose top N ignitions over all candidates, sorted
									  by temperature over ignition temperature
						+ At all steps: call Points::UpdateCombustionStateMachineHighFrequency(heap)
							+ Points uses heap (with burning points) and evolves the "burning"
							  state machine
								+ Raise flames up and down
									+ Redo 3 curves, see paper
								+ Heat to self and neighbors
									+ Do code changes
									+ Do flag to turn off flame rendering
										+ Move flame rendering to heat & combustion?
			+ Ship::ConnectivityVisit:
				+ Call Points::ReorderBurningPoints()
			+ Ship::Render:
				+ Calls Points::UploadFlames()
					+ Uploads flames in order of heap
			+ See Pac0master's bug: looks like when the cardboard of the funnel touches the water it starts generating a super high amount of heat
			+ See Pac0master's bug: Spawn the default ship,  max out the Thermal conductivity and  dissipation the back of the ship will start to heat up and melt very fast
			+ Melting improvements:
				+ Option 1: Test with sticky strength
					+ Springs has new buffer, "MeltStrengthComponent", always > 1.0
					+ We might also need sticky stiffness, but try with strength first
				+ Option 2: Test with sticky rest length
					+ StiffnessCoeff and Strength are memory-less: they return to their original values when no melting occurs,
					  but RestLength not
					+ First test in-place modifying RestLength; if ok:
						+ Make "FactoryRestLength" buffer
						+ Verify all usages of RestLength and choose accordingly
							+ Repair: try using both as targets and choose best
						+ Decide performant way of making rest length sticky
						+ Update comments at Springs
					+ Do asymptotic stiffness, not zero
					+ Try different DeltaTMax's
					+ Repair: recalc coeffs when we've set a new rest length
						+ Adjust rest length before all, "snapping" rest length to factory when close enough
							+ Also set rest length to factory when spring restored
						+ Use boolean flag to recalc coeffs just once per spring
						+ General:
							+ See if should be faster (play with settings' speed)
							+ See if UltraViolent mode makes sense
						+ Decide whether to target current or factory rest length
			+ Electrical: devices generate heat, and lights and generators break at low and high temperatures
				+ New electrical material properties - "HeatGenerated" and operating temperatures
				+ GameParameters: electrical heat generated adjustment
					+ Settings dialog: new "Electrical" section between HeatBlaster and World
				+ Rearc:
					+ ElectricalElements has buffer with operating temperatures
					+ ElectricalElements::UpdateSourcesAndPropagation (rename from "Connectivity")
						+ Move from Ship
						+ Uses mSourceIndices as starting point, instead of just generators
							+ Nuke generator indices
						+ For each source:
							+ Check preconditions:
								+ Wetness
								+ Operating temperature
							+ If ok:
								+ Generate heat (using also adjustment)
								+ Flood graph for VisitSequenceNumber
					+ Rename "AvailableCurrent" as "AvailableLight"
					+ ElectricalElements::UpdateSinks (replaces "Update")
						+ Uses mSinkIndices (vector of indices, not only lamps)
						+ Lamps: run lamp state machine
							+ Consider also operating temperatures in state machine and transition accordingly
							+ Each time AvailableLight is > 0, generate heat (using also adjustment)
					+ Make self-combusting ship:
						+ Make heat-resistant materials (low thermal conductivity and high heat capacity):
							+ Electrical:
								+ Generator
								+ Lamp
								+ Heating Element
									+ And catch at script
						+ Do ship
						+ Redo template
			+ Make flames smaller when point is orphaned
				+ 1: Ship::SpringDestroyHandler: invoke Ship::OnPointOrphaned for each endpoint that becomes orphaned
				+ 2: Ship::OnPointOrphaned: invoke Points::OnPointOrphaned
				+ 3: Points::OnPointOrphaned:
					+ Suddenly truncate development
						+ Try even smaller ?
			+ Interaction with bombs:
				+ Triggering:
					+ Timer, Impact, RC:
						+ Trigger when temperature > GameParameters::BombsTemperatureTrigger = 773.15 (500C)
					+ Anti-Matter: + 1000
				+ Explosion:
					+ Timer, Impact, RC:
						+ Produce heat directly at Ship::DoBombExplosion
							+ Verify first it's called at these 3
							+ Add heat to each point in blastRadius, considering ultra-violent mode as well
								+ Use GameParameters::BombExplosionHeatProduced
									+ Also at settings dialog, under Interactions
					+ Check if default value is good
					+ Check maximum again
			+ Flamethrower:
				+ Physics:
					+ Ship::Interaction:
						+ GameParameters::FlameThrowerHeat
							+ Absolute value, in J
							+ SettingsDialog, under "Flamethrower" in "Heat"
						+ Convert into DeltaT and inject in radius, smoothing radius
					+ Radius at SettingsDialog, under "Flamethrower" in "Heat"
					+ Fix default value of heat <-> slider
				+ Max power: 20,000
				+ Rename it: "Heat Blaster"
					+ Code & UI
					+ Shift cools down
						+ New HeatBlasterAction enum at GameTypes {Heat,Cool}
						+ Interaction: switch on action and either add or remove heat (w/fraction though, for 3rd principle)
						+ Rendering:
							+ Shader chosen depending on mCurrentHeatBlasterAction
								+ Two shaders, use #include's returning radius with parameters to make these changes:
									+ Flame direction (outward or inward, "speedMultiplier")
									+ Then make flame colors (for cooling: turn R into B)
						+ Cursor (simply upside-down and mirrored)
						+ Sound (wind or air vortex)
				+ Option to turn off flame rendering
					+ @ GameController
				+ Help
			+ GameParameters:
				+ ThermalConductivityAdjustment
				+ IgnitionTemperatureAdjustment (in SettingsDialog: "Burning Point Adjust")
				+ MeltingTemperatureAdjustment (in SettingsDialog: "Melting Point Adjust")
				+ CombustionSpeedAdjustment
				+ CombustionHeatAdjustment
				+ Also add all of these to settings dialog, under "Heat" tab
				+ Make max burning points adjustable
					+ All sub-systems need to allow for > max burning particles, because when the user changes the value down,
					  the excess ones will need some time to disappear
						+ Test
					+ RenderContext: realloc VBO each time # of flames changes by 100
					+ Points: doesn't care as it uses vector
					+ SettingsDialog
						+ Under "Heat", with warning icon like Simulation Quality
				+ Make air and water temperature adjustable
				+ See if should lower default MaxBurningParticles (per impact of all burning)
				+ See if should allow higher heat blaster
			+ Flame render:
				+ Make better transition for bottom
				+ Skew wind speed with smoothstep
					+ And reverse wind direction
				+ Make yellow core more narrow, in favor of thicker red border
				+ Make more vivid red
				+ Smoothen wind change (via running average @ RenderContext)
				+ Add slider for flame size
				+ Move wind rotation before noise sampling
					+ Nuke wind randomization
				+ Reduce local coherency of noise
					+ Add FlamePersonalitySeed shader param, straight from ship into vertex buffer
				+ Make same colors as flamethrower
				+ Adjust bottom
				+ Try without red border, to better merge multiple flames together
				+ Multi-flame improvements:
					+ Make better personality (less locality-aware, more randomized)
						+ Assign actual random number between zero and one at ignition time
						+ Change shader to expect value between zero and one
					+ Try dual-phase rendering: border only first, body only then
						+ Test
						+ Do vertex includes
						+ Test perf with instanced drawing(x2)
				+ See if can fix problem with flames on ropes that swing behind triangles
					+ Separate render step for chains, and flames belong to chains if their point
					  has no attached triangles
					+ Test
					+ If works:
						+ Go back to one single buffer (& single VBO, & single VAO), having StartUpload declare total # of flames,
						  and adding bg ones at beginning and fg ones at end
							+ Keep track of beginning of fg ones == end of bg ones
					+ OnChain detection: use # of factory triangles, not current triangles (heuristic to avoid jumping planes
					  when triangles are destroyed by fire)
				+ Try different color scheme
					+ If keep: do also at:
						+ Flames2
						+ HeatBlaster flame
			+ Sound:
				+ Media:
					+ Burning loop
					+ Sizzling X 2 or 3
				+ SoundController:
					+ Subscribe to OnCombustionBegin/End: adjust cumulative volume of Burning sound
					+ Subscribe to OnCombustionSmothered: play one-time sizzling
		+ Experiments/Improvements:
			+ Consider higher default heat from flamethrower tool
				+ Current (900k) is fine for wood and ropes and cloth
			+ Fire-generated heat should be 10x in order to spread more
				+ Or: check if heat should depend on ignition temperature of that point
					+ Is it possible that the heat we release now from burning hi-ign-temp points is actually lower than the one
					  the point has in order to be at that temperature?
				+ Spreads just fine on wood, ropes, and cloth
			+ Lower the min decay for extinguishing, so things break easier once burnt
			+ When state is Burning, also decay non-burning neighbors on top of decaying self (so to smear burnt color more around)
				+ At low-frequency update
			+ Max flame development depends on number of springs connected to point (so ropes have smaller flames)
			+ See if heating element should heat less
			+ Try max air and water temp to 5K
			+ Make melted stuff break earlier
				+ Limit breaking length somehow
				+ Try with limiting rest length instead
				+ Avoid breaking: try with non-smoothstep melt depth (and lower breaking length when melted)
			+ Flame render:
				+ Move more with wind
				+ Transparency on border - slightly more transparent at discard threshold
				+ Noise sampling tests, who knows - it might get better:
					+ Try different noise resolution
					+ Try without second noise component
					+ Try with third noise component
			+ Flamethrower flame render:
				+ Large flamethrower should have higher resolution
				+ Softer border
		+ Optimizations:
			+ Pre FPS: 17/18 fps, 34 U/R @ 111 flames (normally 40, 188)
			+ Do perf analysis for low-hanging fruit first
			+ Low-freq combustion state machine:
				= Burning candidates:
					+ Sticky priority queue: leverage temporal coherence of overheated particles
						+ Contains:
							+ buffer for heap, maxSize = nPoints
							+ buffer of int32_t where element I contains either index in heap buffer of that element,
							  or max<int32>
						+ Exposes:
							+ remove_if_in(ElementIndex)
								+ If in heap, removes it
							+ add_or_update(ElementIndex, val)
								+ If in heap: update and update heap
								+ Else: add
					+ Do benchmarks: (10 out of 20/100/500)
						+ Vector_AddAndSort
						+ PriorityQueue_Add
						+ PriorityQueue_AddAndPop (sort by lowest, and keep top 10)
						+ Vector_AddAndNthElement
						+ Sticky_PriorityQueue
							+ Loop: makeup index w/ (i%200)
						+ TruncatedPriorityQueue
							+ New class altogether, no tracking
					+ Use NthElement w/member BoundedVector
			+ HeatPropagation:
				+ Do perf analysis invoking it N times per frame to exaggerate: 10.4/10.6
				+ Try impact of storing outgoing flows @ local array
			+ Flame rendering:
				+ Do perf analysis to see impact
				+ Shader:
					+ Replace pow with 3 mult's - see FPS gain
					+ When YesBorder, also discard at core
					+ Move discard earlier
					+ Move GetNoise inline
					+ Precalc wind angle in code and send as param
					+ Precalc noise offset in code and send as vertex attrib, replacing flame personality seed
						+ And do not set param time anymore
				+ Get timings
		+ Cleanup:
			+ Test generic textures change (gen tex's + air bubbles at same time) and nuke comment
			+ Test cross of light change
			+ SettingsDialog: Heat Dissipation tooltip: "...dissipate or acquire..."
			+ Run in Debug
		+ Flamethrower tool:
			+ RenderContext exposes UploadFlameThrower(worldPos)
			+ GameController stores worldPos at ApplyFlameThrower(screenPos) and later, at Render, invokes RenderContext::UploadFlameThrower()
			+ Cursor
			+ Sound
				+ Continuous
			+ Tool
				+ Engages (and starts sound) only if GameController::ApplyFlameThrower(screenPos) returns true (i.e. point found in radius)
			+ Fix radius & size (smaller radius for catching points, same render size)
			+ Radius setting
			+ Apply heat (& Ultra-Violent mode)
		+ Update changes.txt
	+ Storms
		+ Another physics component
		+ Game wall-clock based
		+ State machine with concentric phases:
			+ Wind (and thus waves)
				+ Make clouds more sensible to speed - should go faster at higher speeds
				+ No zero state while there is storm
				+ Test storm wind on top of wind modulation
			+ Cloud Darkening
			+ Darknening
				+ Out of phase with cloud darkening, to avoid ugly crossing
				+ RenderContext exposes UploadStormDarkening(float), which is used as multiplier with ambient light
				  and triggers a param update for shaders' effectiveAmbientLightIntensity (rename)
					+ Rename shaders' param
						+ RenderCore
						+ Shaders
						+ RenderContext.h
					+ Add RenderContext method and trigger EffectiveAmbientLightIntensity param update if
					  stormDarkening is different than current
					+ Invoke from storm
					+ Test combined changes in intensities
			+ Clouds
				+ Rearc clouds:
					+ Clouds:
						+ Position is maintained into x=[-1.5, +1.5]
						+ Normal clouds:
							+ New clouds: random
							+ Old clouds: removed
							+ Roll clouds around
						+ Storm clouds:
							+ New clouds: at spaced intervals, checked w/last in vector (arbitrarily),
							  at +1.5 or -1.5 depending on total wind speed sign
								+ Higher scale range, with median larger with progress
							+ Old clouds: removed when rolled over
							+ Roll clouds around
						+ Cloud darkening:
							+ Per-cloud, storm only
							+ Use values: 0.3, 0.56, 0.93
							+ Shader
					+ RenderContext:
						+ map into NDC
						+ Remove test overrides
				+ See if can enlarge small cloud
				+ See if may make storm clouds larger, so to cover whole sky
			+ Rain
				+ Shader
					+ Try with more spatial density
					+ Discard
						+ See if it helps with perf: NO
					+ See double-speed
					+ Discard if tile off - see perf impact
					+ Lower density (and thus up volume)
				+ Sound (continuous, like wind)
			+ Thunders
				+ Others random with same distribution as wind gusts
				+ Events
				+ Sounds (N, one shot)
			+ Lightnings
				+ Storm state machine
					+ Invoke both OnLightning("Touchdown") and mParentWorld.ApplyLightning after .3 of progress
						+ In which case, externalize state machine as we need to emit event
						  during progress
						+ Upload also renderProgress
							+ Save one attribute (space Y, which is == position Y)
					+ Finalize duration
				+ Candidate choice:
					+ Exclude orphaned points
					+ Candidates should be further apart
				+ Storm damage
					+ See if speed of sparkles is ok
					+ Heat
					+ Sound: make 1-3 mixes manually of each material, and make new event ("OnLightningHit(material)")
						+ Mixes: various combinations of Destroy Small sounds
				+ Shader
					+ Figure out daylight colors
					+ Review zig-zag density (before & after duration finalized)
				+ Test:
					+ Lightning above top
					+ Lightning touching well below
				+ See how to make bg lightnings visible during storm
					+ Just less clouds? NO
					+ Render: if exist background lightnings, draw last X clouds afterwards
		+ MainFrame: disable menu during storm
		+ Storm::Parameters:
			+ Given to Wind, who uses its WindSpeed = [0.0 ... +INF] to increase wind in calculations
				+ OceanSurface: gets in indirectly and makes waves
			+ Given to Clouds, who uses its StormMagnitude for darkness of clouds
				+ Param at shader, passed to RenderContext at RenderContext::UploadCloudsStart(...) via new "CloudDarkness" float param
					+ RenderContext::UploadCloudsStart: only sets param when val != mCurrentCloudDarkness
				+ Shader
		+ Wind volume: start with storm
			+ Need additional arg to wind event
		+ Manual storm trigger
		+ Manual lightning trigger
		+ Storm: complete auto-triggering
		+ StormStrengthAdjustment:
			+ GameParameters
			+ Use at Storm for:
				+ Replacement of StormMaxWindSpeed
					+ Make max wind smaller at Adjustment=Max
				+ Adjustment to rain density
					+ Change shader
				+ Adjustment to darkening
				+ Adjustment to lightning and thunder rates
			+ Also include ultra-violent mode
		+ SettingsDialog:
			+ All interesting parameters
			+ Verify saved
		+ Rain extinguishes fire and dissipates heat
			+ Do personality seed work:
				+ Points: RandomPersonalitySeed
					+ At Add(), passed from outside
					+ Also use at other places where we need a per-point random number
			+ Combustion state machine: rain extinguishes fire
				+ Smothering is too fast: try with consumed instead of smothering, or add SlowSmothered
			+ Heat dissipation
		+ Cleanup:
			+ If StormRate is OK in minutes, make it also for tsunami and rogue wave
			+ See perf at Lightning hit when UltraViolent on
				+ Destroy vs. Heat: it's Destroy
				+ Destroy:
					+ Detach: 10%
					+ Sparkles: 70%
						+ CreateEphemeralSparkleLightning
							+ Reduce reset quantities
							+ Run in debug and verify
							+ See if may agglomerate buffers for ephemeral particles
								! Baseline: >= 3000 bubbles: FPS = 23.8-24.something
								+ Now: >= 3000 bubbles: FPS = 24.something-25.something
						+ Rendering: 0%
					+ Notify: NO
			+ Do perf analysis - Andrea Gail slows down a lot
				+ Also give crash to MS
	+ Explosive combustion:
		+ To be done after new explosions
		+ New materials:
			+ "Gunpowder":
				+ Takes-in water
			+ "Diesel"
				+ Doesn't take-in water
		+ Make test ship
		+ Modify combustion state machine
			+ At ignition check loop:
				+ Store combustion type in buffer
				+ Identify top N (=6? Local constexpr) candidates; conditions:
					+ Temperature threshold
					+ and: not wet (smothering watermarks)
					+ Do not care about UnderWater (that's for ignition)
				+ StartExplosion each, with:
					+ Radius, Strength: formula over IgnitionTemperature (the higher, the stronger), "just because"
					+ Heat: uses CombustionHeatAdjust
						+ Does it need combustion heat constant currently used at combustion update to generate heat to neighbors?
						+ Make it a (constexpr) GameParameter
						+ So at the end, heat of explosion is same generated by combustion
					+ Type: Combustion
				+ Transition to new state:
					+ Exploded
			+ At state update:
				+ Ignore
			+ At render:
				+ Ignore
		+ Need Point::Restore
			+ Invoked by repair tool
			+ Resets combustion state machine
				+ Test w/Repair
		+ Do new game event handler, OnCombustionExplosion
			+ Additive (just like bombs)
			+ New sounds x {underwater, size}
		+ Test UltraViolent mode
		+ Cleanup:
			+ Nail down top N candidates
			+ Make new structural materials template
			+ Finalize "Flawed Design" (or "Imminent Disaster"?)
				+ Name, Description
	+ Smoke ephemeral particle emitters
		+ Add ThermalExpansionCoefficient to all materials
			+ Points::Buffer
			+ All materials have it almost as zero (use real)
			+ Air, hydrogen have own
				+ Test blimp filled with hydrogen
					+ Change external structure to something light, e.g. cloth
			+ Add to Guide
		+ UpdatePointForces: if any point is above water, apply air buoyancy (*)
			+ i.e. always end up applying one buoyancy, either water or air
			+ Any buoyancy depends on temperature of particle and on temperature of "ambient air"/"ambient water"
				+ Use ThermalExpansionCoefficient at both buoyancies
				+ Pre-multiply with gravity
		+ See if want to do heat dissipation also on ephemeral particles
			+ So that "frozen" air bubbles start floating again
		+ See perf impact: 29.4 FPS (1 FPS lost!)
		+ Another type of electrical material: SmokeEmitter
			+ ParticleEmissionRate
			+ Add to DB
		+ ElectricalElements::UpdateSinks(...)
			+ Run state machine and eventually invoke Points::CreateSmokeEphemeralParticle
				+ Conditions:
					+ Not destroyed
					+ Connected
					+ Not underwater
				+ Calculate next emission timestamp when needed
			+ Points::CreateSmokeEphemeralParticle:
				+ Create particle of Air (just like AirBubble), but at high temperature
			+ Points::UpdateEphemeralParticles: Smoke
			+ Points::RenderEphemeralParticles: Smoke
				+ For now, just point - like debris
		+ Do test ship
		+ Run in Debug
		+ Optimize ship's UpdateHeat::springOutboundHeatFlows
		+ Rendering: Simple texture (one of N alternatives) via GenericTextures
			+ Alpha and scale change with progress
			+ Finish scale function
			+ Nail down database's world dimensions
			! "Violent" smoke params:
				! Emission rate: 0.05
				! scale: 1.07f * (1.0f - exp(-3.0f * progress));
				! alpha: SmoothStep(0.0f, 0.05f, progress) - SmoothStep(0.85f, 1.0f, progress);
				! "worldWidth": 48.0, "worldHeight": 48.0
		+ Expire smoke ephemeral particles that end up underwater
		+ Cleanup (if everything's fine):
			+ Add particle_emission_rate to Guide
			+ StructuralMaterial: "waterVolumeFill" -> "buoyancyVolumeFill"
				+ json
				+ Materials.*
				+ Guide
			+ Add smoke emission rate adjustment global param
				+ SettingsDialog
			+ Add smoke maxlifetime adjustment global param
				+ SettingsDialog
				+ Make scale independent from adjustment
			+ Try white smoke
			+ Do smoke emitter at Titanic with Lights
			+ BuoyancyCoefficients: make them float, using gravity magnitude, and multiply with gravity dir at use time
			+ Try to replace bomb fuse smoke with real smoke particles
				+ Do "violent" emission, use scale formula above
				+ Test (with sound)
				+ Nuke old textures
			+ R.M.S. Titanic with Lights
			+ Redo materials templates
			+ Add diesel to both titanics
			+ changes.txt:
				+ Hydrogen to explosive materials
				+ Air buoyancy and its relationship with temperature
					+ Hindenburg update
				+ New SmokeEmitter material
					+ Cruise Vessel, Titanic update
	+ Switches:
		! Spec:
			! Two new electrical material types:
				! Interactive switch
					! Controlled by user
				! Water sensing switch
					! Controlled by water
			! Color trick like ropes to have unique and deterministic IDs for switches
				! One material (base structural color) for initially on and another one for initially off
					! Property: conducts_eletricity, just sets the default value
			! New electrical property: ConductsElectricity, bool - used at connectivity visit
				! Lights, Cables, Generators have it as true (also in ElectricalMaterial and in json)
				! Switches have it as true or false depending on whether switch is "on" or "off"
					! The act of switching ("Toggle...()") toggles the boolean
		+ Electrical materials:
			+ Two new types:
				+ GameType enum
				+ Interactive switch
					! Controlled by user
				+ Water sensing switch
					! Controlled by water
			+ New electrical property: ConductsElectricity, bool - used at connectivity visit
				+ Lights, Cables, Generators have it as true (also in ElectricalMaterial and in json)
				+ Switches have it as true or false depending on whether switch is "on" or "off"
		+ GameTypes:
			+ ObjectId overhaul:
				+ ObjectId is unique only in the context in which it's used (e.g. bombs vs switches)
				+ ObjectId == <ShipId (new GameType alias, uint32_t w/ None), LocalObjectId (uint32_t)>
					+ LocalObjectId is provided by caller
					+ ObjectIdGenerator only provides helper for globally unique - with no guarantees - or should go
				+ All ship ID ints become ShipId
				+ All object ID ints become ObjectId
			+ LocalSwitchId typedef (uint32_t)
			+ SwitchId == ObjectId<LocalSwitchId>
			+ SwitchState enum (mapped to bool)
		+ Ship json adds optional names for each ID
			+ as vector<std::string>
		+ ShipBuilder detects all switches as electrical elements
			+ Instance ID is from color code
			+ Checks for duplicate instance IDs - errors out if duplicate found
			+ Instance ID is only used to match with ship's switch names from json (or to make default label when no label specified),
			  then each switch gets name as part of Electrical Elements data communicated to ship
				+ If label not present -> "Switch <instance ID>"
				+ ElectricalElements::Add now also takes std::string label
				+ ObjectId is implicit and not specified now (local ID is index in container of switches's ElementIndex within ElectricalElements)
		+ Electrical dynamics:
			+ ElectricalElement has new "conductsElectricity" buffer
				+ ~ Material (init'd with material's) and "current", in same struct (~ double "Switch")
				+ cctor: value of material's x 2
				! ElectricalElements::UpdateSourcesAndPropagation automagically considers it as it is now in the connectivity graph
			+ GC->World->Ship->ElectricalElements::SetSwitchState(SwitchId, SwitchState)
				+ Checks if state different than current
				+ If so:
					+ Sets conductsElectricity
					+ Then updates ConductingConnectedElectricalElements (see below)
					+ Then fires OnSwitchToggled(SwitchId, new state) event
		+ ElectricalElements connectivity:
			! Most performing approach is to alter connectivity graph with switch toggles
			+ mConnectedElectricalElementsBuffer: stays as is, i.e. structural connectivity
				+ Changes with structural changes only:
					! Point destruction: just mark as deleted, as springs have been destroyed already
						! assert
					! Spring destruction: remove s.endpoints from each other *iff both A and B are electrical elements*
						! Do via ElectricalElements::RemoveConnectedElectricalElement
					+ Point restore: just clear deleted flag, as springs will be restored later
						+ Do via ElectricalElements::Restore(idx)
					+ Spring restore: add s.endpoints to each other *iff both A and B are electrical elements*
						+ Do via ElectricalElements::AddConnectedElectricalElement
			+ mConductingConnectedElectricalElementsBuffer:
				! Intersection of mConnectedElectricalElementsBuffer and mConductsElectricityBuffer:
					! For each electrical element A: A.ConductingConnectedElectricalElements contains B iff:
						! A.ConnectedElectricalElements contains B
						! AND A.ConductsElectricity
						! AND B.ConductsElectricity
				+ Changes with:
					+ Structural changes:
						+ Point destruction: <nothing, as springs have been destroyed already>
							+ assert
						+ Spring destruction: remove s.endpoints from each other *iff both A and B are electrical elements*
							+ Do via ElectricalElements::RemoveConnectedElectricalElement
						+ Point restore: <nothing, as springs will be restored later>
							+ Do via ElectricalElements::Restore(idx)
						+ Spring restore: add s.endpoints to each other *iff both A and B are electrical elements*
						  AND *iff A.ConductsElectricity AND B.ConductsElectricity*
							+ Do via ElectricalElements::AddConnectedElectricalElement
					+ ConductsElectricity changes (i.e. @ SetSwitchState):
						+ F->T: for each elem B in ConnectedElectricalElements such that B.ConductsElectricity:
							+ Add B to this.ConductingConnectedElectricalElements
								+ assert not already in
							+ Add this to B.ConductingConnectedElectricalElements
								+ assert not already in
						+ T->F: for each elem B in ConductingConnectedElectricalElements such that B.ConductsElectricity:
							+ Remove B from this.ConductingConnectedElectricalElements
								+ assert already in
							+ Remove this from B.ConductingConnectedElectricalElements
								+ assert already in
			+ ElectricalElements::UpdateSourcesAndPropagation: only consider ConductingConnectedElectricalElements
				+ Make ConnectedElectricalElementsBuffer private
			+ Test repair
				+ Fix repair:
					+ Repair point if it's in a "bad state"
					+ Keep also count of repaired points
				+ Generator doesn't get repaired
				+ Leaking at times doesn't get repaired
			+ Fix repair problem: springs::Restore adds connected electrical elements, but these are deleted
			  and won't be undeleted unless point is restored
				+ Where we restore elec connections now: only do for !Deleted electrical elements
				+ At ElectricalElement::Restore: also here restore (eligible) connections
		+ Repair: move eligible points' restore flat into radius points
			+ i.e. not subject to session constraints
			+ Test before and after
		+ Water switching: at Ship::<UpdateElectricityPhase>::UpdateAutomaticElectricalConductivity()
			+ Uses list of elements (which included water-sensing switches) for perf
				+ mAutomaticSwitches
			+ If current conductsElectricity==material's && water > high watermark:
				+ SetSwitchState(!current)
			+ Else if current conductsElectricity!=material's && water < low watermark:
				+ SetSwitchState(current)
			+ Test water switching
				+ See why light is always on
			+ Finalize high/low watermarks
		+ New game events:
			+ Ship::cctor invokes ElectricalElements::AnnounceInteractiveElements(GameEventDispatcher &)
				+ New IGameHandler: "electrical"
					+ Also includes lights fizzling
				+ Visits switches among ElectricalElements and fires OnSwitchCreated(SwitchId, name, type, state)
					+ state is current value of ConductsElectricity (i.e. still from electrical material)
			+ Ship::ElectricalElementDestroy/RepairHandler's fire OnSwitchEnabled(SwitchId, false)
				! Also clears (on destroy) ConductsElectricity
					+ Thus see if may avoid checking for deleted at UpdateElectricalPropagation
			+ Ship::ElectricalElements fires OnSwitchToggled(SwitchId, new state) at:
				+ 1) ToggleSwitch(SwitchId switchId)
				+ 2) Water-sensing switching - which is done at ElectricalUpdate()
					+ But invokes ToggleSwitch(.) anyway
				+ state is new value of ConductsElectricity, i.e. after the toggle
		! MainFrame gets switches via AddSwitch event, with all metadata (SwitchId, name, type, state)
			! SwitchBoard panel (see below)
				! Registers as event listener at cctor
				! Uses GameController (own shared ptr) :: SetSwitch(SwitchId switchId, state) to control switches
					! Water-sensing switches are not controllable, they just provide feedback
		+ MainFrame:
			+ Also registers for AddSwitch and shows SwitchBoard on first add
				+ As long as UIPreferences::AutoShowSwitchBoard is set (default=true)
			+ Hides it again only at Reset()
		+ SwitchboardPanel:
			+ MainFrame menu pops it up and down (and MainFrame also pops it up automagically at first switch add, see above)
			+ Has control to hide it back (kinda like "close" button at top-right corner)
			+ ShipInteractiveSwitchControl: much like slider, button (w/2*2 switch images, via cctor) with label below
				+ Has state (SwitchState mCurrentState)
					+ Purely for drawing
				+ May be disabled/enabled (via SetEnabled(isEnabled) override), making it grey and non-functional
				+ User-generated toggle event is via lambda(SwitchId, new state)
				+ Exposes SetState(enum) and ToggleState() for externally-generated toggle events
					+ Does not invoke lambda in this case
				+ Images:
					+ {on, off} X {enabled, disabled}
				+ Tooltip displays keys (whose labels are provided by creator via cctor)
			+ ShipAutomaticSwitchControl
				+ Merge two switch controls into one - base and two derived classes; both expose:
					+ SetEnabled
					+ SetState
				+ ...nuke all the "casting switch(type)" from panel
				+ Images:
					+ {on, off} X {enabled, disabled}
			+ Floating/Docked state machine:
				+ Fix stack overflow issue
				+ Test with EventTicker/ProbePanel on
			+ Panel: much like ProbePanel
				+ Has:
					+ ResourceLoader const & (used @ cctor only for button images)
					+ GameController (see others for shared_ptr or &)
				+ Registers as event listener
					+ Processes IGameEventHandler::OnSwitchCreate/Delete
					+ Processes IGameEventHandler::OnSwitchToggled(ObjectId, new state)
					+ Processes Reset() to delete all
				+ Has unordered_map<ObjectId, SwitchInfo>
					+ SwitchInfo:
						+ uq_ptr<SwitchControl>
						+ bool IsEnabled
				+ OnSwitchCreated:
					+ Create uq_ptr<SwitchControl(key)>
						+ Does the mapping here from switch type to images and class
					+ Add SwitchInfo to map
					+ Add to panel - center-aligned, overflow and grow
						+ json:
							"electrical_panel":{
								"0": {"panel_x"=-1, "panel_y"=0, "label"="Test 1" },
								"1": {"panel_x"=0, "panel_y"=0, "label"="Test 2" }
							}
							+ ShipMetadata::ElectricalPanelMetadata
								+ x, y, label
								+ Move from definition's to ShipMetadata
							+ Verify (at ShipBuilder::CreateElectricalElements):
								+ No dupe instances (done by json already?)
								+ Exist instance key for each metadata
							+ Passed to ElectricalElements::Add as std::optional
								+ Which stores it in  mInstanceInfos (own struct w/ instance ID and epMD) and later uses it
								  for announcements
						+ Announcement:
							+ OnElectricalElementAnnouncementsBegin/End
							+ Switch and PowerMonitor announcements take extra:
								+ ShipMetadata::ElectricalPanelMetadata
						+ Panel:
							+ OnElectricalElementAnnouncementsBegin: clear maps
							+ On...:
								+ Make label if no panel element metadata, then pass to control
								+ Store ctrl and panel MD in ElementInfo
							+ OnElectricalElementAnnouncementsEnd: do positioning for all
								+ Layout algo in LayoutHelper
								+ AddControl(ctrl, x, y)
						+ Nuke PowerMonitor extra map and add type to map element (own enum)
						+ Change CircuitTest's electrical:
							+ 1: SingleSwitch (just rename of current): single instance at center, 1st row, no metadata
							+ 2: <normal>: Add switches w/whole json
				+ OnSwitchEnabled:
					+ Enable/Disable switch control
					+ Enable/Disable in SwitchInfo
					+ Leave in map
				+ OnSwitchToggled(ObjectId, new state):
					+ Lookup from map and call SetState(new state) on control (regardless of disabling)
				+ Keys:
					+ At layout: if interactive, calc key and store in vector<ElectricalElementId>
					  for key mappings
						+ Make constant w/max elements per row (11)
						+ Ctrl/Alt 1...0
					+ Gets key events from MainFrame when MainFrame does not recognize
						+ OnKeyEvent: returns bool for processed/not processed, so MainFrame can chain
						+ Uses key mappings to figure out ElectricalElementId
						+ On key:
							+ If SwitchInfo.IsEnabled:
								+ Call SwitchControl->ToggleState() -> newState
								+ Call GameController->SetSwitchState(SwitchId, ctrl->GetState())
				+ Gfx:
					+ Grey hint panel
					+ Use wxCustomBackgroundWindow for the switchboard panel, with a (tiled) background
						+ Try with whole panel, rather than with SwitchPanel only
						+ Try other background
						+ Nail down color of text labels
					+ Nail down font size
					+ Test:
						+ Remove hint label
						+ Just change checkbox's graphics
						+ Move checkbox to top right
		+ SoundController::OnSwitchToggled(., new state)
			+ {on, off} x {3} sounds
		+ Gfx:
			+ Do push switch (mechanical)
			+ Do automatic switch: grey, blue, grey (disabled)
				+ Darker blue, but brighter
			+ Do powermonitor: red, green, grey (disabled)
		+ ShipBuilder: do not propagate new materials (switch, etc.) through ropes
		+ Cleanup:
			+ Test electrical panel w/all controls bottom-aligned
			+ See how to avoid lights flickering with plain switch off
				+ Hack: each time a switch is toggled, ElectricalElements::mHasSwitchBeenToggledInStep is set to true
				+ Use it at lamp state machine
				+ It is set back to false after ElectricalElements::UpdateSinks()
			+ See if can avoid flickering at reload of ship w/circuit
			+ See if can avoid weird position of board at initial load
				+ Cleanup GameReset/Announcement sequence
			+ Docking sounds
			+ More intuitive pin
				+ Closer to "Switches" label
			+ Clear TODOTEST's in SwitchboardPanel
			+ Mouse pointer on switchboard
				+ SwitchboardPanel::cctor: SetCursor
				+ See whether tool controller should set it only on canvas rather than on application
					+ ToolController::cctor and Tool::cctor take wxWindow for parent, not wxFrame
				+ Make finger pointer
			+ AutoShowSwitchboard preference saving
			+ Nuke ElectricalElements.h::GetConnectedConductingElectricalElements [if not needed]
			+ Nuke Ship.h::commented-out getters [if not needed]
			+ Sound at open and close
			+ Materials guide:
				+ Add new ElectricalElementTypes
				+ Add new properties:
					+ conducts_electricity
			+ Decide whether SwitchboardPanel should be double-buffered or not
			+ Website: add FAQ for heat settings -> Gabe's blog
		+ Run in Debug
			+ Test panel across loading ships
			+ Test electrical repair
	+ Improve "friction" of sea floor: things don't slide down easily; may be add a slider
	+ Power probes:
		+ Rename: "Monitor"->"Probe" in current code
		+ GameTypes:
			+ First off, tag ObjectId
			+ Add PowerMonitorId
			+ Add Switch types:
				! ToggleSwitch
				+ PushSwitch
			+ Add PowerProbe types: PowerMonitor and Generator
				! Engine has own type, EngineMonitor, see at Propulsion (*)
		+ EventHandler:
			! No enabled/disabled
			+ Add power monitor events
				+ Take ElectricalState
		+ New Instanced Generator electrical material
			+ Add to json, new generator altogether, other is !IsInstanced
			+ ElectricalElements::Add: add both generators to sources, treat both of them equally
		+ New PowerMonitor electrical material - and type
			+ Add to json - IsInstanced = true
			+ ElectricalElements::Add: add to sinks
		+ These ElectricalMaterial's announce themselves as power probes:
			+ PowerMonitor (announcement type 1)
				+ Uses arbitrarily initial state as current state
			+ (Instanced)Generator (announcement type 2)
				+ Uses own state's IsProducingCurrent as current state
		+ Simulation of PowerMonitor:
			+ Make it a sink
			+ Keep cur state at PowerMonitor state machine at ElectricalElements::UpdateSinks() and fire toggle events upon state toggle
		+ Simulation of Generator:
			! IsProducingCurrent is same as announced state
			+ At ElectricalElements::UpdateSources(): fire toggle events upon state toggle
		+ Destroy/Repair at ElectricalElements::Destroy/Repair:
			! Make sure announcement follows when generator is restored and becomes powered
			! Alignment of state::IsProducingCurrent with announced state: it's the same
			+ At Destroy:
				+ Generator: if IsProducingCurrent:
					+ Toggle to false and announce
				+ PowerMonitor: if State says it's on:
					+ Toggle to false and announce
			+ At Restore:
				+ Generator: nothing to do: at the next UpdateSources() that makes it work the generator will start
				  producing current again and it will announce it
					+ assert(IsProducingCurrent is off) // iff guaranteed to be called only when destroyed
				+ PowerMonitor: nothing to do: at the next UpdateSinks() that makes it work there will be a state change
				  and it will announce it
					+ assert(State says it's off) // iff guaranteed to be called only when destroyed
		+ UI:
			+ ElectricalElementControl
				+ InteractiveToggleSwitchElectricalElementControl
				+ InteractivePushSwitchElectricalElementControl
				+ AutomaticSwitchElectricalElementControl
				+ PowerMonitorElectricalElementControl
				+ Redo hierarchy
		+ Switchboard:
			+ Register for power probe events
			+ Swap bitmaps:
				+ Current non-interactive becomes power monitor
				+ Also rename pngs
			+ Add power probes to switchboard
				+ Type 1 (PowerMonitor): red/green
				+ Type 2 (Generator): Volt gauge (on continuous value) (new GaugeControl, cctor args are bitmaps, center, 3 angles)
					+ Map ElectricalState to min/max values at SwitchboardPanel
		+ Finalization:
			+ Complete Gauge
				+ IUpdateableElectricalControl
			+ Refresh electrical elements' materials template
			+ changes.txt
	+ Propulsion
		! Requires "Forces Rearc" or "Position-based Springs"
		+ 1 new ElectricalElementType: Engine
		+ 2 electrical materials: engine x {LR/UD}
			+ Need a new engine-specific electrical material property: engine_direction, radiants
		+ 1 new ElectricalElementType: EngineController
		+ 1 electrical material
		! EngineController (telegraph) controls all connected engines, value={-1.0, ..., +1.0}
			! Force that will be imparted is directed along an axis that depend on the control-engine axis and on the direction of the engine
			  material
		+ EngineController announces self as EngineController
			+ And updates use {-1.0, ..., +1.0} values
		+ Engine announces self as EngineMonitor
			+ And updates use {0.0, ..., +1.0} values
		+ Dynamics:
			+ EngineController: API to set value {-1.0, ..., +1.0}
				+ Updates value in state
			+ EngineController state has array of ConnectedEngine={EngineElectricalElementIndex, sin+cos}
				+ Never modified, usage must check for deletion
			+ ElectricalElements::Add*Factory*ConnectedElectricalElement(..., octant)
				+ Invoked only by ShipBuilder
				+ First, if this is EngineController and other is Engine: populates EngineController state
				+ Then invokes AddConnectedElectricalElement(...)
			+ EngineController is Sink
			+ Engine is *not* sink, but Engine (new indices type)
			+ UpdateSinks:
				+ For each EngineController sink that is powered:
					+ For each connected electrical element that is Engine:
						+ Calculate power force vector:
							+ Dir = f(octant, points, MaterialEngineDirection)
							+ Magnitude = f(EngineControllerState::ControlValue)
						+ Add power force vector to Engine::State::CurrentPowerForceVector
						+ Engine::State::CurrentPowerValue = max(
							Engine::State::CurrentPowerValue,
							abs(controller's current val));
				+ Then, for each Engine:
					+ Calculate force=f(State::CurrentPowerForceVector, GameParameters::EngineThrust)
					+ Apply force to point (NonSpringForce)
					+ If Engine::State::CurrentPowerValue != State::LastPublishedPowerValue:
						+ Publish EngineMonitor -> Sound+Panel
						+ State::LastPublishedPowerValue = Engine::State::CurrentPowerValue
						+ Do visual notification if enabled
					+ Reset State::CurrentPowerForceVector
					+ Reset State::CurrentPowerValue
			+ Enable/Disable engine controller upon destroy/create
			+ Engine power should only raise after +/-1, but sound should come at +/-1
				+ unsigned int GameParameters::EngineTelegraphDegreesOfFreedom = 11
					+ static_assert it's odd
				+ Events carry int telegraphValue
				+ Engine power does math to calculate power={0.0, 1.0}
				+ Engine notifications: rpm and thrust
			+ Publish zero value at engine destruction (iff currently not zero)
		+ Adjust thrust
			+ Change circuit test: one single engine now
			+ Add EngineThrustAdjustment
		+ Gfx:
			+ EngineController: Telegraph with hand
				+ N already-rotated hand bitmaps
				+ Mouse events
				+ Key events: back and forth, do not go around
			+ EngineMonitor: RPM Gauge (GaugeControl w/other bg)
		+ SwitchboardPanel:
			+ Handle creations of EngineController and EngineMonitor
			+ Handle enabling/disabling of EngineController
			+ Subscribe to updates of EngineController and EngineMonitor
		+ Sound:
			+ EngineController (telegraph) sound
			+ Engine sound:
				+ Hook volume, pause, reset, etc.; test:
					+ Global mute
					+ Effects volume
					+ Pause
					+ Reset
				+ Fade-in
				+ Add engine_type as new electrical material property
					+ MultiInstancedSound: replace Initialize() with AddSoundType(TSoundTypeEnum, sound buffer)
						+ Stores in unord_map<TSoundTypeEnum, sound buffer>
					+ Communicated at announcement (via ElectricalMaterial)
						+ Stores in unord_map<instance ID, sound type>
							+ ...in MultiInstancedSound, mInstanceIdToSoundType
					+ Start: takes sound type
						+ And another override that takes instance ID, in which case does forced lookup
						  in mInstanceIdToSoundType
				+ Register for EngineMonitor event, only RPM
				+ Simple continuous sound, keyed by object ID
				+ Add pitch controls to Sound
				+ React to EngineMonitor, track object ID and set object's sound pitch
		+ Click on glass of non-interactive elements => IGameController::HighlightElectricalElement
			+ ElectricalElements: concentrate all highlighting @ HighlightElectricalElement(idx)
			+ Highlight
			+ Sound
			+ Cursor ('?')
		+ Make engines conduct electricity
			+ Json: does not conduct
			+ At engine update: conduct_electricity=(rpm > threshold)
			+ Change circuit_test
		+ Fix highlight/last highlighted
		+ Do engines with different properties:
			+ ElectricalMaterial Properties:
				+ Power (in HP)
				+ Responsiveness
				+ Engine Type:
					+ Steam
			+ Different json materials
				+ Use actual HP, not newtons
				+ Outboard
					+ Sound type
					+ Mount on LifeBoat
				+ One more powerful LR steam engine
			+ Store responsiveness and power in EngineState at ElectricalElements::Add
					+ Pre-convert HP -> Newton
			+ Do responsiveness state machine
			+ Nuke GameParameters::EngineThrust
		+ Switchboard panel: display finger mouse pointer only at interactive controls
			+ Set into ctrl from panel
			+ Dockable checkbox too
		+ Make engines lose power progressively when wet
			+ At Engine update: quantity of water determines target RPM damping
				+ e^(-x + 5)/(5+e^(-x + 5))
			+ Mount engine on a new ship for testing
		+ Do wake with very short-lived ephemeral particles
			+ Only if underwater
			+ At EngineUpdate
			+ SettingsDialog:
				+ checkbox for engine wake
		+ Finalization:
			+ Use PI-based constants for gauge angles
			+ Do engine highlight only on 0<->nonzero transitions
			+ Engine produces heat when running
			+ Engine controller stops working at high temperatures
			+ Restore of engine controller
			+ Restore of engine
			+ Do progress at Switchboard constructor
			+ Switchboard: when scroll bar present, must be taller
				+ Add gridbag sizer to a new vSizer member, and add spacer when needed
			+ EngineController: SHIFT for plus/minus
			+ Draw highlights at right plane ID
			+ If the two switch types are physically identical, move switch type as new electrical property
			  and use it only for announcements
			+ SettingsDialog: EngineThrust or Adjust
			+ Ship preview: add electrical icon
			+ Ship preview: add HD icon
			+ Change "Titanic (with Lights)" into "Titanic (with Electricals)"
			+ Add engine_direction, engine_power, engine_responsiveness (and other properties?) to materials' guide
			+ Add all new types to materials' guide
			+ Refresh both elements' materials templates
			+ changes.txt
	+ Different materials have different rotting speeds
		+ For instance, Cardboard would soften and break apart in water within a minute or so
	+ Pinch tool:
		+ "Pick-n-Pull"
		+ Apply spring-like force: Picks a point and keeps setting a Hookeian force on it
			+ State machine (target position, simple recursive function) done by tool
			X If needed applies also a fraction of the force to direct neighbors, or to all points in a radius
			+ Test w/double simulation steps and verify force doesn't change
			+ Converge speed depends on mouse move span (in world coords)
				! The faster the mouse move, the faster the convergence
				+ Tool asks GameController: screenOffset->worldOffset
					+ Need to expose new ScreenOffsetToWorldOffset(.)
				+ Then, formula gives convergence speed
		+ Tool:
			+ Copy from Move tool
			+ Tool engaged only if a point has been picked (like Move tool)
		+ Cursor: pliers or tweezers, up and down
			+ Redo down: make them touch
		+ Sound: just at pick time
			+ Sounds
			+ Wiring (incl. underwater)
		+ changes.txt
	+ Move tool:
		+ Allow for moving orhpaned points
			+ At this moment we avoid that in PickPointToMove, but could allow for orhpaned point if no non-orphaned
			  points are in radius
	+ Pumps
		! Spec:
			! New electrical element type
			! Two types: "in" or "out"
			! Pumps' intake is superimposed to leaking point's intake
				! Point that pump is attached to may or may not be hull, and may or may not be leaking; regardless, when powered,
				  water is sucked in our out
			! Water is taken @ Ship::UpdateWaterIntake()
				! In: as long as external water pressure > 0
				! Out: as long as internal water pressure > 0
			! Continuous sound when pumping
		+ Impl:
			+ Materials: new electrical element type
				+ Property: float pumpNominalForce (< for out, > for in), only de-serialized for pumps
			+ struct Points::LeakComposite: float StructuralLeak (0.0 or 1.0), float PumpNominalForce (-1.0,...,+1.0)
				+ union: int64_t, used for fast "if(is leaking)" check
			+ Test perf
			+ Test destroy & repair
			+ ElectricalElements:
				+ PumpState:
					+ float [const] NominalForce (from cctor: takes material's PumpNominalForce)
					+ float TargetForce
						+ <> 0.0 <=> powered, =0.0 <=> not powered
					+ float CurrentForce
				+ Add(): store as sink
				+ UpdateSinks():
					+ Move IsDeleted check for each type down to its case
						+ See if due to this, we can now put back anything in switch
					+ Pump type:
						+ 1) if ! Deleted: do operating state machine (connectivity, operating temperature) to come up
						  with TargetForce
							+ @ power state changes: emit highlight
						+ 2) smooth CurrentForce towards TargetForce and set Points::LeakComposite::WaterPumpForce
							+ Emit event for pitch and gauge here (exactly like engine's RPM)
								+ See how we avoid at engine to do it when always zero
				+ Announce: as new WaterPumpProbe
				+ Destroy:
					+ Announce
					+ Enough to set Target to zero
				+ Restore:
					+ Announce
			+ Ship::UpdateWaterIntake()
				+ NewWater = <normal is_leaking water, i.e. of StructuralLeak> // before capping
					+ max(
						max(PumpForce * ext.w, 0), // != 0 <=> PumpForce > 0 && ext.w > 0 || PumpForce < 0 && ext.w < 0
						max(-PumpForce * p.w, 0)   // != 0 <=> PumpForce < 0 && p.w > 0 || PumpForce > 0 && p.w < 0
					  )
				+ See if may optimize all those branches
			+ ElectricalPanel:
				+ Gfx:
					+ Gauge with pressure
				+ Announcement
				+ Response to state change
				+ Test w/Circuit Test
			+ Sound
			+ Water Pump Adjust
				+ & Ultra-Violent mode
				+ SettingsDialog
			+ Test
				+ See if need to adjust nominal water pump force
				+ Adjust convergence rate of pump force
				+ Adjust gauge hand angles
				+ Adjust pump gauge bg color
				+ Destroy
					+ Gauge
					+ No working anymore
				+ Restore
					+ Gauge
					+ Working again
			+ Add pump property to guide
			+ Update materials template
	+ Flood doors (*) - really "Powered watertight doors"
		! Spec:
			! New electrical element
			! Point that flood door is attached to may or may not be hull
			! When powered, inverts hullness of point, and water permeability of all attached springs
			! Plays one-shot sound @ when open or closed - much like TimerBomb's defuse
				! No ObjectID needed thus
				! Open sound X n1, Close sound X n2
		+ Impl:
			+ Prep:
				+ Springs::Add() knows nothing about hullness
					+ WaterPermeability set to 1.0
					+ Get rid of Springs::Characteristics::Hull
					+ Replace Springs::Characteristics with simple bool IsRope buffer
					+ Get rid of Springs::Characteristics
				+ Make sure there's no current Points::IsHull
				+ Add Points::IsHull (w/own bool buffer, Get(), and Set()), which will contain externally-computed resultant of
				  flood doors + material
					+ Default @ Points:Add(): from material
				+ Change Points::MaterialIsHull usages:
					+ @ Points::OnDamage: to decide whether or not to make the point leaking
						+ Target: use material's IsHull (kinda arbitrarily)
					+ @ ShipInteractions::Flood: to avoid flooding hull points
						+ Target: use new IsHull (to avoid flooding points on activated doors)
				+ Nuke MaterialIsHullBuffer as usages may directly check StructuralMaterial
			+ Ship::SetAndPropagateResultantPointHullness(pointIndex, bool isHull)
				+ Change Point::Hull and change Spring's::WaterPermeability according to old code:
					// The spring is hull if at least one node is hull
					// (we don't propagate water along a hull spring)
					if (points.GetMaterialIsHull(pointIndexRemap[springInfos2[s].PointAIndex1])
					    || points.GetMaterialIsHull(pointIndexRemap[springInfos2[s].PointBIndex1]))
					    characteristics |= static_cast<int>(Springs::Characteristics::Hull);
					 mMaterialWaterPermeabilityBuffer.emplace_back(
						Characteristics::None != (characteristics & Characteristics::Hull)
						? 0.0f
						: 1.0f);
			+ Ship::Finalize()
				+ Called by cctor
				+ Does multiple things:
					+ Visit all hull points and calls ~SetAndPropagatePointHullness(.)
					+ Current call to detect connected component
			+ New electrical element:
				! Passive, and carries just open/close state
				+ Announcement
				+ State change
				+ Enabled/Disabled
			+ ElectricalElements:
				+ State:
					+ CurrentState (bool): activated (powered) or not
				+ Add: add to sinks; current state=!activated
				+ Redo with electrical element carrying directly open/close instead of activated/deactivated
					+ WatertightDoorState remembers both IsActive and CurrentIsOpen
					+ ElectricalElements::Add takes also Points to determine whether point is hull or not hull (closed/open) at rest
					+ IShipHandler takes directly open or close
					+ Highlight: based on open/close instead of activated/deactivated
				+ Announcement
				+ UpdateSinks:
					+ Do powered state machine
					+ On state toggle:
						+ IShipHandler::HandleWatertightDoorActivated(true or false)
						+ Publish electrical element state
						+ Highlight
				+ Destroy: force toggle to not activated:
					+ State variable
					+ IShipHandler::HandleWatertightDoorActivated
					+ Publish electrical element state
					+ Publish Enabled/Disabled
				+ Restore: probably nothing to do, as next UpdateSinks() will see if it works
					+ Assert currently not activated
					+ Enable/Disable
			+ Ship::HandleWatertightDoorUpdated(pointIndex, bool isOpen):
				+ Calculate target hullness = f(point's material hullness, isOpen)
				+ Invoke SetAndPropagatePointHullness(.)
				+ On Open->Close transition, might also want to dry up point or else existing water there will stagnate
				+ Fire event for Sound
					+ Event is aggregated with size
			+ Electrical panel:
				+ Gfx: open/close/disabled
				+ Announcement
				+ State change
				+ Enable/disable
			+ SoundController:
				+ Open sound X n1, Close sound X n2
				+ Event response (size => volume)
					+ object-agnostic
			+ No real need to also change Point::Buoyancy
			+ No real need to also change Point::IsHull
				+ Points' hullness is only used to decide whether or not to make a point Leak when an attached spring breaks; we
				  leave this determined by underlying structural material
			+ Springs::IsHull should be gone by now
			+ Test:
				+ w/Circuit Test (temporarily)
				+ Operation
				+ Destroy
				+ Restore
			+ Add new type to Materials Guide
			+ Redo electrical materials template
	+ Frontier (*):
		! Only for non-rope points - rope points never take part in frontier
		+ Preliminaries:
			+ Make sure endpoints in triangle are always in CW order
				+ From ShipBuilder
		+ Plan:
			+ Data structures
			+ Initial frontiers at ShipBuilder
			+ Render frontiers:
				+ New render setting
				+ New ship upload
				+ New shader
			+ Maintain at destroy
			+ Maintain at repair
		+ Impl:
			+ Data structures
				+ GameTypes:
					+ FrontierIndex + None
					+ FrontierType enum (External, Internal)
				+ Frontiers class
					! Kinda like 'Points' but for frontiers only; contains data structures (merged in one) and logic
						! Including update and rendering logic
					! Logic that requires points/springs/triangles takes those as args
					+ Owned and maintained by Ship
					+ Structs:
						+ FrontierEdge: contains edge metadata only needed for physics
							+ Cardinality: Edge
							+ NextEdge(..Element...Index?) (index of edges)
							+ Point indices in frontier order
						+ Frontier:
							+ Cardinality: any
							+ StartingEdge(...Element...Index?)
							+ FrontierType
					+ Cctor takes point_count, Springs, Triangles
					+ AddFrontier()
						+ Invoked by ShipBuilder
			+ ShipBuilder: jumpstart algo:
				+	5	6	7
					4	*	0
					3	2	1
				+ For each scan line:
					+ For each flip point (0->1 or 1->0) from left p0 such that p0 does not belong to any frontiers:
						- fId = new frontier ID
						- p = p0; k = 4|0 (depending on flip type)
						- do:
							- Find p' from k+1 to k-1 (CW, %8)
								- If not found: it's an isolated point, go to next flip
							- Lookup <p, p'> in edge map
								- edge map is a purpose-built map, with <p, p'> being a lexicographically ordered key
								- assert is found, unless this is a "pure spring"
							- Make edge belong to frontier fId
							- if p' == p0: break
						- continue to next flip point on same scan line
				+ Fix bug
				+ Tests:
					+ Scan line finds first a chain point, then a triangle
					+ Scan line ends on a triangle vertex followed by a chain point
				+ Cleanup
					+ Remove unused args
				+ Remove ContainsEndpoints are replace with edge map earlier on
					+ EdgeMap gets added to each time we add to springInfos1
				+ Add timings for whole ShipBuilding and for FrontierBuilding alone
				+ Test perf on Dell
			+ Rendering:
				+ Decide whether we want to announce frontier edge size
				+ SettingsDialog flag
					+ Expose via GameController
				+ Frontiers::Upload
				+ ShipRenderContext:
					+ At Prepare() (or wherever we do others), set progress parameter
				+ Shader
				+ Adjust color shift speed w/release build
				+ Do color march differently - by playing with local progress:
				+ Move SettingsDialog checkbox to Debug rendering settings
			+ Maintenance at destroy:
				+ Ship's triangle destroy handler invokes new Frontier::HandleTriangleDestroy
				+ Marks mIsDirtyForRendering
				+ Triangles: points A,B,C indices also (mainly) avail as array
				+ FrontierEdge: also PrevEdge
				+ Debug window
				+ Cases:
					+ 0 frontiers
						+ Test in debug
					+ 1 frontier
						+ Test in debug
							+ Also internal frontier
					+ 2, 3 frontiers
						+ Ext, Ext
						+ Ext, Int
						+ Int, Ext
						+ Int, Int
							+ Same frontier ID, not connected
								+ Frontier type (flood) check
									+ This is done with visiting points, flagging springs (edges)
										+ Make sure that by the time Frontiers::HandleTriangleDestroy is invoked, springs
										  are already consistent with the triangle being gone
											+ Move MaintainFrontier invocation by Ship::HandleTriangleDestroy after springs have been made consistent
											! Destroy dynamics:
												* DestroyPoint
													=> DestroySpring
														=> DestroyTriangles
															=> MaintainFrontier
												* DestroySpring
													=> DestroyTriangles
														=> MaintainFrontier
									+ Test all cases
							+ Different frontier ID
							+ Fix bug wrt "traverse springs"
								+ See implications of not populating traverse springs; check all uses of:
									+ Springs::SuperTriangles
									+ Triangles::SubSprings
				+ Things to remember:
					+ Every frontier that is changed/created is also flagged as dirty (new flag at Frontier)
					+ Each time we change an edge's frontier ID, also make sure we don't screw head - so set it there anyway
				+ Tests:
					+ Thanos' Snap
					+ 1 triangle with 3 lobes
			+ See if it makes sense to clear and restore Triangles' SubSprings - might just leave FactorySubSprings?
				+ If so, do like endpoints (3-array, etc.), respecting CW order
				+ Get rid of Frontiers::Triangles::Edges
				+ Test:
					+ Destroy
					+ Repair (without frontier maintenance)
			+ Maintenance at repair:
				+ Ship's triangle restore handler invokes new Frontier::HandleTriangleRestore
				+ Preliminary work:
					+ Cusp search needs to be done by searching triangles or edges connected to cusp Point
						+ Make do with existing structures @ Springs that track octants
				+ Cases:
					+ Case 3 frontiers
					+ Case 2 frontiers
					+ Case 0/1 frontiers
						+ Propagate 1 frontier
						+ Process cusps
							+ Ext1 != Ext2
							+ Ext1 == Ext2
						+ Handle pathological isolated triangle case
				+ Things to remember:
					+ Marks mIsDirtyForRendering
					+ Each time we change an edge's frontier ID, also make sure we don't screw head - so set it there anyway
		+ Optimizations:
			+ Frontiers::RegeneratePointColors(): only for frontiers marked as dirtyForRendering
				+ Clear frontiers' dirtyForRendering flags afterwards
			+ See if FrontierEdge::PointBIndex is really needed
		+ Cleanup:
			+ Nuke HasRegionFrontierOfType and subst with IsFrontierCW
				+ Test
				+ Remove unused args
			+ Cleanup log lines at Frontiers
			+ Finalize speed for rendered frontier's march
	+ Directional water drag (*)
		! After frontier work
		! Separate into friction and pressure drags: https://en.wikipedia.org/wiki/Drag_coefficient#Concept
		+ Calc force depending on projection of particle's velocity along normal
			+ Try to re-instate square velocity drag
				! Two water drags:
					+ Point-based == friction drag
					+ Surface-based == pressure drag
				+ Split water drag adjustments
				+ Find right coefficients for both
				+ Need to clamp pressure force
					+ So better done after spring/nonspring forces rearc, so expense is minimized		
				+ Test Titanic Before and After
			+ Add new test shape: long
			+ See if should do back-pressure as well
				+ See gliding deifference between with-and without-back-pressure
					+ It does make a difference
				+ Do it right				
			+ See if should halve/lower pressure drag
			+ See if friction drag is needed after all
				+ Useful for impact
			+ Global drag change below
			+ Cloth explosion issue:
				+ Magnitude investigation:
					+ Default ship: max drag force mag=236,799
					+ Cloth: max force=18,910,600
				+ Issue is due to cloth's small mass, which makes force generate an enormous acceleration
					+ Try with linear force
			+ Weaker titanic bottom
				+ Copy to TitanicWithPower
			+ Water drag adjustments:
				+ Allow zero for both
				+ Maximum for friction
					+ Frictional: see below, lava
					+ Adjust if needed to avoid instabilities
				+ Maximum for pressure
					+ Adjust if needed to avoid instabilities					
			+ Final tests/Goals:
				+ Titanic
					+ Breakup
					+ Stern should glide				
				+ Lifeboat running fast and capsizing
				+ Hydrodynamics test
				X Ship falling from sky should break upon impact with water				
				+ Lava settings
					+ See if need to change drag adjustment setting name
				+ Submarine 3000 with anti-matter bomb on tail
			+ Incorporate water density in  drag
				+ pressure
				+ check lava again
			+ Cleanup force rendering x 3
		+ Video
			+ Side-by-side
			+ Titanic, possibly 2X
			+ "A glimpse of hydrodynamics"
		+ Changelist
			+ Also add "recalibrated all drag forces"
	+ See if we still need the high global damp - it affects the parabole traveled by slinged ships, they fall vertically at the end
		+ See with adj==0.5
			+ See if splinter springs dance for too long
			+ If ok: recalc everything so that world feels like with adj==0.5
			+ Cleanup GameParameters.cpp
			+ Cleanup extra logging at Ship
	+ Fishes (*)
		! Spec:
			! Textures: https://oceana.org/marine-life
			! Ideas (Wreno): https://docs.google.com/document/d/1RHF9BC2L19Dcx9YzkBSQ1hdz8Pnxz0vC8R6tj03txr8/edit
		+ Impl:
			+ Base
				+ ViewModel: nuke mVisibleXXX and replace with WorldFocus
				+ WorldRenderContext: param for fish size adjust (much like ship flames)
			+ Basic AI:
				+ Initial placement
				+ Initial state (goal location, state)
				+ Basic state machine
			+ Tail rendering
				+ Progress:
					+ State stores CurrentProgressPhase
					+ Update adds to CurrentProgressPhase and calcs and stores CurrentProgress
				+ Upload progress as "tail" progress
					+ Rename as "TailProgress", also in shader
				+ Shader
					+ Also upload texture coords X boundaries for clamping
			+ Try with third bream, then decide which between first and third to keep
				+ Nuke other psd's, only keep chosen one
			+ Clamp spawning Y
			+ Final state machine:
				+ Fish turning around: simply done with geometry @ Upload
					+ Replace verticalSign with horizontalScale (between -1.0 and 1.0)
						+ Angles and flipping
				+ Round corners
					+ Replace state machine's CurrentPos & TargetPos with CurrentPos & CurrentVelocity (vector),
					  with velocity vector's y component used to update current pos, flattening depending on distance from StartPos or TargetPos
				+ Misc:
					+ Make CruiseSteering an optional<struct> & populate w/emplace
					+ Rename CalculateVelocity as MakeBasalVelocity
					+ See if may make auto-smoothing converge rate variable
					+ Rename fish.Direction as RenderVector
					+ Smooth direction and/or velocity vector constantly towards target
						+ When not in any "Steering" state
						+ See it might actually replace the "Steering without turning" state
					+ Need gravity state machine?
						+ bool IsInFreeFall
						+ In fall:
							+ Water drag inverse
							+ Immediate convergence of direction
						+ High- and Low-watermarks for ocean level, for enter/exit state checks
						+ End of fall: enter panic mode, keeping current (target) velocity; un-panic will do the rest and re-direct towards previous target position
					+ Allow fish in much panic to go out of water
						+ Simply don't consider water surface collision if panic > threshold
						+ Need freefall to allow for initial velocity with y > 0
					+ See whether we still need 2 water surface regimens
						! Confirmed: we hit BigPanic upon freefall re-entry
						+ Might get rid of "panic" one, as long as we don't hit the other one upon freefall re-entry
					+ See texture X coords limits issue
						+ See if it's due to not mipmapping upload
					+ Test freefall after wave
					+ Try with velocity brake @ re-entry being smoothened - with right (high) convergence rate
					+ At beginning of freefall, render direction change is too abrupt: try with auto-smoothing instead of immediate convergence
					+ See center of disturbance issue w/Mako
					+ Higher jump out of water
						+ Try lowering gravity amplification
						+ Try higher watermark for going out of water
					+ Waves at leave & re-entry
					+ Add tail speed and swing width to species
					+ Disturbance (& food): incorporate somehow fish quad size
						+ Move anchor point to species DB
						+ Need to know actual rendered size (texture world scaling factor * render adjust)
							+ FishSizeAdjust in GameParameters
								+ ...and stored by Fishes at Update()
							+ World size in species
								+ Not in Texture DB
								+ Also adjust tailX to be over whole length rather than just half
							+ Fishes passes world size to Render::Upload(.)
						+ FishSizeAdjust:
							+ SettingsDialog
							+ Finalize min & max values
							+ Parameter smoother
					+ Fix bug with fish count increasing
						+ Also make sure everything's fine after reducing & re-augmenting
					+ Test rendering ocean transparency, ambient light
					+ Add one little fish
						+ Fix size and frozen tail
							+ Redo shader
								+ Adjust smoothstep
							+ Fix Mako
								+ With formula
						+ Rearc & optimize shader
						+ Darker
						+ Fix Y overrun: need another clamp
						+ Fix other disappearing fishes
					+ Position update: incorporate dt, so eventually adjust species' speeds
						+ We already had to multiply mako's speed (13) by dt
						+ Verify that speed in json now matches real world
					+ Scale the following with fish size adjustment:						
						+ Radius of interactive disturbance & attraction
						+ Velocity
					+ Add fish speed adjustment
						+ Param
						+ SettingsDialog
						+ Use @ dynamics
						+ Adjust min and max
						+ Change velocities on the fly
					+ Gravity free-fall must not take size adjustment nor speed adjustment into account
					+ aka: Speed adjustment and size adjustment only apply to swimming
						+ Just in MakeBasalVelocity then
					+ Bug: fish becoming above water while steering - does not free fall
					+ World border:
						+ Clamp at spawn
						+ Simple collision check w/immediate bounce, not excluding other collision checks
						+ Check during free falling as well!
					+ Rename size adjust
				+ New algo:
					+ Turning (if isTurning)
					+ Pos update
					+ Panic check X 4
						+ General panic state:
							+ Panic mode needs to slow down
								+ Panic mode slows down and ends when it reaches zero, no target really needed
								+ Re-disturbing sets it back to one
								+ Change shape of slow-down:
						+ Water level: dealing with fish getting over water level (because of waves, etc.)
							+ Solve issue of target position Y: we use current pos - something, but current pos might already be too late
								+ Try clamping it to water level
							+ Far from surface: normal bounce
							+ Close to surface: panic run
							+ Out of water: need new regime with fish falling:
								+ Different position update when depth < 0:
									+ Gravity
									+ X velocity as now, y clamped to <= 0
									+ Tail progress very fast
										+ Rename as "tail"
								+ ...and cut short state machine afterwards, as fish can't swim
								X See if this one suffices without the two explicit "water level" collision checks
						+ Ocean floor:
							+ Do check with head of fish
								+ Since there's no guarantee of world bounds compliance, clamp X
							x Test with small panic
							+ See why panic'd fish doesn't care
								+ Doesn't care when velocity is pointing outside of normal
								+ Do we keep it? Yes
							+ See why speeds up after bounce							
							+ Test also ship collision with sea floor, for Dx change!
						+ Interactive disturbance:
							+ Panic run:
								+ New target position: any
								+ New target velocity/direction:
									+ Direction along radius to disturbance point, but opposite direction
									+ Velocity: panic velocity
										+ Need to change CalculateVelocity: takes direction instead of start & end points
										! Using panic velocity comes for free
								+ Make sure that a second disturbance at the back of the fish just speeds it up
								+ Prevent panic direction from being too vertical
				+ Obstacles rearc as per Moleskine
			+ Try without u-turn at ocean floor
			+ Lower uturn limit width
			+ New target position:
				+ X constraints:
					+ Ensure X direction change
				+ Y constraints:
					+ Not too much y slope (wrt current)
			+ Superimpose sin over movement
				+ Resynchronize sync with tail
				+ Test with more pronounced superimposed sin during panic run				
			+ Tools:
				+ Think of rearc: instead of storing disturbances, act on fishes right away - exactly like we do with ship
					+ Need to reset u-turn
				+ Food/Scare
					+ Icons: 
						+ Food: little can, tilted at rest, rotated w/crumbles when used
						+ Scare: megaphone 45 degrees at rest, w/sound waves when used
					+ Sounds:
						+ Food: shaking powder
						+ Scare: children screaming
					+ Food: 
						+ Set target velocity to direction towards tool; auto-smoothing does the rest
						+ Enter panic mode with distance
						+ See if can make it so that fish jumps out of water - fix issue
							! Issue due to panic away from bounce -> panic towards food -> ...
						+ See if can randomize direction a bit - but not continuously
					+ Scare:
						+ Panic charge should be proportional to tool distance
						+ Ultra-violent mode
				+ Disturbances also from bombs, with large radius
					+ via mParentWorld.DisturbOcean(vec position, float fishScareRadius)
					+ Add TODO item at plan for sprays for bombs to reuse this, with other args
				+ Tsunami: widespread panic
					+ From World::TriggerTsunami, one-shot
				+ Thanos' snap: panic at interfaces
			+ Shoaling
				+ When adding new fish, distribute remaining counts among species according to swarm sizes
				+ Rearc Update() in three parts
				+ Do shoaling only if GameParameters::DoFishShoaling is set
				+ UpdateDynamics(): maintain sorted Xs in vector at position update
				+ Apply fish's max dimension to shoal spacing (which is in terms of bodies)
				+ Main algo:
					= Attempts:
						+ A: My own algo:
							+ A1: Fish.ShoalingVelocity = k*DeltaPos
								+ TargetRenderVector moves to CruiseSteering
									+ Auto-Smoothing always sets CurrentRenderVector to CurrentVelocity.normalise()
								+ Fix bursts
								+ ShoalingVelocity must scale with GameParameters x 2
									+ Also adjust ShoalingVelocity @ GameParameters' changes
									+ Zero out ShoalingVelocity when fish stops shoaling (via GameParameters)
								+ No U-turn check with ShoalingVelocity
									+ ShoalingVelocity is not supposed to change direction
										+ Remove u-turn code
								+ DeltaPos calc'd using new target pos each time
									+ Sum of deltas of shoaling position is normalized and added with weight to target velocity								
								+ Add sliders for Shoal Neighborhood Radius Adjustment and Shoal Cohesion Strength Adjustment
									+ Verify: velocity should be proportional to distance																
							+ A2: Direction change based on neighbours								
								+ If at least one in neighborhood - regardless of being visible or not - has direction opposite
								  to fish's, and its last directionChangeTimestamp (set at UTurnEmplace) is > ours, then we turn
								+ Only changes TargetVelocity, not ShoalingVelocity
								+ Also calculate new target position
								+ Fix mad-uturning with larger radius
									+ Add back age limit on own u-turn
							+ Try ours, with changes we did for guy's algo:
								+ First off, commit
								+ No "direction of vision"								
								+ break after u-turn							
						+ B: guy's algo:
							+ Clone UpdateShoaling altogether
							+ B1: Movement vector
							+ B2: Collision vector (closest neighbour among those closer to fish than spacing)
							+ B3: Cohesion vector (furthest neighbour among those further from fish than spacing)
							+ The weighted sum of the three + target direction determines ShoalingVelocity
								! We do ShoalingVelocity instead of TargetVelocity to avoid spring effect		
						+ C: hybrid
							+ B1, B2, B3, u-turn check like now
								+ No "ahead" check
							+ If there's no furthest, go to lead
								+ Velocity depending on distance
								+ Also do u-turn if lead's current position is behind our current velocity
				+ Ideas:
					+ Derive neighborhood radius from spacing
						+ Then nuke one of the adjustments
						+ Merge calculations
					+ Converge ConvergenceRate to its default at each UpdateDynamics() after using it
						+ We have to do this as shoaling works well with ConvergenceRate set to the value we temporarily set it now to
				+ Sliders
					+ SettingsDialog: rename "Shoaling" to something else
					+ See if we still need Shoal Neighborhood Radius Adjustment
					+ Nuke FishShoalCohesionStrengthAdjustment
				+ Tsunami: no panic when auto-triggered
				+ See if can randomize spacing
				+ Cleanup:
					+ Optimize
						+ Begin:
							+ UpdateDynamics: 8.31% (7.68% self)
							+ UpdateShoaling: 5.90% (5.90% self)
						+ See if can avoid normalize() at 682 using CurrentRenderVector
						+ Update fish.IndexInXVector
						+ Precalc position of head
						+ Shoaling
						+ If not needed, nuke whole sort/sortedbyx/etc
			+ AABB around ships' frontiers, so that fish AI's avoid them
				+ AABBSet class, at Geometry, containing vector and helper methods and helper calculations
				+ World maintains AllShipAABBs
				+ Frontiers::FrontierIndices maintenance
					+ At Add
					+ At Create
					+ At Destroy
					+ VerifyInvariants: all and only Frontier w/value are in FrontierIndices
				+ Ship::Update(): generate all AABBs					
					+ AABBSet: Add: commment on from ships only
					+ Do AABB buildup
				+ Rendering at World::Render
					+ Upload to RenderContext -> WorldRenderContext
					+ SettingsDialog checkbox
					+ Shader
				+ Run in debug
				+ Fishes::Update(.) takes AllShipAABBs
					+ First update of Fishes at World initialization takes empty AABB
					+ AABB collision check:
						+ If cur pos within any AABB (with margin), and target vel towards: bounce target vel
							+ Basically, just copy BounceOceanFloor
				+ Avoid spawning in AABBs
					+ Split: ChoosePosition and FindPosition
					+ Also avoid spawning underneath ocean floor
				+ Test "sudden appearance of AABBs" at ship load, which happens _after_ initial Fishes initialization
					+ If really bad, consider nuking initial Fishes initialization			
		+ Test:
			+ 0-depth ocean
			+ All sliders
		+ Cleanup:
			+ ShoalSpacing should be from fish species database
			+ Fix initial spawn position: center of gaussian should be at the center of the half-screen at start of direction
				+ Ensure first cruise of ship is "long enough", i.e. that fish doesn't u-turn right away
			+ Larger field for spawning and next position?
				+ Unify variances anyway
			+ Finalize GameParameters::NumberOfFishes
			+ Do we need initial Update() call at World construction?
				+ Better to spend time for fish creation there than at first frame
		+ Misc:			
			+ See if want to spread initial fish more
			+ More textures per species
			+ More fish species
			+ SettingsDialog:
				+ Number of fish
				+ Fish size multiplier
				+ Do shoaling flag
				+ Shoal sspacing adjust
			+ See if can improve fish swimming above ocean surface
			+ Optimize shoaling by only looping through fish's shoal, rather than all fishes
				+ Start: 38/39ms
				+ End: 3ms
			+ Fish scared by some ship sounds:
				+ Klaxon, Fog horn
				+ With initial delay
					+ World::DisturbOcean takes Delay (wall-clock time)
					+ Fishes::Interactions: vector
				+ Test:
					+ Manual x 2
					+ Bomb
					+ Tsunami
					+ Destroy
					+ Thanos
			+ Freefall:
				+ Lower gravity multiply, and
				+ Use velocity multiplier when in freefall
				+ See also if need to lower low watermark (smaller freefall band)
			+ Other scares:
				+ Lightning strike
				+ AM bomb pre-implosion
				+ AM bomb explosion
			+ Recalibrate Mako
				+ Swimming speed
				+ TailX and swing
			+ Fix disturbance and attraction radius
				+ Disturbance
					+ Re-check all radii
						+ Lightning
						+ Bomb
						+ Tool
						+ Thanos
				+ Attraction
					+ Re-check all radii
						+ Tool
			+ Remove fish update time @ notification layer
				+ If it's negligible on Dell
			+ Initial placement of fish in a shoal should obey shoaling spacing
	+ Rot tool: rots without having to flood it
		+ Then merge scrub tool into this one, with SHIFT
		+ Icon:
			X https://cdn0.iconfinder.com/data/icons/poison-symbol/66/22-512.png
		+ Sound
			+ More immediate start
		+ Dynamics:
			+ Abovewater should rot less
		+ Test:
			+ With no effect volume
	+ Waves from ship (*):
		! Spec:
			! Physics:
				! For each underwater frontier point:
					! Ocean surface disturbation proportional to:
						a) Velocity of point (its vertical component only)
						b) Depth of point 
						c) May be: normal of frontier at the point
			! Computation:
				! Done at frontier visit in ship, by simply accumulating delta's in OceanSurface
				! These delta's will then be materialized into real surface y's at the next OceanSurface::Update (after being smoothed via a low-pass filter)
					! Yes, this generates a lag between the ship entering the water, and the surface moving for it, but we hope it won't be noticeable
					! With this deferred scheme though, we have the following pro's:
						! Not having to recalculate cached point depths
						! Not having to materialize ocean surface delta's at each *ship*'s Update() (we can do it once for all ships, and at OceanSurface::Update() which is more adept)
						! All frontiers in all ships still get to see the original surface, and thus there's no risk of one affecting the next
							! However, we might not want delta's to be cumulative. For example, if CC 1 sees y=0 and makes delta=-3, and CC2 sees y=0 and makes delta=-2, we might not
							  want to end up with delta=-5. See if should use a "max" thing instead
		+ Impl:
			+ Step 1: basic
				+ Simple, immediate adjustment of surface height
					+ Requires temporary method from OceanSurface (& world)
			+ Step 2: delta's incorporated at next update
				+ OceanSurface: mHeightFieldDeltas buffer
					+ Simply a buffer of samples
						+ Make it part of SWE
							+ Make it a FixedBuffer
								+ Clear it in cctor with fill()
									+ Verify assembly
							+ Make its size==SamplesCount+1
					+ Materialized into samples during UpdateFields()
					+ Then zeroed out at end of UpdateFields(), so it's ready for the next cycle
				+ Wave generation:
					+ pointDepth (capped) * (1 - Smoothstep(0, maxDepth, depth)) // no velocity here, velocity influences maxDepth already
			+ Step 3: add smoothing
				! Smoothing is needed: it removes little spikes (exactly the same spikes we used to get with bubbles)
				+ constexpr constant gives width of smoothing, so we may experiment
					+ Make delta buffer size==SamplesCount + 2 * (DeltaSmoothingWidth/2) // or just +(DeltaSmoothingWidth/2), depends on whether we need right part or not
			+ Step 4: nail down displacement calculation
				+ Temporarily alter UpdateFields() to use DeltaHeight buffer directly, without SWE and with/without smoothing
				+ At small velocities, displacement should be greater
					+ Plot displacement by velocity
					+ Find curve
						+ Piecewise quadratic + linear
				+ Incorporate mass, so that light wooden ball doesn't create as many waves
					+ Smaller masses should have slightly more impact			
			+ Perf:
				! Do not optimize mass calculations, are we only need to calc for those points that are
				  in frontier - as opposed to *all* points if we were doing it at UpdateMasses()
				 + Pre (20s. +10->):
					+ ApplyWorldForces: 1.67%
					+ OceanSurface::Update: 0.55% (UpdateFields: 0.51%)
				+ See abs vs intrinsics
				+ OceanSurface: DeltaBuffer smoothing:
					+ Vectorize
						+ Attempt 1: by compiler, with restrict
							+ OceanSurface::Update: 0.52%
				+ Ship: Displacement:
					+ Do benchmarks for various Heaviside "if" steps
					+ Formulas optimization:
						+ Try replacing sqrt(mass) with linear law
						+ Others, with PlotLab
				+ Post:
					+ ApplyWorldForces: 1.60%
					+ OceanSurface::Update: 0.53% (UpdateFields: 0.51%)
			+ Cleanup:
				+ See if can get rid of "displace small scale" function, and use delta-buffer instead
					+ Already verified that small spikes caused by single-sample displacement go away when distributing the displacement among the two adjacent samples
					+ @ Fishes x 2 (entering freefall, leaving freefall)
					+ @ AirBubble surfacing
				+ Name of method to populate deltas
				+ Make y offset the same between two Titanic's			
			+ Other wave generations:
				+ Ship::Explosion state machine (above or below)
				+ ElectricalElement::Engine
					+ Honor flag from settings
			+ See if can recalibrate Lifeboat
			+ Settings:
				+ Flag to turn off - everywhere
					+ ApplyWorldForces becomes templated on boolean
					+ Also applies to Ship::UpdateExplosionStateMachine
				+ Displacement Wave amplitude adjust - only applies to ship (& engine may be?)
					+ Test min & max
				+ SettingsDialog
			+ Test more displacement at fish
			+ Final tests:
				+ Check disappearing field issue
				+ Test in Debug build
					+ Displacement at middle of world
					+ Displacement close to both ends of the world
				+ Perf tests on old dell
					+ Before=30.0/30.1 after=30.5
					+ Explosion 
					+ Engine 19.3/19.4 => 
		+ Changelist
	+ Look back at SWE's (*)
		X Try re-instating skipped steps - just redo original implementation (two buffers, etc.)
		+ Other SWE ideas:
			X Flow limited to avoid chequerboard oscillations (cell draining completely and then back)
			+ Inertial formulations:
				= http://catalytics.asia/wp-content/themes/catalytics/flood/Bates%20et%20al%202010%20new%20lisflood.pdf (1) improved at https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2011WR011570 (2)
				+ Implement second formulation in (1): OK
				+ Implement q-centered in (2): OK
				+ Find right params:
					+ q-centered model:
						+ Theta = 0.8f;
						+ n = 0.1f;
			+ Cleanup:
				+ UpdateFields, w/comments
			+ Nail down parameters:
				+ Interactive state machine
					+ More max height
					+ Better delay curve
						+ Less delay at small delta heights => try again with Smoothstep
				+ Tsunami
				+ Rogue wave
			+ See if the removal of hf is making the wave evolution asymmetrical
				- No - remove hf again
			+ Make less rigid - try to make waves bounce back
				+ Play with fixed height
				X It's not friction (actually friction might be zero, see below)
				+ Play with theta - new setting ("WaveSmoothness" or find better name in paper) & SettingsDialog
					+ 0.95, friction 0.5: nice bouncing, but weird vertical offset stays
					+ 0.953, friction 0.25: nice bouncing, small weird vertical offset
					+ 0.953, friction 0.15: nice bouncing, no weird vertical offset, stable - BEST
					+ 0.922, friction 0.15: little but visibile bouncing
					+ 0.172, friction 0.005: no bouncing, no instabilities, wave stays round, but asymmetric
					+ 0.906, friction 0.005: small bouncing
					+ 0.984, friction 0.005: repeated bouncing, dying off soon; tall waves become unstable
					+ 1.0, friction 0.005: repeated irregular bouncing
					+ 0.984, friction 0.1: repeated bouncing, dying off soon; tall waves become unstable
					+ 0.891, friction 0: negligible bouncing, wave is steep
					+ 0.844, friction 0: negligible bouncing, wave is almost triangular
					+ 0.8, friction 0: negligible bouncing, wave is reasonably round
					+ 0.5, friction 0: no bouncing,  wave stays round, no instabilities
					+ Might be best to temporarily set decay rate to zero to better see the effect here
					+ At end:
						+ Decide decay rate of interactive
						+ Make rising slope of interactive less steep, tsunami is quite nice
			+ See what's going on with rendering at far zoom
				X See if repros with basic shader
				X Try with squared, as in experiment
				+ Remove dFdy at basal width, it's useless anyway
				X Analyze derivatives
					+ Hardcode in shadertoy shader and play with it
					X Try with that new shader
				X Tan trick?
				X See if may change how we upload
					X Upload avg of three derivatives
				+ Try:
					+ Back to world coords
					X 1: with shader-calculated derivatives:
						float borderWidthHalfFront = (basalBorderWidth + abs(dYFrontWorld)) / 1.2;
						float yFrontMidBorder = yFrontWorld;
						float borderFront =
							1. - smoothstep(0., borderWidthHalfFront, abs(yWorld - yFrontMidBorder));
						X 1b: if OK: see with code-calculated derivative instead						
					+ 2: Try "double-shader" + second derivatives
						+ Go back to all shaders working on World
						+ Shadertoy PoC
						+ Implement second derivatives
							+ Infrastructure
							+ Second derivatives
								+ Zoom-out case
									+ Fix problem with top y
										+ At buffer upload: fixed world offset									
									+ Do other planes
										+ See if other planes really need derivatives: NO
										+ Remove derivatives
								+ Zoom-in case
									+ See if can really leave derivatives at zero
								+ Fix bug in upload code w/fractional part from next sample
								+ Optimize
									+ Upload code
										+ Fix DEBUG issues
											+ Redo NumSlices, DX
											+ Also @ OceanFloor
										+ Verify assembly
					+ Cleanup shader
					+ Test all rendering modes
						+ {Basic, Detailed } x 3 render modes x {far, close}
			+ Split UpdateFields:
				+ SmoothDeltaBufferIntoHeightField
					+ As-is, for the time being
					+ Also clears at end					
				+ UpdateFields: just SWE loop
					+ Optimize:
						+ pow
						+ Pre-perf: 4.59/4.60
						+ See if friction is really needed - setting it to zero seems to have no effect
							+ Waves stay stable with smoothness at 0.8
						+ See if best to store velocity field or Q field
							+ Rename everything as Q/flux
							+ Write alternative - and verify it works - using velocities
							+ Also, if we go for Q field, be careful - height and velocity/Q are at different places in the cell
						+ Optimize
						X Check if may be vectorized
							X See first if all works fine with separate-time buffers 
							X See two-pass
						+ Post-perf: 4.57/4.58
			+ Vectorize SmoothDeltaBufferIntoHeightField
				+ Pre-perf: 4.57/4.58
				+ 1: Move current algo to Algorithms as Naive
				+ 2: Naive unit tests
				+ 3: Make version with x86 intrinsics in Algorithms
				+ 4: x86 instrinsics unit tests
				+ 5: Hook up into OceanSurface
					+ Do alignment: use Buffer
						+ DeltaBuffer
						+ Both SWE buffers
							+ Nuke FixedSizeVector usage completely
							+ See if +1 @ SWE buffers is still needed
					+ Invoke Algorithm
					+ Verify 
						+ Works
						+ Assembly
				+ Post-perf: 4.57
			+ SetSWEWaveHeight: see if can be replaced by populating deltabuffer
				X Every caller (state machines only?) need to start reasoning in terms of delta's then, rather than absolute heights? 
				+ Nuke SWEWaveStateMachinePerturbedSamplesCount
			------------------------------
			+ Bump up rate of rogue waves
			+ Interactive state machine: try with bouncing waves
			+ See if wave displacement can now be slightly more pronounced
				+ Keep an eye on infinitely-bouncing balls
				+ See if adjustment may move to:
					X Simply multiplier
					+ Slope
			+ See if may increase:
				+ Fish displacement
				+ Bubble displacement
				X Engines
			+ Decide whether to keep or not WaveSmoothnessAdjustment in SettingsDialog
				+ If so: find right Min/Max range - keep an eye on preventing unstable waves
	+ Pressure implosions / pressure crush (*)
		! Requires frontier
		! Better done after cached quantities - underwater depth (*)		
		+ Plan A: simple: inward forces on (ext and int) (non-leaking) frontier points based on external pressure (density*depth*g) at that point
			! Con: does not consider internal pressure/water
			+ Phantom forces:
				+ Verify rotation happens always around *geometric* center, not around *mass* center
					+ Calc center as first step
						+ Break up ApplyWorldForces first:
							+ ApplyWorldParticleForces
							+ ApplyWorldSurfaceForces
					+ Rendering of center:
						+ Physics folder: ShipOverlays
							+ Just container, member of Ship
							+ Centers vector: vec2f pos, PlaneId
							+ Also takes over DebugMarker functionality
							+ TODO: nail down: allow to be drawn during interactions (hence can't be cleared at beginning of Update())
								! Remember: upload is always called, also when paused
								+ ShipOverlays::Upload() only uploads when dirty
									+ Uploaded stuff is sticky on the RenderContext side
									+ Self-resets after upload, and then marks itself as dirty so at next upload it will upload emptyness
							+ Remove clearing of PointToPointArrows during Repair - implied by previous one
							+ ShipRenderContext::Upload requires ViewModel for NDC
								+ ShipRenderContext::Upload needs to take ViewModel, given by caller
							+ Uploaded at each Upload()
						+ ShipRenderContext::UploadCentersStart/./End
							+ Quad size is independent from zoom
							+ Shader: two concentric circles
					+ Investigation facts:
						+ Triangle: inside-pointing normal using before-and-after edges points along edge rather than towards inside of triangle
						+ Square: normals look ok, yet resultant torque is non-zero (10^-3)
					+ Do:
						+ Cleanup:
							+ Cleanup code to the point that hydrostatic pressure is applied as only force
								+ Undo force render buffer as well
								+ Undo any other TODOTEST
							+ Commit
							+ Do ForceRenderBuffer fix (*)
								+ New Points::NextFrameNonSpringForces buffer
								+ All interactions populate Points::NextFrameNonSpringForces
								+ After Spring+Integrate:
									+ Reset Points::NonSpringForces
									+ Swap Points::NonSpringForces <-> Points::NextFrameNonSpringForces
									+ ...continue as usual...
								+ Points::Upload vectors:
									+ Nuke ForceRenderBuffer
									+ Upload NonSpringForces directly
								+ Test both interactions and world forces are rendered now
								+ Issue with pick'n'move - i.e. issue with forces having to apply to next frame
									! Interactions that generate forces: Pick, Blast, Draw, Swirl
									+ Fix option 1: those 4 interactions are queued - as merely "interaction packets" - and processed
									  at about the same time as ApplyWorldForces, in any case after integration and before rendering
										! This way the positions their forces depend on are consistent, i.e. it's the positions that are 
										  in effect at the time we apply the forces
										+ Plan:
											+ Nuke NextStepNonSpringForce's
											+ "Interaction" struct & union internal to Ship, containing args of interaction + struct's EnumClass+Type
											+ List of interactions
											+ New step before ApplyWorldForces: ApplyQueuedInteractionForces
											+ Queue interactions @ interactions
								+ See issue with skewed quad for ship center
									+ Due to sorting at ShipRenderContext
									+ ShipOverlays does the sorting before giving to ShipRenderContext
						+ Move and Rotate interactions: should zero-out non-spring forces as well? Otherwise yet-to-integrate forces might generate torques after rotation
				+ Theory: this might happen because the force is calculated once on a certain position configuration, and then integrated multiple times during the
				  spring iteration loop, with particles changing positions - and likely getting in a configuration that causes torque
					+ Solution: last spring iteration step calls ApplyHydrostaticPressureForces() before Integrate()
					+ ApplyHydrostaticPressureForces: simply adds forces to NonSpringForces
					+ See if applying forces _before_ spring relaxation (i.e. at iteration 0) is better
						+ For a test, populate SpringForces
						+ If works:
							+ Rename Spring and NonSpring forces: DynamicForces and StaticForces
					+ See if Red October also gets torque
						+ Screenshot taken WITHOUT at -839m
					+ Associate AABB with frontier (Frontier->AABB)
						+ At calculatation time: populates a frontier member
						+ Then adds that member const & to AABBSet
			+ Decide between applying HP on *first* iteration or on *last* (or even in-between)
		+ Finalization:						
			+ GameParameters settings:
				+ 1: Adjustment (or just adjustment, and == 0 disables simulation)
					+ SettingsDialog
		+ changelist
	+ Internal pressure (*)
		+ Option 1: a new single "pressure" quantity, separate than Water
			+ New quantity at each particle, much like Water
			+ Intake @ WaterIntake, more or less same concept
			+ New EqualizePressure step to propagate pressure from each particle to its neighbors along springs
				+ Much like we do in temperature
				+ Hullness trick, to ensure that hull particles have pressure (for frontier checking) yet pressure does not propagate through internal hull walls:
					+ Pressure does *not* propagate through hull springs
					+ Hull particles do not partecipate in normal propagation, but get average instead of all neighboring particles
		X Option 2: separate WaterPressure and AirPressure quantities, playing in tandem
			X At any moment: total pressure at a particle is Water+Air
	+ Way to remove all pins (*)
		+ SHIFT to remove them all - unconditionally from *all* ships
			+ World::RemoveAllPins()
		+ Add to help
	+ Water impact (*): water drag does not cause ships to break upon impact
		X See if due to lack of square law: find law such that Titanic's dive is still the same, but higher velocities get higher drags
			+ dragCoefficient' * titanicVelocity = dragCoefficient'' * titanicVelocity^2
			x Doesn't change the fact that airplanes break upon impact; multiplying drag forces x10 causes some almost reasonable crashing on impact, but sinking Titanic 
			  slows down to 8m/s (from ~15m/s normally) - even with pressure=0 and drag=0
		+ Implement as multiplier of drag force, normally 1 but when old Points::CachedDepth==0 and new Points::CachedDepth > 0, then quite high, may be also with some additional dep'cy on velocity
			+ Multiplier: (1-step(0, oldDepth)) * step(0, newDepth) == step(oldDepth, 0) * step(0, newDepth)
			+ Optimize
				+ Test both drag * impact
			+ Setting: "WaterImpactForceAdjustment"
				+ GameParameters
				+ SettingsDialog
				+ Nail down value & extremes
			+ Test dependence on water density
			+ changelist
	+ Satellites and shooting stars (*)
		+ Stars "parks" always an extra star at (-1, -1)
		+ (World)RenderContext: allow incremental upload of prefix of stars only
		+ State machines:
			+ Satellite
			+ Shooting star
		+ Test (all in Debug):
			+ Changing number of stars - including zero
			+ Changing number of stars while moving star is running
				+ Add LogMessage for trigger to verify
			+ Remove LogMessage
	+ Material system improvements
		X Check if can undo BuoyancyVolumeFill:
			X Option 1: Replace with "buoyant_volume_naked" (now one) and "buoyant_volume_clad" (old one)
				+ The biggest test is whether current ships start flying or not
					+ Preliminary checks indicate it might be ok!
					X Argh, no - ships don't sink anymore
				- Replace with "buoyant_volume_naked" (now one) and "buoyant_volume_clad" (old one)
					! Physical interpretation: the volume occupied by the particles, for the purpose of both buoyancy calculations *and* water taken mass calculations
						! Naked: when particle has zero attached triangles; clad: when has at least one triangle
						! Buoyancy: volume of water displaced
						! Taken water mass: high cap on water taken mass (should be 1.0-volume though)
					- Material (in git stash)
					- Adjust structural palette json; guidelines:
						- Every hull material: C=1.0 N=0.0
							! C: because (hull) structures should feel buoyancy (NEW)
							! N: because naked particles won't take water, hence would float forever if they were buoyant (OLD)
						- Every non-hull material: C=1.0 N=1.0
							! C: because structures should feel buoyancy (OLD)
							! N: because naked particles will take water, and hence have to counterbalance taken water weight with own buoyancy (OLD)
						- Ropes: C=N
							! Because even when they form a triangle, we want same bouyancy (OLD)
						- Materials like hull and chains have it ~zero, ropes a bit more
				- Points::Add:
					- ShipBuilder specifies if has triangles attached, and populates mBuoyantVolumeBuffer accordingly (and then calculates buoyancy coeffs)
				- @Points' Triangle Destroy/Restore: populates mBuoyantVolumeBuffer accordingly (and then calculates buoyancy coeffs)
				- @ Points::CreateXYZEphParticle: populates mBuoyantVolumeBuffer accordingly (and then calculates buoyancy coeffs)
					- Air (has 1.0, uses special only for bubbles): TODO
					- Smoke (Air material but with buoyancy_volume_fill overwritten as 1.0): TODO
					- Water (has 0.0): TODO									
				- Remove hacks from ShipBuilder (WaterlineAnalyzer; others?)
			X Option 2: mass of hull is > 1000, and buoyancy_volume_fill is 1
				X Too heavy
		+ Take some of the changes from experiment
			+ Test glass
			+ Test smoke
			+ Test ball of air and water
			+ Test engine wake
			+ Test chains
		X See if still need Points buffer for buoyancy_volume_fill
		+ Make "Internal Watertight" (and other) versions of hull/non-hull materials
			! Spec:
				! Watertight (i.e. hull) but lighter than hull
				! Rename materials (json and code): "Hull" -> "..."
			! Variants:
				- XYZ Hull						# Hull (most of the times, density being 10 times that of base)
				- XYZ Light I-Beam					# base
				- XYZ Solid I-Beam					# Non-hull (permeable) with 10 times the density of base; was: Structural
				- XYZ Light Bulkhead					# Hull (impermeable), with same density as base
				- XYZ Solid Bulkhead					# Hull (impermeable), with ~5 times the density of base
				- XYZ Brittle						# base, but weak; was: Cheap
			+ Write script to generate
				+ Decide final names of variants
					+ Thin: Light+
					+ Thick: Heavy, Solid+
					+ Cheap: Inferior, Common, Low-Grade+
				+ Also mass: Hull and Structural are +100Kg wrt base
				+ Group
					+ Palette in json
					+ MaterialDatabase
					+ H separator between categories in main palette canvas
				+ Fix order of words for names
					+ Format string @ VariantConstants
				+ Also set subcategory in PaletteCoords - to new name of material
					+ Assume group name matches stem; if not found, abort
				+ Better algo for colors
			+ Do for:
				+ All metals
					+ Iron
						+ Lower double-bottom strength
					+ Steel & Stainless Steel
						+ Script: deal with extra color - take min of base and, if exists, hull
						+ Separate palette groups
					+ Titanium
					+ Aluminium
						+ Separate Aluminium Sheet into its own group first, which later won't get variants but only colors
					+ Nails
						+ Colors only
				+ All woods
					+ Complete pine below, first
					+ Oak wood
					+ Pine wood
		+ New materials:
			+ Add helper for adding colors: base base_reference target_reference
			+ Structural materials:
				+ Another wood variant
					+ Names: Oak (600-900, heavier - current), Pine (350-850, lighter)
						+ Check densities and see which one is current
						+ Rename old
							+ Fix mass of hull: nominal_mass=1000->800 density=0.0935->0.116875
						+ Make Pine
							+ nominal_mass=400
							+ Three variants, one color
							+ Add colors to three variants
						+ New materials textures
							+ wood_planks_3: One of the three "wood planks"
							+ wood_studded_2
				+ Sodium: explodes when particle's water > threshold
					+ New enum value: SodiumExplosion (or ChemicalExplosion)
					+ Material
						+ New property for water-based reaction - WaterReactivity - float
					+ Ignition:
						+ Points: we piggy-back on low-frequency loop
							! We still do normal combustion/ignition state machine, as sodium can also burn
							+ Then, sodium state machine follows:
								+ WaterReactionState state:
									+ StateMachine enum: Inert, Unreacted, ReactionTriggered, Consumed
									+ ExplosionTimestamp
								+ WaterReactionState buffer
									+ Init'n: state depends on water_reactivity != 0.0f
									+ At CreateEphXYZ: no need to change
								+ State machine
							+ Explosion: re-use same IShipPhyiscsHandler as explosion, including heat (it's an exothermic reaction)
							+ Follow CombustionState for everything else to do here, including but not limited to:
								+ When to call Sate::Reset()
					+ ship_explosion shader: new "boolean" param to make it yellow (sample.r = sample.g = (sample.r + sample.g) / 2);				
					+ Sounds
						+ Explosion
							+ Normal
						+ Sizzling
							+ Normal
						+ SoundController
							+ Do WaterReaction
							+ Do WaterReactionExplosion
					+ Make test ship for game
						+ Add more electricals
						+ Then move it to game's Ships folder
						+ Do also 1 cargo container
					+ Test:
						+ Run in Debug
						+ Thing itself
							+ Flooded
							+ Rain
						+ Normal explosions
							+ Bombs
							+ Gunpowder							
						+ Sodium thermal properties
							+ Burning
							+ Transmission
						+ Repair
							+ Explodes again afterwards
				+ Try to make glass transparent
					+ Material: optional "opacity", default = 1.0
						+ StructuralMaterial::RenderColor becomes full rgba, taking into account Opacity
						+ Auto-texturization uses alpha of structural material's render color
						+ Test now setting it to ~0.4 just for glass
					+ Test:
						+ Ship (w/no texture layer)
						+ Material Palette
						+ Builder
					+ If ok: make "Opaque" and "Transparent" variants for:
						+ Glass & Glass Hull
						+ Do uniqueness of materials via new json property
						+ Air
						+ Hydrogen
						+ Test all of them (with a single ship)
				+ Helium: ~like Hydrogen, but not combusting
					+ Make "Helium" variant of Goodyear
					+ changes.txt
				+ Redo structural template
				+ changes.txt
				+ More glass colors
				+ More concrete colors
				+ More fiberglass colors
			+ Electrical materials:
				+ Rename horns, @ electrical template, filename, sound enum, etc.
					+ Horn 1: Queen Mary Horn
					+ Horn 2: Four Funnel Liner Whistle
					+ Horn 3: Tripod Horn
					+ Horn 4: Pipe Whistle
				+ Timcan's sounds
					+ Lake freighter horn
					+ Shieldhall steam siren
					+ Queen Elizabeth 2 Horn
					+ SS Rex Whistle
				+ Two new evac's
				+ Ocean disturb at other sound types as well
					+ Klaxon1
					+ Nuclear alarm
				+ Test all sounds underwater
				+ changes.txt
				+ New Engine type: Jet
					+ Requires Engines rearc (*)
					+ Enum
					+ Materials json:
						+ Named variants for  "Jet", "Thrust" (less power, less inertia) X "R/L, U/D" x different powers
							+ "Jet"
								+ Base variant U
									+ Fix direction
									+ Check responsiveness
									+ Check power - seems to be the max
									+ Cheak heat generated
								+ Powers: 50, 200, 1000, 3000, 8000
									+ Make test ship
								+ D, L, R
							+ "Thrust"
								+ Base variant U; powers=100,1000,5000
									+ Check power
									+ Check responsiveness
								+ D, L, R
						+ Make palette groups: Propeller Engines, Jet Engines
					+ Change Material::ToLabel to say "Engine" vs "Jet Engine" depending on engine type
					+ ElectricalElements:
						+ @ engines update:
							+ Does not work underwater - zero targets (thrust and RPM)
							+ No wake if jet
							+ Rendering with bidir flame and variable size flame:
								+ EngineGroup: stores signed RPM
								+ State::Engine: stores AbsRpm (just rename of current, but populated with abs(EngineGroup::RPM)) *and* JetEngineFlameVector
									+ JetEngineFlameVector: 
										+ Engine direction * group signed RPM * scale==(Non-linear for engine power, linear for thrust adjustment * super-electrification)
											+ Engine power: thrust capacity = EnginePower * 746; EnginePowers: 50 -> 8000
										+ Smoothed as well towards target
									+ Uploaded instead of dir and RPM
								+ Test:
									+ Engine in both directions
									+ Gauge
									+ Circle notification
									+ Different powers: same gauge, different flame size								
					+ ElectricalElements::Upload():
						+ Invoke from ship
						+ Upload 
							+ Only jet engines 
							+ Iff state::thrust magnitude != 0.0f
							+ Upload direction and magnitude
							+ Z-sort:
								+ mJetEnginesSortedByPlaneId
								+ Init'd at Add, random order
								+ OnStructureChanged~:
									+ Invoked by Ship when connected components change
									+ Sorts by point's PlaneId
								+ Upload runs on it
									+ So no "Jet" type check
					+ ShipRenderContext:
						+ Shader
						+ Set params like in others
						+ Upload
							+ Quad length and width both depend on thrust magnitude, but length depends more
							+ Wind is zero (it won't be used anyway)
							+ Should take RPM instead of thrust, so flame is visible also at zero thrust but non-zero RPM
						+ Nail down flame H/W proportions: sqrt definitely good?
					+ Displayed differently by ElectricalPanel
						+ Different sub-type of Engine RPM UI control for different background: JetEngineGauge.png
							+ Image
					+ Sound
					+ Tests:
						+ Z depth
						+ Row of engines - for flames					
				+ Controllers:
					+ New "EngineController" sub-type
					+ Controller values are all float, between -1.0 and 1.0
						! TelegraphValue was between -Degrees/2 and +Degrees/2
						+ ElectricalElements::EngineControllerState:: Current"Telegraph"->Current"ControllerValue"
						+ ElectricalElements::SetEngineControllerState
						+ ElectricalElements::UpdateSinks: EngineController: map -1/1 to group RPM, etc.						
						+ Switchboard: creation of Telegraph: current value is 0.0
						+ UILib/Telegraph controller: map to internal, at all places
						+ All implementations of OnEngineControllerUpdated
					+ Materials:
						+ Engine Telegraph (rename)
							+ Material::ToLabel
						+ Engine Controller "Jet Throttle"
							+ ElectricalPanel
								+ Resources:
									+ Image: background and handle
									+ Image: disabled x 2
								+ ElectricalElementControl
							+ Material::ToLabel
						+ Engine Controller "Jet Thrust"
							+ ElectricalPanel
								+ Resources:
									+ Image: On, Off
									+ Image: disabled x 2
								+ ElectricalElementControl
							+ Material::ToLabel
					+ ElectricalElement handling of two new controllers
					+ Sounds
						+ EventHandler::OnEngineCtrlUpdated: take prev value (pop'd by ElectricalElements) and type
						+ Clutch sound for Throttle
						+ Existing button sound for Thrust
					+ Tests:
						+ Telegraph:
							+ Works between -1 and +1
							+ Switchboard: Disabled/Enabled, On/Off 
						+ Jet Throttle:
							+ Works between -1 and +1
							+ Switchboard: Disabled/Enabled, On/Off 
						+ Jet Thrust:
							+ Works between -1 and +1
							+ Switchboard: Disabled/Enabled, On/Off 
	+ Engines rearc (*)
		! Goal: allow controllers to control engines at a distance
		+ EngineState: EngineGroup member
		+ EngineController: EngineGroup member
		+ Connectivity update
			+ Should we do it at each frame (because of autonomous state changes), or is it enough to only do it at structure changes?
				+ Doing at structure changes: at all places where we do structure changes:
					+ Destroy/Restore
					+ AddConnectedElectricalElement/RemoveConnectedElectricalElement
			+ Do UpdateEngineConductivity, populating Engine's and EngineController's group IDs
				+ Store connectivity visit seq number in state, but clearly named
				+ For each engine_controller: if not deleted: if not visited:
					+ Make new group ID
					+ Store reference point and angle
						+ Should be able to copy most of the current code
					+ Flood graph from this engine
						+ Recongize elements by type
				+ Resize member vector for groups
					+ member vector for groups' "power", struct with RPM and ThrustMagnitude
						+ member just to make allocation efficient
			+ Test
				+ QueryElement/log
		+ UpdateSinks():
			+ Reset all groups
				+ asm: make sure it's a fill
			+ Source loop: 
				+ Controllers update groups (current: RPM=max, ThrustMagnitude=SUM; new: TODO)
					+ Move direction calculation to engine
					+ assert(group ID not zero)
			+ Then, engine loop: engines update themselves, drawing from groups
				+ RPM and thrust are zero if their engine group ID is not the zero group, else the group's
					+ Actually nuke "None" constant, and use "group zero"
				+ Move direction calculation here
		+ Cleanup:
			+ See if still need EngineState's "current" values (rpm, thrust dir, thrust magnitude)
			+ Nuke EngineController's connected engines
				+ And code that populates that at AddFactoryConnectedElectricalElement()
			+ See if it still makes sense to call Engines "EngineSink" - do they share any characteristics with sinks?
				+ Do they consume electricity?
		+ Test ships
			+ Red October
				+ Fix (making it shp2)
			+ Triton
			+ Blimps
			- etc.
		+ EngineTransmission material
			+ Material, new ElectricalElementType
				+ Yes electrically conductive
			+ ElectricalElements
				+ State
					+ VisitSeqNumber
				+ General support for new type
				+ Engine connectivity visit
			+ Test - also exercising engine groups
				+ Make test ship, and watch queryElement/log
				+ Circuits
				+ Destroy/Restore
	+ Laser cannon tool (*)
		! Spec:
			! Like saw but heats structure
			! Turrets at four corners, oriented towards mouse
			! When clicking, laser shaders from four corners
				! Nice shader for laser ray
		+ Impl:
			+ Test all other notif's w/pause
			+ Tool:
				+ Stride
					+ EngagementData has previousMousePos
					+ Update previousMousePos @ Update()
			+ Rendering (NotificationRenderContext):
				+ Cannon @ mipmapped alias
					+ PNG
						+ Smaller
						+ Play with colors
						+ Play with textures
					+ Database + enum
				+ Upload
					+ Cannon vertices
						+ Make cannons rectractable 
							+ Watch out for negative points
						+ Fix aspect ratio problem
					+ Ray vertices
						+ Make noise invariant from length: instead of -1..+1, do  +1-ScreenToNdc(ray_length)..+1
						+ Strength no thickness change
				+ Shaders:
					+ GenericMipMappedTexturesNdc
					+ LaserRay
						+ Strength variation:
							+ A little thicker when strong
							+ Center more white
						+ Outer noise different
				+ Cannons are subject to daylight, ray is not
			+ Physics (Ship::Apply...):
				+ Stride:
					+ Cut 
						X Full cut (like @ saw)
						+ New material property: laser_ray_cut_receptivity
							+ Use script to set it to 1.0 for: ropes, cloths, paper, ...
						+ Cut springs iff material
					+ Heat injection at each point close to stride segment
						+ Find right distance
			+ Sounds:
				+ Basic code
				+ Normal variant (more electronic)
				+ Amplified variant
		+ SettingsDialog:
			+ LaserRay heat flow
				+ Double-check value range
		+ Test on Dell
		+ changes.txt
	+ Electric Sparkle tool: sparkles can cause lights to explode (*)
		+ Can be done within OnElectrified, by calling directly Desotry(Explode) with randomness
			+ See why can't be repaired
			+ Better debris material: new StructuralMaterial unique type: GlassDebris
			+ Nail down probability 
	+ Lamps breaking under pressure (*)
		! Unrelated to pressure crush (*) with frontier
		+ Pre:
			+ Make ship w/lamp electrical material
			+ Verify NO glass sound when hammered and when broken (w/ tearing)
			+ New electrical material property: "lamp_external_pressure_breakage_threshold", in Pa (i.e. N/m2)
				+ json
			+ IEventHandler
			+ Invoke Destroy(own index, DestroyReason=None|ForLampImplosion|ForLampExplosion)
				+ Destroy(.) translates into IShipPhysicsHandler::ElectricalElementDestroySpecializationType
			+ Specialization types, and IShipPhysicsHandler::OnElecMaterialDestroyed takes ElectricalElementDestroySpecializationType
				+ None: nothing else
				+ Lamp: glass sound
				+ LampImplosion: lamp implosion sound
				+ LampExplosion: lamp explosion sound + debris
			+ SoundController
		+ @ Ship::Update(.):
			+ Find points loop that may be used for this
			+ If has electrical element and that elec element is not deleted and that element is a Lamp: ElectricalElements::Destroy(implosion)
				+ Regardless of current operating state of lamp
			+ Nail down variance: constant, not percentage
				+ Rearc:
					! Move physics from Ship to ElectricalElements
						! Update(.) takes effective air density, etc.
					+ ElectricalElements::Add(.) pre-calc's threshold external pressure
						+ Gaussian
						+ Stores it in LampState
					+ UpdateSinks(.):
						+ case Lamp: before RunLampStateMachine(.), check pressure and eventually call Destroy(.)
							+ Verify current physics also calls ElectricalElements::Destroy(.)
							+ Use adjustment
					+ Remove from Ship
						+ Put ship's code back to normal
				+ Test:
					+ Check spark particles (Ship::GenerateSparklesForCut)
					+ Titanic 
			+ Nail down depths:
				+ 500m => 5019.04
				+ 5000m => 50190.43






+ Water
	+ Water
		+ Ship::LeakWater:
			+ Try rearc: just check if leaking and if externalWaterPressure (0 if above World::WaterHeight) > mWater
		+ Test hull springs/water propagation
			+ Check if also in old program Titanic.png had non-wet hull rudder: YES
			+ Less hull material in Titanic, but maintain strength
			+ Test Titanic afterwards
	+ Did original game propagate water also through hull springs? YES. How did hull thin dividers work? THEY DIDN'T WORK
	+ Add Point::Hull Characteristic, and don't leak/propagate(incl. gravitate) water if at least one of the two points is hull
		+ Alternatively: just make a spring hull if one point is hull; test it
 	+ Rush sound: should water rush sound be more....rushy?
	+ Water rearc:
		+ Points::Water is height of water column that provides equivalent pressure
			+ When 0<=Water<=1 is also fraction of volume filled with water
			+ Add comments at Points
		+ Ship::LeakWater:
			+ Calc velocity of entering water with Bernoulli
				+ Still need to cap to max (external pressure) because of dt possibly being too large?
			+ Also do negative pressure (i.e. water leaving cell)
		+ Do water-momentum based dynamics
		+ Cleanups and deferred TODOs:
			+ Test with Bernoulli's spring velocity being added to point's water velocity (times its mass of course)
			+ Do U-shaped tube
			+ SettingsDialog:
				+ Flex spacing
			+ Rename water detail parameter: Water Detail Coarseness
			+ Take perf measurements:
				+ FPS: 26.8/26.9/27.0/27.4
				- MainFrame::RenderGame:	61.08%
				- GameController::Update:	32.92%
					- UpdateWaterDynamics:	 5.85%
						- UpdateWaterVelocities:	5.77%
			+ Refactor UpdateWaterVelocities:
				+ Normalize based off sum of magnitudes
				+ Finalize double-buffering
					+ Take perf measurements afterwards: 27.3/27.5/27.6
				+ 1) Test with memcpy of water buffer
					+ Perf before: UpdateWaterVelocities: 5.59%
					+ Inline first (taking also oldPointWaterBuffer * as restrict)
					+ Perf after: 27.4/27.6
					+ Move to Points as:
						- float * restrict CheckoutWaterBufferTmp()
						- void CommitWaterBufferTmp(float * restrict ...)
							- asserts same as own
				+ 2) See to improve (sse for 2?) water momentum making/demaking
					+ Move to Points (anyway) as:
						- vec2f * restrict CalculateAndCheckoutWaterMomentumBuffer()
						  or: vec2f * restrict PopulateWaterMomenta()
							- Returns the buffer afterwards
						- void CommitWaterMomentumBuffer(float * restrict ...)
							- asserts same as own
						  or: void PopulateWaterFromMomenta()
				+ Use restrict pointers also for source buffers and springs' properties
					+ Start with only waterBuffer and waterVelocityBuffer, see if improves 1) pre- and post- steps,
					  and 2) main loop
					+ Check asm before
					+ Take perf measurements afterwards: 27.7/28.0
			+ Move "other endpoint" to Springs class
				+ Verify with asm: it's inlined
			+ Finalize
				+ Take measurements: 27.4/27.7/27.9
				+ Check asm
					+ Momenta initialization
					+ Velocity recalculation
				+ Finalize perf snapshot
			+ ShipRenderContext: add waterLevelOfDetail param to all other shader programs
			+ SettingsDialog: make it tabbed: mechanics, fluid, rendering
			+ Add crazyness to SettingsDialog
			+ Rename GameParameters::GravityNormal to GravityNormalized
			+ GameParameters:
				+ Rename NumDynamicIterations as NumMechanicalDynamicsIterations
				+ Add NumWaterDynamicsIterations
			+ Is Springs::WaterPermeability still used?
			+ See if GameParameters::WaterPressureAdjustment still needed (or needs to change name)
			+ Remove old water dynamics code from Ship
	+ UpdateWaterVelocities:
		+ See what happens when we also incorporate dest's velocity in Bernoulli
		+ See what happens with drag (after final calculation of velocities)
			+ See if needs to be linear or quadratic
		+ Test with reflected momentum
	+ Splash sound:
		+ First we need to cleanse "rushing water" of bubbles sound
		+ New "splash" continuous sound, with volume controlled by total magnitude of momentum change
			+ Test with ProbePanel, ScalarTimeSeriesControl
			+ Go for kinetic energy lost instead
		+ Finalization:
			+ Nail down sound
			+ Nail down volume
			+ Measure perf:
				+ FPS: 25.9/26.1/26.2
				+ UpdateWaterVelocities (2m): 11.19%
					+ expf: 2.34%
			+ When removing Q from point, test with using only component of oldV along spring
			+ Recheck one-sided deltaT
			+ Cleanup
			+ Run in debug mode
			+ Averager needs to become member of ship
			+ Optimizations - things to test:
				+ That scalar/vector/scalar
				+ See if can either update all point water momentum once, or for each spring - not both like now!
					+ => FPS=26.2/26.5
					+ UpdateWaterVelocities (2m): 8.75%
						- expf: 0.81%
				+ Low-hanging fruit
				+ Initial point visit for populating exp(water)
					+ Requires temp buffer
					+ Pre: 26.2/26.5
					+ Post: 26.8/26.9
				+ Initial spring visit for all Bernoulli's (scalar)
					+ Requires temp buffers
					+ Still need to assign sign depending on whether pointIndex is spring's point A or not
					+ Post: 26.8/26.9
					+ NOT WORTH IT
			+ Should replace water rushing in - decide
	+ Do water bubbles (at intake) and water drops (at outtake)
		+ Ephemeral particles emitted at UpdateWaterIntake()
			+ Intake:
				+ Material ("Air") with (very low) weight (real air weight) and full buoyancy so rises up automagically
					+ MaterialDatabase: special getter for it
						+ Mechanism for detecting this and Ropes: unique_type
						+ SoundType needs to become optional
						+ IsRope has to go/ColorKey comment has to go
				+ Ship must take MaterialDatabase
				+ Emit
					+ Need to coalesce multiple emissions into one
				+ Points::Ephemeral support
				+ Sounds:
					+ Destroy-AirBubble
				+ Expose DoGenerateAirBubbles to SettingsDialog
				+ Air Bubbles Tool:
					+ ~Continuous Tool
					+ Cursor
					+ Continuous Sound
					+ Clean Destroy() doing air bubbles
				+ Don't steal ephemeral particle for air bubbles

			+ json comments
				+ Stripped out at Utils
				+ Add comment to air bubble water volume fill
		+ Cleanup:
			+ Points::Ephemeral maxlifetime expiration is per-type, not global
				+ But buffer stays, useful for finding free slots
			+ Make vortex parameters GameParameters
	+ New sinking (and un-sinking) detection: (*)
		+ Sinking detection is broken - it currently only considers total water that entered the ship, which comes proportionally to external
		  water pressure; all this water could be confined to a tiny volume, and yet we trigger sinking
		+ Should be based off # of points underwater *and/or* total # of wet points
			+ Could be a very-lo-freq step that just checks y's against water height at that point
			  and/or total # of wet points
				+ Use HighWatermark/LowWatermark
				+ Sinking:
					+ Total # of wet points > 2/3 * total points
				+ Unsinking:
					+ Total # of wet points < 1/3 * total points
			+ Make music class with FadeToStop()
				+ Also call its ::Update(), which fades
					+ Called only for music's that we know are to fade
				+ Stop() stops immediately at any point
				+ Test music:
					+ Pause
					+ Stop/Resink
			+ Test music fading
			+ Find right thresholds: just check default ship and balls and sailship2
		+ Check assembly
			+ See without restrict point but GetWater() directly


+ Debug light/drag issue
	+ Could be due to distance too close and shooting light to sky
+ Do connected component detection
	+ Get new baseline
+ See perf of merged LeakWater+DetectConnectedComponents vs Separate
	+ Use perf analyzer:
		+ Merged:
			- Ship::Update: 60.64%
				- PreparePointsForFinalStep: 3.14%
		+ Separate:
			- Ship::Update: 63.69%
				- LeakWater: 0.11%
				- DetectConnectedComponents: 3.02%
+ Fix multiple clouds

+ Game Interactions and Controls:
	+ IGameEventHandler: individual methods, including parameter changes, all default-implemented
		+ OnDestroy(Material const *, size) // size=1 for each destroy, but Dispatcher aggregates assuming size=anything
		+ OnBreak(Material const *, size) // size=1 for each break, but Dispatcher aggregates assuming size=anything
	+ GameController::RegisterGameEventHandler(IGameEventHandler *)
		+ calls into GameEventDispatcher::RegisterGameEventHandler, who does:
			+ Registration of real sinks (vector of plain IGameEventHandler *)
			+ Aggregation of duplicate events
				+ e.g.: OnBreak: keep distinct Material * and sum for size
				+ Clears aggregations at OnStepStart() (from GameController) and publishes them
				  to registered sinks at OnStepEnd()
	+ GameController gives shared_ptr<GameEventDispatcher> to Game at Game's cctor (as shared_ptr<IGameEventHandler>)
	+ GameController calls mGameDispatcher (shared_ptr<GameEventDispatcher>)->OnStepStart()/End()
	+ Invoke events at Game and below (pass handler at XYZ.Update())
	+ First GameEventHandler: EventTicker
		+ It's custom panel at bottom with text ticker
		+ EventTicker holds wxPanel and draws it (figure out OnPaint and DC...)
		+ Created by MainFrame and registered by MainFrame on GameController
		+ Hide it by default and only show via MainFrame menu option
		+ Complete event handlers
		+ Do ship sinking event notify in ship (mWater > 1/3 points)
	+ Increase max grab force
	+ Extended status text
		+ Shows:
			+ Current zoom
			+ Rendering vs simulation percentages
				+ GameController continuously updates, same way as FPS
			+ If paused
				+ Actually, this is from StatusText
		+ Multi-row:
			+ Text layer gets it split & gives vector to TextRenderContext
	+ Move tool
		+ Rename current "move" as "Pan"
		+ ShipId type (see around here)
		+ ObjectId type (see around here)
		+ With move tool enabled:
			+ Click on ship -> GameController returns std::optional<ShipId> -> if not None, tool is engaged (save cur screen pos)
				+ Works like pan
			+ Moving tool tells GameController delta (offset) screen
	+ Ship definition: multiple layers
		+ We want to maintain BW compat for ease of one-layer ship making
		+ Impl:
			+ json:
				+ "structural_colour" -> "color_key"
				+ "colour"->"color"
				+ Copy & rename
				+ Structural:
					+ Refactor sound_type for all structural elements
					+ Remove electrical properties
				+ Electrical:
					+ Remove non-electrical materials
					+ Refactor materials
			+ Breakup material class
			+ MaterialDatabase
				+ Restructure
				+ Find: fallback to rope
			+ ResourceLoader::LoadMaterialDatabase()
			+ IGameEventHandler events take now StructuralMaterial
			+ Points::new struct for materials
			+ Springs, Triangles
			+ ElectricalElements
			+ Ship
			+ ShipDefinition/File: new layers, plus bw-compat
			+ ShipBuilder
			+ Event publishing
			+ Event handlers
			+ Sound renames
				+ StructuralMaterial::MaterialSoundType MaterialSound
			+ GameController
			+ Fix issue with rope endpoints
			+ Fix issue with rope buoyancy
			+ Rope shader: use color from point color buffer
				+ And then get rid of rope color passed to RenderContext
		+ Get rid of IsRope from structural material
			+ Also from json
		+ Test:
			+ BW compat old ships
				+ Electrical
				+ Ropes
				+ All
		+ Renew ships:
			+ Make SS queen of unova use layers
				+ Fix structure as well
			+ Make Szersen cargo use layers
				+ Also test propagation of electrical (cable, in this case) along ropes
				+ Also test different colors for ropes
		+ Cleanup:
			+ Do two new material template screenshots and nuke old one
			+ Redo materials.md
	+ New "Impact" Bomb
		+ Only explodes when spring is destroyed
		+ State machine only for explosion
		+ See why huge explosion
		+ See why texture weird
		+ Center texture
		+ Help
	+ Tool to flood ship
		+ Name: Flood
		+ Shift: un-floods
		+ Icon: bottle (flood), syphon/dropper (unflood)
		+ New ToolController/Tool
			+ Continuous, like Destroy
		+ World->Ship::OnFloodAt(x,y,strength)
			+ Find closest (very small radius)
			+ Add water quantity to point
			+ Emit event
		+ Sound: continuous as long as ship takes water
			+ So, like sawed
				+ Update() attempts to stop i
	+ Control incisiveness (contrast) of water color for water in ship
		+ New uniform
	+ Save screenshots/photos
		+ Saves automatically in custom folder
			+ New settings provider: UISettings
				+ Managed normally by SettingsManager, and thus tweaked via SettingsDialog
				+ Cctor sets default path (which will be default for SettingsManager)
		+ Code (at RenderContext::TakeScreenshot() -> returns ImageData)
		    glPixelStorei(GL_PACK_ALIGNMENT, 1);
		    glReadBuffer(GL_FRONT);
		    glReadPixels(0, 0, windowWidth, windowHeight, GL_BGR_EXT, GL_UNSIGNED_BYTE, pixels);
		    + See glPixelStorei and glReadBuffer
		    + Call glFinish before all
		+ MainFrame does the saving, via GameLib/ImageTools
			+ Move load functions from ResourceLoader to ImageTools
			+ All static methods
			+ Creates UISettings and passes to SettingsDialog
			+ MainFrame responsible for finding unique filenames like smartphone, with micro's portion
			+ Fires snapshot sound
		+ SettingsDialog:
			+ Add DirCtrl under tab "TODO"
				+ https://docs.wxwidgets.org/3.0/classwx_dir_picker_ctrl.html
		+ Make actual snapshot sound
		+ Changelist
	+ Pick tool: ability to move individual connected components (*)
		+ After connected component has been overhauled
		+ Spec:
			+ New tool gets point ID from GameController::Pick() and passes it to new MoveTo()
			+ Move tool becomes this new one
			+ Old move tool becomes "MoveAll" tool
		+ Impl:
			+ Pick engagement returns ObjectId for point ID (or none)
				+ Ship::Pick(vec2f position) -> opt<ElementIndex pointId>
				+ World makes opt<ObjectId>
			+ Ship::MoveTo(ElementIndex pointId, vec2f position, vec2f velocity) (new overload):
				+ If point deleted => return false (to disengage)
			+ Tool: copy from Move
			+ Make cursor for "MoveAll"
			+ Help
			+ Changes.txt
+ Sound:
	+ SFML:
		+ Build own
		+ Add bins reference to ship CMake
	+ Mute @ Menu
	+ Fix splash progress - make sure final "Complete" shows
	+ Break/Destroy: handlers also take bool isUnderwater (based off Y of broken thing wrt world's water height)
	+ MainFrame initializes SoundController, which implements IGameEventHandler
		+ Initializes off visit of Data/Sounds and Data/Music, w/Music and Sounds
			+ Mapping of sounds with IGameEventHandler events via:
				+ Material::optional<SoundProperties>
					+ SoundMaterial: enum(wood, metal, ...)
					+ Material enums have StrToX()
				+ Filename patterns of sounds and music (e.g. destroy_wood_small_underwater_1.wav)
					+ Parse: if 'destroy'=>expect SoundMaterial next, then ...
				+ Storage of sounds:
					+ Maps store vector<SoundBuffer>
						+ Values are all the variations of the sounds, and
						  SoundController chooses randomly
					+ Sounds are created when played and stored in queue together with timestamp
				+ Sounds stored in maps (of maps of...) indexed by coordinates off filename patterns
					+ Material's enums used as coordinates, together with SoundController's own
					  enums (e.g. action, size, underwater type)
				+ ResourceLoader has:
					+ GetSoundFilenames() -> all sound (relative) filenames
					+ GetSoundFilepath(filename)
		+ Do random choice
		+ Need to manage number of currently-playing sounds
			+ When currently playing > MaxPlayingSounds (constexpr):
				+ ScavengeCompletedSounds()
				+ If still full, stop oldest (among same SoundType, or absolute if none) and pop it
			+ ScavengeCompletedSounds() also called at SoundController::Update()
	+ Stress event
		+ At break loop: for each spring:
			+ Spring->UpdateTensionStrain(..., IGameEventHandler):
				+ If is broken=> this->Destroy(); break event (calc undewater);
				+ else if is stressed=>
					+ If !mIsStressed:
						+ set; stress event (calc undewater)
				+ else:
					+ mIsStressed = false;
		+ Spring::IsStressed()->mIsStressed, used for rendering
	+ Don't play soundbuffer if already playing for < 20ms
	+ Sounds:
		+ destroy, stress
		+ finish destroy
		+ better cable snap
		+ Listen to all materials
		+ fix destroy cable/string's
		+ Batch convert all to flac
			+ Test and commit
		+ underwater: with reverb effect
			+ Batch mode, save aside current underwater's first!
	+ MainFrame registers SoundController as Handler with GameController
	+ Sinking music
		+ GameController starts it upon OnStartedSinking() event
	+ See if sounds should be spaced more apart
	+ See underwater cable sounds - sound like metal?
		+ break small 1, 3, 4
		+ destroy medium 1
		+ destroy small 4
	+ Draw event:
		+ GameController fires Grab, simple
		+ SoundController: uses own sound.isPlaying as state and starts @ event/stops @ update
			+ Uses two consecutive Update() w/no Draw in-between as stop
			+ how to loop though?
	+ Rethink notification of Draw and Swirl events
		+ Remove from GameController, fire at tool via "Toggled(bool)" events
		+ Remove magic from SoundController
		+ Can always modulate sounds at Tool::Update, for example asking GameController::IsUnderwater(screen coords)
			+ Do at Chainsaw, do underwater sound
				+ Change event handler:
					+ OnSaw(opt<bool> isUnderwater): off, on overwater, on underwater
		+ Test: get rid of all FlushEvents outside of update
			+ If OK, remove commented-out code
	+ Reset sound controller at ResetAndLoadShip()
	+ Water rushing-in
		+ Continuously-playing sound
			+ Find sample
		+ Volume time-interpolated off total quantity of water that entered ships during step
			+ Communicated via new event - OnWaterRushedIn(total_water_quantity)
			+ total_water_quantity update (passed by arg &) replaces mTotalWater update
				+ mTotalWater updated afterwards with +
			+ Volume = 100 * ( -1/(Qw+1) + 1 )
				+ Qw = some scaled version of total_water_quantity (1.0f might suffice)
	+ Separate sound control for tools
	+ Saw sound
	+ Turning down a bit the very high pitch stress noise
		+ Do it on flac - on all high-pitched ones (same amplitude)
	+ Sawing: do not publish destroy events when cutting springs, but new "Sawed" events with own metal/wood sounds
		+ Two new continuous sounds: metal and wood saw
		+ OnSawed is invoked with Type and size - size=0 means nothing
		+ Event handler sets continuous sound's volume up/down (when size=0), and eventually starts it
		+ Stopping continuous saw sound also sets volume of these two to zero
	+ Do air bubbles sounds, very low volume
		+ At expiry
		+ New events at IGameEventHandler
			+ Dispatcher aggregates with counter
			+ Ship takes shared_ptr<Dispatcher> now, for perf

+ Put credits
	+ Splash: https://www.artstation.com/stukata/profile, contact the guy

+ Fix: When land is above water, water is upside down

+ Optimization: to improve locality: points in contiguous buffer
	+ No PointerVector but (fixed) std::vector<Point>, and others point to locations in the vector
	+ Points never deleted, just marked
		+ So have to check point.IsDeleted() each time the Point buffer is iterated
		+ No check
	+ Point destroy: also clear *own* references
	+ Try contiguous buffer also with springs and triangles
		+ And not checking isDeleted
			+ Remove assert's
		+ Multi-step create loop
		+ Spring destroy: also clear *own* references
		+ Triangle destroy: also clear *own* references
		+ Do check IsDeleted for Spring and Triangle operations that may affect connected non-deleted points
		+ New perf: 15.7/15.8
		+ See ElementContainer::range(start, end)
			+ UnitTests, verify last excluded
	+ IsDeleted needs only be checked at SpringRender and TriangleRender
	+ Try fast_qrt for vec2f::length()
	+ Test fast_XYZ at vector
		+ fast_inv_sqrt: 15.2/15.3/15.3
		+ 1/sqrt: 15.3/15.3/15.3
		+ Nuke'em if ok
	+ EventTickerPanel is stealing 1.99% even when not shown

+ Render optimization: only upload spring elements, triangle elements when they're dirty (deletion occurred)
	+ Get perf analysis first:
		- Game::Render: 34.90%:     Ship::Render: 31.53% (Incl)	3.05% (Excl)
			- RenderShipEnd: 28.24%	- Ship::RegisterDeletion: sets mAreSprings/TrianglesDirty=true
	+ cctor: true
	+ set to false after uploaded to RenderContext
	+ Move XRay flag consumption to RenderContext

+ Now that we have connected components, fix covering of ship pieces:
	+ Draw batches of triangles and springs by component, so that pieces are "covered" nicely
		+ Ship keeps track of # of connected components and of each size
		+ At RenderXYZ(), allocate N buffers for the vertex indices and dispatch each triangle/spring
		  to the correct buffer based off ConnectedComponentID
			+ ConnectedComponentID passed by caller (spring or triangle) based off the (first) point
			  of the primitive
				+ assert other points have same ID
			+ Note: points themselves are not affected by this; they're still uploaded in their entirety
			  once per cycle
		+ At RenderXYZEnd(), draw each connected component buffer from last to first
		+ Do for triangles
		+ Do for springs
		+ Each connected component must be drawn together - its springs then its triangles

+ Technical Debt:
	+ Resources: lowercase filenames
		+ git
		+ code
	+ /Data
	+ /Ships
		+ Uppercase ship filenames
		+ Code (ResourceLoader)
		+ source (git)
		+ CMake
	+ MainFrame::Die(msg of exc)
	+ Get rid of Game.cpp and move functionality to GameController
		+ ResourceLoader::LoadDefaultShip()
		+ Also, don't load default ship autonomously (need to register event handlers before that happens);
		  rely on MainFrame calling GameController::LoadDefaultShip() after registration
	+ Change calls to Point::SubtractFromLastPosition() to AddToLastPosition() and use (& implement) unary '-' operator for vectors
	+ Points and Springs and Triangles::Destroy()'s are templated on Point/Spring/Triangle"Being"DeletedHandlers (others than self),
	  & ship passes own methods
		+ OR: even better, as handler never really changes: cctor takes handler at beginning, given by ship,
		  and stores as std::function
		+ Handlers invoked *before* actual deletion
			+ Comment on handlers on connected-to-argument might be deleted
		+ Not re-entrant - can't delete from within
		+ Handling of pinned point deletion is then done here
		+ See if also whole logic of point<->spring<->triangle can be done in handler
			+ If so, don't pass containers at various Destroy()'s
		+ Test
	+ CircularList::Erase unit test: complete verification of returned iterator
	+ Containers::Destroy and GameEventHandler::OnDestroy rearc:
		+ 3 containers are given shared_ptr<GameEventHandler> and ParentWorld & at cctor
		+ The 2 Destroy()'s fire events (after invoking DestroyHandler), unless otherwise specified
		  via DestroyOptions
		+ Ship's DestroyHandlers don't fire events anymore, and Ship::SpringDestroyHandler takes boolean
		  for triangles (translated from Springs::DetroyOptions)
		+ Test assert's with Debug build
	+ Move definition of ElementIndex et al into GameTypes.h
	+ Move also pinned points to a PinnedPoints class, just like Bombs
	+ Textures are json files, with world size, offset, and lighting boolean
		+ SEE MOLESKINE
		+ Cleanup:
			+ RenderContext:
				+ Hook up IProgress to individual loads
					+ Double-check total count adjustment
			+ Commit
		+ Then:
			+ (Ship)RenderContext: Do not store sizes but whole database instead
				+ Database must be associated with GLuint's of textures
				+ RenderContext stores (moves) database at cctor
				+ Passes reference to ship
				+ TextureDatabase::GetFrameMetadata(TextureFrameId)
					+ TextureDatabase builds map of references at cctor
			+ Remove hardcoded sizes and offsets and substitute with metadata lookups
				+ Cloud size
				+ Water size
				+ Land size
				+ Pinned point size
				+ Bombs sizes and offsets
			+ Test
				+ Double-check clouds's aspect ratio
				+ Anchor at all frames of timer bomb
			+ Commit
			+ ShipRenderContext: replace pinned points and bombs with Upload(Ship)TextureRenderSpecification:
				+ PinnedPoints
				+ Bombs:
					+ Upload4Render() eventually invokes twice (lighted and unlighted)
					+ Frame indices are TextureFrameIndex instead of uint32
				+ Args:
					+ ShipID (used only by RenderContext to dispatch)
					+ ConnectedComponentID
						+ Until Z-rearc: ShipRenderContext has one TextureRenderSpecification per-connected component
						- After Z-rearc: put in buffer for shader to transform to Z
					+ Position (vec2f)
						+ Of anchor
					+ Orientation (std::optional<vec2f, vec2f>)
					+ TextureFrameId
				+ ShipRenderContext gets TexturePolygon from TextureRenderManager::CalculateTexturePolygon
					+ TexturePolygon is declared at RenderTexture.h, which includes other Texture render .h's
					+ Contains 4X{pos,textureCoord, and AmbientLight adjustment}
					+ For the time being it calculates also rotation
					+ Nuke RotatedTextureRenderInfo.h
				+ Use a single shader for these "simple" textures
					+ Takes TexturePolygon, described to OpenGL
				+ ShipRenderContext rearc:
					+ Textures -> TBD Name="Generic"
					+ Simplify alpha and beta with just beta, and beta is "ambientLightSensitivity"
				+ ShipRenderContext: Detach textures from ConnectedComponentData
					+ RenderContext::RenderShipStart(connected components)
					+ RenderContext::RenderShipEnd()
				+ Double-check cloud rectangle calc'n against TexturePolygon
				+ Test
					+ Double-check clouds's aspect ratio
					+ Anchor at all frames of timer bomb
					+ Rotation of bombs
				+ Move TextureRenderManager::AddRenderPolygon method to .h, and call it EmitRenderPolygon
				+ Move bind into TextureRenderManager, templated
				+ Nuke old bombs/pinnedpoints at ShipRenderContext
				+ Commit
		+ Change the single shader to do *all the work* (for the "simple" textures, including rotation) for all ships and connected components
			+ Initially, runs on 1 texture at a time
				+ After atlas and Z, runs on all textures (via atlas' per-frame texture coordinates)
			+ Perf before moving rotation into shader (2000 textures, @ 30s):
				+ With multiple batches:
					+ FPS: 16.5
					+ ShipRenderContext::RenderGenericTextures: 31.29%
					+ TextureRenderManager::EmitRenderPolygon: 0.53%
						+ atan2f: 0.16%
						+ sin+cos: 0.09%
				+ With single batch:
					+ FPS: 12.24
					+ ShipRenderContext::RenderGenericTextures: 4.65%
					+ TextureRenderManager::EmitRenderPolygon: 0.83%
						+ atan2f: 0.28%
						+ sin+cos: 0.16%
			+ Move rotation et al into shader (without Z for now)
				+ TexturePolygon is modified to also contain orientation
			+ Perf after moving rotation into shader:
				+ With multiple batches:
					+ FPS: 16.4
					+ ShipRenderContext::RenderGenericTextures: 32.23%
					+ ShipRenderContext::UploadGenericTexture...: 0.56%
						- atan2f: 0.14%
						- vector: 0.10%
				+ With single batch:
					+ FPS: 12.29
					+ ShipRenderContext::RenderGenericTextures: 6.88%
					+ ShipRenderContext::UploadGenericTexture...: 0.75%
						- atan2f: 0.21%
						- vector: 0.08%
			+ If OK:
				+ Nuke TextureRenderManager::EmitRenderPolygon and do all at ShipRenderContext::UploadGenericTextureRenderSpecification
				+ Move TextureRenderPolygonVertex out of RenderCore and make it private to ShipRenderContext

			+ Extra optimizations to test:
				+ vector (no test)
				+ Use a vec4 for the four lonely floats
					+ With multiple batches:
						+ FPS: 16.4
					+ With single batch:
						+ FPS: 12.29
				+ further packing: two vec2 as one vec4
					+ With multiple batches:
						+ FPS: 16.4
				+ Commit
				+ atan in shader - REJECTED
					+ requires two extra vec2 or a vec4
					+ With multiple batches:
						+ FPS: 16.2
						+ ShipRenderContext::RenderGenericTextures: 31.50%
						+ ShipRenderContext::UploadGenericTexture...: 0.56%
							+ vector: 0.56%
			+ Final perf test:
				+ FPS: 16.4
			+ Text single texture rotating
			+ Cleanup:
				+ Ship's test upload
				+ reorder RenderCore::VertexAttributes
			+ Final test with game, real textures
	+ Fix issue with very fast rope sinking
		+ How's a wet rope different than iron hull? Test with test_ship.png
		+ It's because ropes get water (when broken) and gravity force is based off point_mass+water, while integration only uses point_mass
			+ In fact it also applies to all light hulls that are broken
		+ See if can apply buoyancy always, and thus get rid of Points::Buoyancy
			+ Nope: too many hull materials would float
		+ NOPE: Apply water mass at Integrate then? And what about springs - should use new mass there as well?
		+ Two possible fixes:
			+ Just don't consider water at gravity if buoyancy=0 (i.e. if hull)
				- i.e. revert the buoyancy fix
				- result is that wet hull points never feel water weight (and neither buoyancy)
			+ THIS ONE: Or, buoyancy=0 points (i.e. hull points) never take water, period
				+ i.e. they are never set leaking upon spring destruction
				+ First figure out how internal hull gets wet - if it does - IT DOES NOT!


	+ Move RenderContext et al into Render:: namespace and file group
			+ See if TextureTypes.h is still needed and whether it can be moved to GameTypes
				+ After all, ShipRenderMode is in GameTypes
				+ Polygon for now moves to that class that makes it

	+ ToolController rearc:
		+ ToolController has pointer to SoundController, and tells the latter when to play and stop tools' sounds
		+ IGameEventHandler events then exist only for the world-generated noises (e.g. something really breaking), not
		  for the tools
		  + So Swirl, for example, should disappear from IGameEventHandler; some others as well
		  + Tools don't invoke IGameEventHandler->OnSwirl(), for example
		  + Removed:
			+ OnSaw
			+ OnDraw
			+ OnSwirl

	+ CMake:
		+ INSTALL target for release
		+ RelWithDebInfo: Inline any suitable (/Ob2)

	+ Replace ShipDefinitionFile's metadata with ShipDefinition

+ Ships:
	+ Titanic:
		+ Introduce weak metal
			+ Use it underneath funnels

+ Help:
	+ wxWidgets HTML help: http://docs.wxwidgets.org/3.0/group__group__class__help.html
		+ Also, just https://github.com/wxWidgets/wxWidgets/blob/WX_3_0_BRANCH/samples/html/about/about.cpp
	+ Use icons for keys

+ Fix bug: when you reload ship when paused, no clouds & no ship are visible until resumed
	+ World::Initialize():
		+ Calcs connected components for each ship
		+ Builds clouds
		+ Invoked by GameController after pair of world::Reset and world::AddShip()

+ Compare old (released) look with this one, and see if there are changes (in phys, render,...) to take in
	+ Also jellyfish fixed in 1.2.6? NO

+ Release:
	+ Do structure first (above)
	+ Check if less rope mass makes empress of britain not break
	+ Add all other ships
		+ Remember: uppercase and spaces filenames
	+ Do new .shp's:
		+ Carnival
		+ Titanic
	+ Rerun perf profiling
	+ Lower volume of stress sounds, so that break sounds are louder
	+ @Release only: make Krafting.shp the default ship
	+ Screenshots @ github readme
	+ Tell art guy
	+ Send email to Luke
	1.3.0:
	+ Fix Ocean Depth
		+ Affects only textures, not land
	+ Make some ships
		+ Copy three balls
		+ Make ShipTools, -quantize verb
		+ Make some stiffer columns of steel, iron, titanium, etc.
			+ materials: also order rows based on mass
			+ Do last steel column stiff
			+ Iron and Wood
				+ Switch stiff wood with new one
					+ Switch also Titanic
						+ Test
			+ Add "f=..." to template or better "M:S:F"
			+ Test newest ship
		+ Copy, change, and fix from old:
			+ Ship5
			+ Ship6
		+ Cruise vessel
			+ Plan:
				1 + New layer, with thin hull and light interior
					+ Fix buoyancy
				2 + Introduce heavy metals - own row, just grey's
					+ Make strong structural beams
				3 + Adjust colors by peeking at lower layer
					+ Redo the layer with quantize
				4 + Detachable life raft
					+ Make "Nails" material
	+ Call .shp parts ".png.dat"
		+ Rename via git
		+ Edit .shp files
	+ Build and release 1.2.0
	+ Post to forum
	+ Add to gamejolt

+ Lights
	+ need Optional()
	+ Material:
		+ use picojson
		+ Material.ElectricalProperties (optional)
			+ type (Material::ElectricalProperties::ElectricalElementType=lamp, cable, generator)
			+ flat list of all electrical properties, some apply some don't
	+ class Lamp()
		+ points to Point and Point points optionally to ElectricalElement (base abstract of Lamp, Cable, Generator)
			+ ElectricalElement::GetType(){return mType;}: non-virtual, it's optimized by compiler
	+ Move electrical components to ElectricalElements class, an ElementContainer but also like bombs, with update and state machines
	  (but no render)
		+ GameEventHandler and points members
		+ Buffers (type, connected electrical elements, etc.)
		+ AddCable/Lamp/...()
		+ Destroy
			+ Removes self from connected
				+ OR NOT: If Ship::PointDestroyHandler deletes point's connected springs before point's electrical element,
				  then we can assert that electrical element has no connected points anymore already
		+ Getters ("subset" section) for Lamps and Generators
		+ Update()
			+ Invoked by Ship
			+ For each lamp: runs its state machine
				+ Via RunLampStateMachine(LampState &)
				+ Outcome: AvailableCurrent
	+ Materials: self-powered lamp
		+ Just boolean property in JSON
			+ Current light material is self-powered
			+ New light material is not
		+ ElectricalElements: store boolean at LampState (const, passed via cctor)
	+ Point has ElectricalElementIndex (or None), passed at cctor
	+ ShipBuilder:
		+ Create ElectricalElements via ElectricalElements::Add
		+ Give point/elec element index to each other
		+ Add connected electrical elements to each other
			+ See how it's done for points, springs, etc.
	+ Nuke ElectricalElement, Cable, Generator, Lamp
	+ Nuke unused Material electrical properties
	+ Ship::PointDestroyHandler:
		+ Destroy point's ElectricalElement, if any
		+ Do this after deleting springs, so that ElectricalElement::Destroy does not have to remove self from connected elements (see above)
	+ Ship::SpringDestroyHandler:
		+ Remove each endpoint's ElectricalElement (if any - both must be elec elems) from each other's ElectricalElement
	+ Move StrToDuration and includes to GameTypes.cpp
	+ Move ElectricalElementIndex at Points to own buffer
	+ @Ship::Update():
		+ New "inline" electrical section:
			+ UpdateCurrentConnectivity():
				+ Invoke regardless of dirty elements, as generators might become wet
				+ From generators to all reachable points, just propagates visit seq num
			+ ElectricalElements::Update()
			+ DiffuseLight()
				+ For each ElectricalElement::Lamp:
					+ Use its AvailableCurrent and set mLight
	+ Implement full lamp state machine @ ElectricalElements::RunLampStateMachine
		+ EventHandler: OnLightFlicker(size, length, isUnderwater)
		+ Update() takes Points (for underwater)
		+ Implement
		+ SoundController
			+ Add new sound for electrical cable
				+ 2 X random, X 2 underwater
			+ Find 2 sounds ("electrical discharge" or "electric arc")
				+ And make them also underwater
				+ Lower volume of overwater ones
	+ Optimizations:
		+ Take perf analysis of circuit test 1 (2 mins Circuit Test 1)
			- World::Update: 30.15%
				- UpdateElectricalConn: 0.06%
					- Deque::new: 0.01%
					- Deque::~: 0.01%
				- ElectricalElements::Update: 0.05%
				- DiffuseLight: 0.43%
		+ Ship::DiffuseLight: see inverting nested loops (for each lamp: for each point)
			+ Need test ship with many more lamps
			+ Before perf analysis: DiffuseLight: 35.83% == ~30,000 samples; fps=22.10
			+ Switch loops:
				+ Requires first point light zeroing!
				+ After perf analysis: DiffuseLight: 30.63%; fps=24.x
		+ Do perf analysis with complex graph
			+ Need circuit test 3
			+ Impact negligible: Ship::UpdateElectricalConnectivity: 0.21%
	+ Diffusion:
		+ Can test it by itself, by using light material and by cheating with current!
		+ After current propagation:
			+ Zero out mLight of each point (use generation sequence number? useful for other Point properties?)
				+ No, easier and probably faster to do it in same pass as LeakWater - LeakWaterAndZeroLight()
		+ Diffusion: propagate mLight to adjacent points (incl. other lamps),
		  inv. proportional to distance^2, with a graph flood stopping at max distance
		+ Point.GetColour() takes also into account mLight (from itself, not from lamp)
                  and makes alpha blend just like water
		+ Need "off" color to use at lamp point when Lamp is off (different than structural color),
		  used when rendering point in springs/triangles/points
			+ Not used when using textures, of course
			+ Needs material's Color to split in StructuralColor and RenderColor (set to the same except for lamps)
	+ Diffusion improvement: see if can simply add light (rather than max'ing it)
		+ Need to ensure sum is always < 1.0
		+ Or just set to max(1.0, cur+new)
			+ Best when done in point->lamp loop: add up in inner loop, then assign to point as max
			+ Doesn't improve look considerably, and still requires an if

+ Bugs:
	+ Ship::Render: when there are no changes to elements and we keep uploading stressed springs, we don't reset the count
	  in ShipRenderContext::mElementBufferSizes
		+ Fix simply by having Start and End for uploading stressed springs
		+ Done in FB branch
	+ No default args @ vec cctors
		+ Done in FB branch
	+ Fix mem leak
		+ Plan:
			+ Calc base rate of growth: 500K/sec
			+ Comment out ShipRenderContext::Render halves until find the one
				+ When nothing done in loop: 159K max
				+ Just PinnedPoints: grows fast
				+ No texture & no buffer: grows fast
				+ No parameters: grows extremely slow
				! No OrthoMatrix param, Yes AmbientLight param: grows fast
				+ Yes OrthoMatrix param, No AmbientLight param: grows extremely slow
			+ Undo all (dbl-check)
			+ Commit other work
			+ glHint(..._HINT) x 2 at Render::Start()
		+ Cut down on calls to glSetParameter:
			+ Before FPS: 27.4
			+ ShipRenderContext::SetXYZ (ortho, visible world coordinates, and light)
				+ Sets into all programs
				+ Nuke member references
			+ ShipRenderContext::cctor:
				+ Sets into all programs with value from cctor args (this time by val)
			+ RenderContext::UpdateXYZ
				+ Set into all ships
				+ Passes current values by val into new ships
			+ After FPS: 27.4
			+ Verify leak is slower
			+ Do also at RenderContext
	+ Fix issue with clouds and canvas size (wrong aspect ratio)

+ Roadmap:
	+ 1.7.0
		+ Magic spring optimization (*)
			+ Then decide whether to increase the number of basis iterations, and whether to adjust strength
				+ SQ: 2.0 => Basis = 24
				+ Strength to maintain Titanic auto-break: <= 0.397928
					+ Change max strength to 10 and see again value: 0.403352
				+ Tune bombs
				+ See pin
				+ Change ocean floor bump - remove center chasm and move it right
				+ Fix sound quantity
				+ Adjust volume of those two high-pitched sounds
				+ Adjust container ship
				+ Bomb blast radius: 2.0
				+ Fix missing RC bomb pings
					+ verify break & stress sounds are still good
		+ Test collisions with seafloor being less destructive
		+ Fix crash
			+ Springs and Triangles cctors: pass default-ccted FixedSizeBuffer() there, not {}
			+ Then revert floor collision
			+ Remove TODO's with checks at:
				- Ship.cpp
			+ Clear super/sub buffers in destroy handlers

		+ Move inertia & ultra-violent mode
		+ Move tool extension: rotate
			+ Shift: up ccw, down cw
				+ Make it relative to prev pos
			+ Change icon
		+ Slider for water drag adjust
			+ Test with water drag depending on v^2
		+ Update help:
			+ Anti-Matter bombs
			+ Move tool

		+ See collisions' bug
			+ Move tools always update velocity
				+ Checl L'n'F'

		+ Strength adjust at 1.0

		+ Decide max water drag:
			+ 100: OK,but not really "draggy"
			+ 10,000: awesome

		+ Extended status: take stats from RenderContext
			+ RenderContext::Stats:
				+ LastRenderedShipSprings
				+ LastRenderedShipTriangles
				+ LastRenderedGenericTextureTriangles
				+ LastRenderedConnectedComponents
				----
				+ Reset stats at each RenderContext::RenderStart()

		+ Redo full perf analysis

		+ Recheck L'n'F' for current collision handling
		+ Recheck L'n'F' for strength
	+ 1.7.5
		+ Test a density adjustment to make ships float more easily without affecting bending
			+ 0.55
			+ See real weight of steel H-beam: 151 Kg
			+ See old ships
			+ See Roma: work on it and see L'n'F'
			+ If OK:
				+ Fix ships:
					+ Base: a bit heavier (lower center of mass) - make it stiffer in the process
					+ Container ship: make it heavier, containers are too light and ship won't sink
						+ Rename .dat's
					+ Submarine
				+ Adjust materials.json
					+ Python script for materials
					+ except for double-bottom's
				+ Remove hack at Materials.cpp
				+ Recheck all ships
					+ Fix Submarine
				+ Redo materials template
		+ See if can make Titanic not take water all up quickly
		+ See if now some TODO ships are buoyant
		+ .dat renames:
			+ Ship 0: PM_Oasis
		+ Try out auto-texture
			+ Awful
			+ See with nn_mipmap_linear
			+ See with custom upsize
		+ Figure out strength adjustment based off # of simulations
		+ Check structure/texture alignment issue
			+ Fix
			+ Fix Titanic
				+ Fix ropes: offset -1L, +1B
			+ Fix Queen of Unova
				+ Fix ropes: offset -1L, +1B
				+ Fix eaten things
		+ Reduce sparkles' angle
		+ Impact bomb (*)
	+ 1.8.0
		+ Multi-layer ships
		+ Initial GL canvas size issue
		+ Focus kill/tools issue
		+ Add cloth material (*)
		+ Improve light diffusion (*)
		+ Buoyancy rearc (*)
		+ Crazy ropes:
			+ Don't touch water retention
			+ Add new "water diffusion speed" - value=0.5
				+ Materials system
				+ Points buffer
				+ Use at UpdateWaterVelocities
				+ Rope: 0.015

			+ Make water quickness a "water quickness adjust", between 0.0 and 2.0, default = 1.0
				+ Also @ setting dialog
			+ Test:
				+ Ropes @ ATest
				+ Flags/Cloth
					+ Also with move
				+ Settings Dialog
				+ Perf (after optimization above)
		+ See if need to bump up again global damp
			+ Test: bomb on Titanic; splinter springs tend to dance a tad too much
		+ Add Roma
			+ .dat renames
		+ Light:
			+ Add low/medium/high-dimmed lights and portholes (*)
		+ See if cloths should be lighter - to not break ropes
		+ Bubbles
		+ Flood tool
		+ Test if debris (and sparkles?) really fly out of water
		+ Redo Submarine - thicker to avoid bending
		+ Lights with different chances of turning off when wet
			+ Do test ship
			+ Do
		+ Trawler with cloth
		+ Ship loading: resize of texture must depend on actual image size (don't get huge)
		+ Make these ships more breakable:
			+ Titanic
			+ Krafting
		+ Porthole: "wet_failure_rate": 3.0
		+ Terrain adjust tool
			+ Managed by World via OceanFloor
			+ See if can get rid of extra sample
				+ Also at Water
			+ Fix zero-index
			+ Undo 500 samples
			+ Test multiple destruction sound w/delay being 50ms
			+ Sound (hammer)
			+ Changelist
		+ Wind and cloth (*)
		+ Do we still need render color in material?
			+ YES - For ephemeral particles
			+ Update guide
		+ SettingsDialog: advanced tab
		+ Bubble tool:
			+ Hide menu, but ensure it is still reachable
			+ Do inverse visits at World anyway
		+ Log marker w/timestamp
			+ -------------------- 519558699552151
		+ Complete "How to Build a Ship" guide
		+ Move all guides to own folder "Docs"
			+ Also material_template's
		+ Air bubble randomization
		+ WiX Installer
			+ Rearc:
				+ Heat only used for:
					+ Data - ComponentGroup "Data", own wxs
					+ Ships - ComponentGroup "Ships", own wxs
				+ Then manual ComponentGroups:
					+ Binaries
						+ w/proper platform
						+ w/shortcuts
					+ license, readme, changes

			+ No upgrade/downgrade
				+ Version in product name
				+ New product guid each time
					+ Just use new variable
			+ Program files
			+ Desktop shortcut
				+ No working directory
				+ Check icon
			+ Start menu shortcut
				+ Check icon
			+ UI
				+ Initial screen
				+ Progress
				+ Final confirmation
				+ Canceled
				+ Already installed
			+ Icon of add/remove programs
			+ Version main binary:
				+ CMake: only include resources if MSVC
				+ Use version defines from Version.h
			+ Test repair
			+ Remove whole folder on uninstall, even with users' files
				+ https://helgeklein.com/blog/2014/09/real-world-example-wix-msi-application-installer/
		+ Installer: add location picker
	+ 1.9.0
		+ Ship file dialog (*)
		+ Fix metres bug
			+ ShipPreview must carry original size, before resize
		+ Add new ships
		+ Installer does not install guides
		+ Change version
		+ ConnectedSprings/OtherEndpoint Optimization (*)
		+ Create "z_buffer" branch
		+ Zbuffer (*)
		+ See if can avoid freezing (so, deleting) springs to which we have bombs attached
			+ Don't destroy spring if it has a bomb attached, at:
				+ StressedSprings break
			+ Test L'n'F':
				+ 3 Bombs
				+ Anti-Matter bomb (should fall at some point)
		+ ShipLoadDialog: make sure default Ships directory is always in recent dirs, first
			+ Test w/empty preferences
			+ Also add Home button
		+ Fix bug with cross-of-light spawning underwater
		+ Fix sailing ship - cut sail in texture (but not in psd)
		+ Fix Titanic's jagged sides
		+ Tooltips (*)
		+ Update changes.txt with tooltips and z-buffer
		+ Fix SettingsDialog/RecentDirs bug: when new dir loaded, it doesn't appear in combo
		+ Make flood tool adjustable
			+ Two settings - radius and quantity of water
			+ Make sure ultra-violent mode applies to both
			+ SettingsDialog
				+ Use same sliders as DestroyRadius
			+ Test mins and maxs
		+ Make ropes less crazy when they get wet
			+ Test: base tall, slice rightmost tip
			+ Lower water intake adjust seems to help: add per-material
				+ StructuralMaterial: WaterIntake: 0.1 for Rope, default 1.0
					+ Also to guide; dimensionless
				+ Point buffer
				+ Use
			+ Find good value:
				+ 0.05
			+ Perf:
				+ Pre: 29.1/29.2
				+ Post: 29.3/29.3
		+ Add more cloth colors
			+ Redo structural palette afterwards
		+ New render setting: Ocean Render Mode {Texture, Flat, Depth}
			+ One vertex attribute structure to rule them all
				+ Texture
				+ Flat
				+ Depth
					+ restWaterHeight is sea depth, no need for: RenderContext need to be told of changing sea depth by GameController
					+ Rename as seaDepth
			+ 3 shaders
			+ VisibleWorld bounding box in viewmodel
				+ Test CrossOfLight
			+ SettingsDialog:
				+ RenderMode
				+ 3 colors
			+ Test all 3 with:
				+ Ambient light intensity
				+ Ocean transparency
			+ Find good default colors:
				+ Depth
				+ Flat
		+ New render setting: Ocean Floor Render Mode {Texture, Flat}
			+ One vertex attribute structure to rule them all
				+ Texture
				+ Flat
			+ 2 shaders
			+ SettingsDialog:
				+ RenderMode
				+ 1 color
			+ Test all 2 with:
				+ Ambient light intensity
			+ Find good default flat color
		+ Initial help window (HTML) @ Startup
			+ UserPreferences tag to suppress
	+ 1.9.1:
		+ Fixed crash when attemping to load a ship from a directory containing an empty ship
		+ Fixed crash with air bubbles tool
		+ Spring Damp setting
			+ Test mass changes (now that coeffs are recalc'd on mass change)
				+ Bomb attaches
			+ SettingsDialog: advanced
			+ Play to see if can find value
			+ Try dividing by dtSquared
		+ Fix V offset of AM bomb cursor
		+ Slice-while-paused bug
	+ 1.10.0
		+ See if lights can make texture colors come out at night, rather than just yellow-izing it
			+ ShipTrianglesTexture shader: use local light as "additive" to ambient light (to draw colors)
			+ Split Points:: colorBuffer upload to own func
				+ RenderContext: range-based
			+ Remove logs and shader TODOs
			+ Check intensity at distance==0
			+ Change luminance to 1 rather than 2
				+ See first what difference it makes
				+ Change in materials.json
				+ Enforce in electrical material
				+ Verify fixes issue
				+ Constrain luminiscence adjust to max 1
					+ Or change how to apply adjustment
					+ Change tooltip and minimum
			+ If it works, also these shaders:
				+ TrianglesColor
				+ PointsColor
				+ Ropes
				+ SpringsColor
				+ SpringsTexture
			+ See if passing vec instead of floats among shaders helps with perf
		+ EventTickerPanel:
			+ Fix name of AM bomb @ placed (and @ al?)
		+ Bounded World
			+ GameParameters: MaxWorldWidth, Height
				+ Remove MaxZoom, MinZoom
				+ Use very small world for now
			+ Constrain view changes:
				+ ViewModel:
					+ float ClampXYZ() -> clamped value
					+ CanvasSize changes: make sure the largest visible world dimension stays the same
						+ i.e., adjust zoom so that the new visible world dimensions are contained within the old one
				+ Use at GameController:
					+ Zoom updates
						+ Get back value
					+ Camera updates
						+ Get back value
					+ CanvasSize update: pickup changes and reset smoothing
				+ Test
			+ Constrain physics:
				+ Ship::Update: at end of mech physics (after last integrate):
					+ Destroy points (also with sounds, it's OK) that are outside of bounding box
					+ No destroy points, just do simple bounce w/bounded velocity
			+ Verify AM bomb issue is gone
			+ Test in Debug
			+ Make larger bounding world
				+ W: 10000
				+ H: MaxSeaDepth * 4
				+ w/static_assert for ocean depth
			+ Figure out where it is that the submarine disappears
			+ Fix water drag
				+ Find coefficient for linear drag in "slow" range
				+ When done: see if bounds of water drag adjustment are still good
					+ Test at new max (1K) - do ship pieces go to a standstill?
			+ Verify AM bomb issue is gone
			+ Get current FPS
			+ Changes.txt
			+ Merge to master
		+ See move tool changing center
			+ Is it because of missing last step?
				+ Should finalize only after last step, making sure to clamp elapsed to Lag first
		+ Create dump upon crash
			+ https://stackoverflow.com/questions/9020353/create-a-dump-file-for-an-application-whenever-it-crashes
			+ In app folder, via StandardSystemPaths
				+ Under \CrashDumps
			+ Try with empty png and corrupted png
		+ VAO (*)
		+ Misc OpenGL Optimizations (*)
		+ Secondary PlaneIDAsFloat buffer
			+ We only pay the price sparingly, but reap the benefits at each frame
			+ Code
		+ Vertex buffer optimizations (*)
		+ Update FPS & perf analysis
		+ Water Contrast @ 0.875?
		+ UIPreferences
		+ Decay (rust) (*)
		+ Ship descriptions (*)
		+ ShipRenderContext: make water color depend on ocean render mode color
			+ Get FPS before
			+ Water color in shader has to become parameter
			+ OceanRenderMode:
				+ Texture: waterColor=<constant matching now>
				+ Flat: waterColor=<that flat color>
				+ Gradient: waterColor=<mid color>
			+ Test x 3
			+ Get FPS after
		+ Ships
		+ Less stress sounds: use mIsStressed buffer, w/high and low watermarks
			+ Get FPS before
			+ Do
			+ Test
			+ See if can remove "negligible" check now
		+ Fix air bubble progress issue
			+ Confirm repro test
			+ Get FPS before at bubble tool:
			+ Do
			+ Test
		+ Send for testing
		+ New ships
		+ Check "Smash" bug
		+ Add other testers to About box
		+ Finalize descriptions
		+ Release
	+ 1.11.0:
		+ Orphaned points
		+ Increase # of ephemeral particles
			+ And thus lower water intake threshold for air bubbles
		+ Sea and Ocean Floor rearc(*)
		+ Change cover art to Logo2
			+ About box image
				+ And remove "Cover art" credit altogether
			+ Installer
		+ Try to build with Runtime Type Information disabled
		+ Add world end markers
		+ Repair tool
		+ Fix Linux build break
			+ Do specialization outside of class
			+ Set /permissive- for all projects
		+ Take Mathias' pull request
		+ Fix github's clouds bug
		+ Un-sinking (*)
		+ Floatsam: see if using (waterY + 0.1) at UpdateWaterIntake helps
		+ Are we really forced to set point colors to structural colors?
			+ Can we always use the (sampled) texture colors?
				+ After all, texture layer is now mandatory!
			+ Test look'n'feel
		+ Also dry points should rot (*)
		+ Pick tool (*)
		+ Add new materials:
			+ Rubber
				+ SoundType=Rubber
				+ Hull, Non-hull
				+ 2x (hard and soft)
					+ 3 colors each
				+ Make repair sound (copy from one of the break)
				+ Make separate balls
			+ Test weight of new non-hull rubber
				+ ...and make sure hull rubber sinks
			+ Fiberglass
				+ SoundType=Plastic
				+ Hull, Non-Hull
					+ 3 colors each
				+ Make ball at "New Materials Balls"
				+ Make repair sound (copy from one of the break)
			+ Plastic (ABS)
				+ SoundType=Plastic
				+ Hull, non Hull
					+ 3 colors each - LEGO colors
				+ Make ball at "New Materials Balls"
			+ Redo template
			+ Send to Michael
			+ Add to changes.txt
		+ Probabilistic Destroy
			+ Probability is zero at radius
			+ Cleanup:
				+ Also do fraction at other continuous tools
				+ Remove 1.0 at ModulateCursor
		+ Try to show tip window after first Render
			+ Undo hacky test changes
			+ mHasStartupTipBeenChecked = false
			+ OnGameStep:
				+ at beginning: only schedule timer if mHasStartupTipBeenChecked
				+ at end:
					+ if !mHasStartupTipBeenChecked:
						+ Show startup tip dialog
						+ schedule timer
						+ mHasStartupTipBeenChecked = true
			+ Check refresh when moving tip window
		+ Dry points when repaired
			+ Halve moved points' water
		+ Do perf analysis for many air bubbles
			+ ShipRenderContext::UploadGenericTexture: vector::emplace - 3.5
			+ ShipRenderContext::RenderGenericTextures: memcpy - 1.0
			+ Points::UpdateEphemeralParticles: sin - 1.0
			+ Try dedicated upload
				+ Take FPS pre: 20, UR=113-132 @ 4K GenTex's, 62/300 planes
				+ Do
					+ Use same VBO, two draw calls
						+ VBO first used for AirBubbles, size=MaxEphParticles
						+ Then re-allocated for GenTex's
							+ Allocate only if necessary, i.e. if new size > last (MaxEphParticles)
				+ Take FPS after: 22.3, UR=133
			+ changes.txt
			+ ParameterSmoothing: make it with sin (btwn pi/4 and pi/2)
		+ Shallow Water Equations (*)
		+ Try to change speed of particles at repair
			+ See big notebook
		+ See problem with too many bubbles
			+ See if water is constant after hole plugged
				+ Custom probe w/total water in ship
				+ Remove probe afterwards
			+ See if water is turbulent
				+ Temporarily change shader to draw pressure waves
			+ See if true: realistic sinking of ship is 3 water intake and 0.25 water diffusion speed
		+ Use precalc'd sin for bubble vortex
			+ Pre FPS: 22.5, 125
			+ Make static precalc'd sin (lo-res: 512)
			+ Post FPS: 23.4, 136
			+ Do perf analysis
		+ Send for testing
		+ Do test with "the possible ships" broken
		+ Double-check latest rotting speed
		+ See frequency of wind ripples
		+ Font 2
		+ Perf:
			+ ExtractShaderParameters: regex::search
			+ Utils::ParseJSONFile::RemoveJSonComments
		+ Installer:
			+ Add repair when already installed
				+ Tests:
					+ Install codepath
						+ Verify registry keys
						+ Verify control panel
						+ Verify both shortcuts
						+ See why game does not start visible
					+ Repair codepath
						+ Verify delete bin file re-added
						+ Verify desktop shortcut re-added
					+ Uninstall codepath
						+ Verify no registry keys left
						+ Verify orig files gone
						+ Verify added (ship) files gone
						+ Verify control panel gone
						+ Verify shortcuts gone
					+ Tooltips at install
					+ Repair and uninstall from control panel
						+ Repair (w/real deleted)
						+ Uninstall (w/extra ship and delete verification)
				+ Make repair and remove buttons
			+ See if installer for current user removes need for admin consent
				+ Check app folder
				+ ShipLoadDialog does not show AppFolder
			+ Uninstall older versions except one
			+ Info URL
			+ Send installer for testing
		+ Change .shp names to match filenames
			+ Use python script to detect
		+ Bugs:
			+ Goliath crashing
			+ Mike's weird waves
			+ SamminAter unsupported OpenGL ext => crash
				+ Test error in Debug mode
				+ Give him a relwithdebinfo
				+ Check if dir is null
		+ Michael Bozarth's ships
			+ Check Carpathia differences
			+ Check OpenGL error with 3 queen mary's and titanic interior
				+ Check first why it crashes afterwards
				+ Then, do explicit texture size check
			+ Fixes to do:
				+ 1: Titanic in a bottle (leak): his don't leak - I fix it
					+ In final, verify
				+ 2: Ed Fitzgerald (ropes): I do it
					+ In final, verify
				+ 3: Cargo ship 2 (too heavy): asked
				+ 4: Lego Titanic (offset): done
				+ 5: RMS Britannic (ropes): I do it
					+ In final, verify
				+ 6: Queen Mary (ropes): I do it
					+ Retaken
				+ 7: Take electrical of RMS Titanic with Lights
					+ Can't see the difference; asked
					+ No changes
				+ 8a: 3 Queen Mary 2's (large texture): done
					+ Retaken
				+ 8b: Titanic Interior (large texture): done
					+ Retaken
			+ Run verifier on all ships
		+ Do movie
			+ Repair
				+ With move and rotate
			+ Rubber ball
		+ Release
	+ 1.11.1:
		+ Fix crash
			+ Remove TODO logs and checks (discard all changes)
			+ Fix bug
			+ Test
		+ Change version
		+ Fix HMT Olympic b
		+ Update changelist
		+ Check if other bugs
		+ Release
			+ Git
			+ GameJolt
		+ Merge into 1.12
	+ 1.12.0:
		+ Fix latency of move tool
		+ Do perf analysis
			+ Usual sample-based one
		+ SFML fixing:
			+ Re-run FS cmake
			+ Redo FS release build
				+ Verify static CRT in output
			+ Redo FS install build
				+ Verify static CRT in output
				+ Verify guides in output
		+ Automatic updates checker via file placed on floatingsandbox.com
			+ UIPreferences::CheckForUpdatesAtStartup
			+ class UpdateChecker:
				+ Wraps separate thread and conveys result via UpdateCheckOutcome
				+ Getter for UpdateCheckOutcome:
					+ Returns null if not done yet
					+ Returns UpdateCheckOutcome when done
				+ Uses SFML::Network::Http
			+ At startup:
				+ MainFrame starts UpdateChecker at end of PostInitialize, and then polls it as long
				  as it's not null
				+ If poll OK && new version, displays popup, then nullifies it
					+ Uses NewVersionDisplayDialog
				+ Redo: kick-off is by timer after 10 secs, rather than at PostInitialize() - everything else stays
			+ Help->Check for Updates
				+ MainFrame: menu item
				+ CheckForUpdatesDialog (Modal Dialog)
				+ cctor starts UpdateChecker
				+ Timer does progress (calling wxGauge::Pulse)
				+ On poll OK, displays with NewVersionDisplayDialog
			+ NewVersionDisplayDialog:
				+ If ccted with "atStartup", displays checkbox for turning off check on startup
			+ Preferences window:
				+ Check for updates at startup
					+ Toggling checkbox resets version blacklist
			+ Test:
				+ Does not notify for old version (Startup, Check)
				+ Notifies for new version (Startup, Check)
				+ Everything stays the same at next check (Startup, Check)
				+ Blacklist checkbox clicked and re-clicked does nothing (Startup)
				+ Blacklists version for next check (after checkbox) (Startup, Check)
				+ Does not check at next check (after checkbox) (Startup)
				+ Preferences
					+ Blacklist reset
				+ From http
			+ Cleanup:
				+ "Click here to download ...":
					+ Button
					+ Change text
				+ Cleanup changes.txt
				+ Trim changes.txt at www
				+ Timer: 10 sec
		+ Make sure sfml network is crt statically linked
		+ Bugs:
			+ Wavemaker sound when paused does not pause
			+ Emplace force fields at interactions
			+ Move tool now doesn't work when paused
				+ See why
				+ Fix
		+ Multiple textures for:
			+ Land
				+ Each has entry in texture DB
					+ Some new ones have 512 - decide one by one
				+ RenderContext::GetAvailableLandTextures()
				+ SettingsDialog: drop-down
				+ RenderContext::SetOceanFloorTexture(size_t)
				+ Test ShipPreviewControl (for zero-sized bitmap)
				+ Rename TextureRenderManager to UploadedTextureManager
			+ Ocean
			+ Changes.txt
		+ Shaders:
			+ Land texture:
				+ Texture compression on edge
					+ Try (4*x)^(0.2) / (3 * ((4*x)^2+1)) + x
				+ Add non-linear (same non-linearity as ocean) darkening (lightest at ocean surface)
			+ Ocean gradient: make non-linear
				+ Cleanup shader afterwards
			+ Ocean texture:
				+ texture compression on edge
				+ add non-linear (same non-linearity) darkening
		+ Optimize GameOpenGL::UploadMipmappedTexture: alloc write buffer once and swap pointers
		+ Fix bug at bump-map interpolation at ocean floor: need to calc fractional part
		+ Settings dialog:
			+ Merge Mechanics and Fluids and World into "Generic"
				+ Mechanics box
					+ Add decay
				+ Fluids box
					+ Move WaterLevelOfDetail to Rendering, next to WaterContrast
				+ Lights box
			+ Do spacers at Ocean+Sky and Wind+Waves as Mechanics and Rendering
			+ Interactions: add boxes (and make like Mechanics):
				+ Interactions
				+ Side Effects
				+ Make tools two rows and move side-effect to left
		+ Make slider for air bubble density
			+ SettingDialog: enable/disable based off checkbox
				+ Move checkbox
			+ Max=128
				+ Ensure cur value fits slider
			+ Fix issue with randomization of density
				+ Try with redoing randomization of all leaking points at each param change
		+ Ocean rendering: replace stencil with first rendering w/zero transparency
			+ Remove MatteOcean shader, now that it's not needed anymore
			+ Do pass on all ocean textures doing exactly what we did before (cornflower blending)
			+ Redo flat and gradient ocean colors

		+ Waves need to be further limited
			+ Make repro: tsunami on manually-created high wave field
			+ Tsunami and rogue wave: target H is absolute, not based on current H
			+ If ok:
				+ Update changes.txt
		+ Merge to master
		+ Send to testers
		+ Move tool: make sling easier
			+ 1) Merge Move tools
				+ Base templated class
				+ Derived only has virtual's for GameController calls
			+ 2) Improve
		+ Multi-music
		+ Sea and land shaders: use smoothstep's instead of complex stuff
			+ float increment = -10.0 * (1.0 - smoothstep(0.0, TODO.0, textureCoord.z))
		+ Repair tool improvement:
			+ RepairTool passes RepairSessionId, RepairSessionStepId
			+ Points has buffer of struct RepairSmoothing{RepairSessionId currentSessionId, RepairSessionStepId currentSessionStepId, float smoothing}
			+ Repair interaction when engaging "other endpoint":
				+ Zero's smoothing iff currentSessionId != this session ID
					+ And sets currentSessionId = this session ID
				+ Advances smoothing (smoothing += (1-smoothing)*alpha) iff currentSessionStepId != this session step ID
					+ And sets currentSessionStepId = this session step ID
			+ Test and fine-tune alpha
			+ Remove logging
			+ Fine-tune inertial velocity exponent
			+ See why points fly at weird angles
				+ See if due to (wrong) intertial: does it happen with no inertial? NO.
			+ See Moleskine for Attractor vs Attracted
			+ Deal with same conn comp ID
			+ Undo decay (halve it)
			+ See missing springs
			+ Play with tolerance
			+ See if conn comp logic:
				+ Is broken (think): NO
				+ Is useful: commented out for the time being (for AwesomeYorkie)
			+ Get AwesomeYorkie's second feedback
			+ Try with smoothing done only at attractors via step ID
			+ Ropes strength amplifier/reducer
			+ Try to put back attractor/attractee exclusion
			+ Radius = 2.0
			+ Alpha = 0.0025f
			+ Find multiplier (play w/strength slider for the time being, make high max (for now))
			+ Commit
			+ See if can use the duration of the role
				+ A point shouldn't take the role of attracted if it was attractor in the immediately-previous step
				+ A point shouldn't take the role of attractor if it was attracted in the immediately-previous step
			+ See if may have slower startup of force
				+ Replace whole smoothing with:
					+ Attracted force is <MaxForce>*smoothstep(0.0f, 10*60, # of consecutive session steps as attracted)
						+ Need to track # of consecutive steps as attracted in this session
			+ Test repair strength adjustment as "repair speed adjustment"
				+ If ok, rename @ code & settings dialog
			+ Then see if can put radius back to something higher
			+ See if rope kindness is still granted
			+ Cleanup logs and code for Correct/Wrong counts
			+ Cleanup TODO
		+ Fix exponential slider core for negative edges
		+ Put back links
		+ Fire Extinguisher tool
			+ Action
				+ Cool, with heat subtraction
			+ Shader
				+ Radial noise + rotation
				+ Somewhat transparent, so that flames show through
				+ Full radius
			+ Sound
				+ Volume
			+ Cursor
				+ HotSpot
		+ Add slider for repair tool radius
		+ Add slider for flamethrower tool radius
		+ Rotting:
			+ Fix bug: "Idk if this is a bug or not but the tiny particles that appear after something is destroyed start flickering like
			  christmas lights with rot at 1000 when uderwater"
			     + Yes: W=112.826 T=288.003 Decay=3.93467e+06
			+ Bump up rot speed for dry stuff, takes 98 minutes now
				+ They all agree: a ship should rot in 30 minutes on the surface, and in 15 minutes when flooded
			+ Tests:
				+ Surface rots zero, submerged a bit more, flooded more, leaking a lot
				+ Christmas light bug: with acceler8r at 1000.0 when uderwater
				+ Stainless steel does not rot when acceler8r at 1000.0
				+ 15mins (@50fps) for flooded when acceler8r at 1.0
				+ 30mins (@50fps) for exposed when acceler8r at 1.0
				+ Doesn't rot when acceler8r at 0.0
		+ Thanos' Snap
			+ Tool managed by GameController
				+ Dedicated state machine (mThanosSnapStateMachine) stored in queue
					+ Additive, up to N (8), circular
					+ Move state machines to separate cpp: GameController_StateMachines.cpp
					+ At beginning (first insert):
						+ Fire "StartSilence" event
							+ SoundController::OnSilenceStarted: stop sinking music
						+ Call Wind::SetSilence(float between 0.0 and 1.0)
							+ Wind stores it, and uses it at Update()
							+ Wind state machine progresses, but final result is multiplied by silence
								+ And rely on moving avg to smooth the step
					+ Throughout: call World::ApplyThanosSnap(centerPos, innerRadius, outerRadius) X 2
						+ Called for slices, advancing from mouse position at moment of application
						+ Ship::ApplyThanosSnap(centerPos, innerRadius, outerRadius)
							+ Only does between two outermost edges, so to catch moving things
							+ Deletes springs (and consequently triangles) (w/no noise)
							+ Imparts velocity on particles
						+ OceanSurface::ApplyThanosSnap(centerPos, innerRadius, outerRadius)
							+ Flattens surface that falls in crown to ~-1.0
					+ At end (last removal):
						+ Fire "LiftSilence" event
							+ SoundController: niks
						+ Call Wind::SetSilence(0.0)

			+ Cursors (up and down)
			+ Snap sound
		+ Heat and combustion
		+ ShipLoadDialog: search bar
		+ Check bugs:
			+ Scrolling past world end/black triangle
			+ Mike's rotting when water is inside: he's right
		+ Add new materials: black cloth, black wood
		+ Take Mike's music
			+ Test flac versions
			+ About box: add Stuart's Piano World, https://stuartspianoworld.com/
	+ 1.13.0
		+ Refresh current perf
		+ Add those 2 Lava textures
			+ Need to remove blue overlay first, apply to textures directly making a second "Caraibic" version of them
				+ Color: 87cefa rgbColor(0x87, 0xce, 0xfa), // cornflower blue
				+ Transparency: 0.8125
				+ Make "Caraibic" version the default
			+ Add two lava
		+ Version overhaul
			! Goal: "beta" shows up in file details (product version, etc.) and in About Box
			+ Version class:
				+ No build number but beta instead, with beta=X always < beta=0
				+ Unit tests
			+ RC file
				+ Test with both FileVersion,ProductVersion having the same (w/"beta")
					+ Beta 1
					+ Beta 0
			+ Revert all changes:
				! We are happy to release 1.13.0.592
				+ No beta's needed, revert to 4 components, just rename them (patch, build)
		+ Windows installer: rethink strategy, go for upgrades
			+ Make UpgradeCode fixed value, that is, the one from 1.12.0
			+ ProductCode changes for each release
				+ It's the only one that changes
			+ Move back component GUIDs from vars to hardcoded attributes, using same as in 1.12.0
			+ Change HeatPerUser.xslt: "todo" comments for 1.12 fixed
				! Ideal would be to have version-agnostic reg key as keypath (a new one), but then 1.12.0 components would not seem
				  to be installed
			+ Do <MajorUpgrade> w/AllowSameVersionUpgrades=Yes
				+ See https://support.firegiant.com/hc/en-us/articles/230912187-Implement-major-upgrade-
			+ Try changing keypaths (folder & reg key)
				+ Rethink their values
			+ Tests:
				! To verify:
					! Final result
					! Text of dialogs
				+ Clean install
				+ Upgrade
				+ Maintenance->Repair
				+ Maintenance->Uninstall
				+ Upgrade when Ships folder contains additional ship files
			+ Add to changes.txt
		+ ShipLoadDialog: Crack ShowModal() puzzle
			+ ShowModal()
			+ Try:
				+ PollQueue: consume 10 events at a time
				+ Pre-created ShipLoadDialog member
			+ Cleanup:
				+ GameController::Pause:
					+ Move GameWallClock pause here from MainFrame
				+ Make MainFrame::SetPaused(bool) with content of pause menu handler
					+ MainFrame has "stack" (counter)
					+ Invoked by:
						+ Pause menu handler
						+ ShipLoad cycle
				+ Remove "todo" Log's at ShipLoadDialog
		+ Run with AppVerifier to detect cause of crash at reload
		+ Make sure we don't copy Temperature buffer twice
			+ Make Buffer::swap(Buffer<T> & other)
			+ Pre: 28.1/28.8
			+ One copy only
			+ Post: 28.5/28.7
			+ Do also at Water
			+ Post: 28.9/29.1
		+ ShipLoadDialog:
			! Do own paint, no controls
			+ Replace paint with overriding OnDraw(), // https://docs.wxwidgets.org/3.0/classwx_scrolled.html
			  which provides scrolled coords
				+ But we have to deal with mouse events anyway
			+ See if we need the mem DC and/or double-buffering
				+ Try with double-buffering off
			+ Mouse events
				+ Calc tile based off mouse coords, panel position, and vscroll
				+ Single-click
				+ Double-click
			+ Try making panel a wxWindow instead (as it doesn't have child controls)
			+ Nuke old code and rename ShipPreviewPanel
			+ Fix empty bitmap/exception
			+ Search:
				+ Test adding author
				+ Button for "next"
					+ Do icon
					+ Functionality
					+ Do enable state machine
			+ Remove TODO Log's
			+ Fix SS Arizona
			+ Test:
				+ Dir changes
					+ With tree
					+ With dropdown
					+ With Home
			+ Merge into 1.13
			+ Update changes.txt
		+ Lava textures
			+ Update changes.txt
		+ Benchmark vectorized spring lengths (see Moleskine)
			+ Move VectorNormalization_Vectorized_AndLength_Reciprocal_LibSimDpp to Algorithms
		+ Cache layout optimization for points and springs (*)
		+ Slider text box editable (*)
		+ Adjustable zoom and pan increments (*)
		+ Sparkles with shader
			+ Impl:
				+ ShipRenderContext
					+ VBO, VAO
					+ Shader
						+ Need sparkleSpace position
						+ Complete
							+ See perf (@ShaderToy) w/length instead of length2
					+ UploadSparkle: make vertices
						+ Quad size is 4x4
				+ Ship
					+ UploadStart/End
					+ Upload:
						+ Normalize velocity to (-1,-1) -> (1,1) and adjust sign
					+ Expire sparkle when underwater
					+ Simplify sparkle state machine, if there's stuff we don't need anymore
				+ Watch videos and adjust butterfly
					+ Use full quad
					+ Shader
					+ Butterfly: gaussian around direction opposite to movement
					+ Faster max (and min) speed: * 1.5
			+ Cleanup:
				+ Nuke sparkle texture(s)
				+ Shader:
					+ Get rid of velocityVectorAdj
				+ GameRandomEngine renames
			+ Try:
				+ More thick
		+ Lights perf improvement (*)
		+ Settings Manager (*)
		+ Fix guy's name in Aurora:
			+ Need:
				+ Name: HummeL
				+ URL: https://www.youtube.com/c/HummeL_Prog
			+ Ship
			+ AboutBox
		+ Print speed (in m/s) after throwing objects with both move tools
		+ Move status text toggles to UIPreferences, so that they're save-able
			+ Leave menu entries, they now talk to UIPreferencesManager
				+ Refresh status after each change
		+ Music from Officer TimCan:
			+ Convert SleepingSun full and see if may fit in FS; if not, take the short version
			+ Add the three songs
			+ Add to about box
		+ Storm (*)
		+ Ocean darkening:
			+ See if may do exponential
			+ If so, fix marianas trench
		+ Ocean detail adjust:
			+ See if at zero there's no tool; if so: make minimum > 0
		+ Need to align Points' first ShipElementCount elements
			+ Check all references to mShipPointsCounts et al
			+ Run in debug
		+ Nuke unused water bubble texture
		+ Water bubbles: try with allowing CumulatedIntakenWater to go negative: NO CHANGE
		+ Text when repair completed: "Completely Repaired!"
			+ At iteration where at least one spring or one triangle has been repaired, and no more fixable springs
			  exists and no more destroyed triangles exist
				+ Maintain flags during visit
				+ Maintain per-ship counts of broken springs and triangles, updated at:
					+ SpringDestroyHandler and TriangleDestroyHandler
					+ Repair handlers
		+ SpinCtrl at SliderControl?
			+ Range is slider's range, and SpinCtrl is coupled with slider
		+ Send for testing
		+ Bump up version
		+ Slider's edit box: enforce setting on focus away
		+ the [PAUSE] on the top left corner fails to show up; shows up for 1 second after unpaused, and then disappears after that second has passed
		+ loading up "last-modified settings," or any settings for that matter, remove the pin's ability to stay in one place, and the pin just falls with the object/vehicle/ship, not keeping anything in place
			+ Definitely repro's with Simulation Quality
			+ CalculateIntegrationFactorTimeCoefficient needs to take into account mIsPinned
				+ ...which becomes float
		+ "here is a bug that I found to where the game crashes. You zoom out, click adjust terrain, remove all terrain, then reset the map by hitting ctrl+r, the game freezes for a second and the crashes."
		+ "I feel that the waves on the 'storm' should be a bit smaller"
			X The titanic has a structural problem, In a storm the stern keeps breaking off
		+ Improve app icon
			+ First icon (AAA) has white bg
				+ Verify it's the app (exe) icon
			+ Second (AAB) is current, used by SetIcon
		+ Try Dario's cable suggestions
		+ Background Music
			+ Long Note Four by Kevin MacLeod: https://www.youtube.com/watch?v=mzmfxEcCeic
			+ Needs to fade out while sinking music is fading-in, and needs to fade-in once sinking music
			  is fading out
				+ All done by MusicController, as long as mPlayBackgroundMusic is on
				+ Default: off
			+ Add him to credits
			+ UIPreferencesManager:
				+ Global mute
				+ Game music: volume, playSinkingMusic
				+ Background music: volume, playBackgroundMusic
				+ Center sliders and their checkboxes
			+ PreferencesDialog:
				+ Same as UIPreferencesManager
			+ SettingsDialog: remove music volume, music mute, playSinkingMusic
				+ Also from SettingsManager
				+ Merge Sounds w/Advanced: "Sounds and Advanced"
					+ And now add static boxes
			+ Global mute:
				+ Remove from both SoundController and MusicController
				+ AudioController:
					+ static void AudioController::SetGlobalMute(bool)
					+ static bool AudioController::GetGlobalMute()
						+ check whether sf::Listener volume is > 0.0f
				+ MainFrame
			+ Test playlist
			+ Remove all TODOTEST's
			+ Update changes.txt, also w/new location of global sound setting
			+ Make all music OGG/Vorbis
			+ Run in Debug
		+ Send for testing
		+ Bump up version: 1.13.0.7
		+ See more gradual wave height
		+ Clickable links in About box
		+ Installer:
			+ New icon for installer itself
		+ Video (see Marketing above)
		+ Release
	+ 1.14.0
		+ Branch
		+ Bump up version
		+ Ships:
			+ Cyclops from Bluefox
			+ Alex02
				+ About box: "Alex di Roma", No URL
		+ RenderContext: nuke current texture before loading new Ocean/Land texture, so to save memory
		+ Randomize flames' wind bend with personality seed
		+ New explosions:
			+ Shader:
				+ Take frames out of 4K video
				+ Make 16 textures
					+ Resize frames (512x512)
						+ See if should discard a lot of useless external padding
					+ Make frames transparent: https://graphicdesign.stackexchange.com/questions/4056/replace-black-background-with-a-transparent-background
				+ Cross-linear alpha between two textures
				+ Shader
			+ Atlas:
				+ RegularAtlas builder method (no optim's, all same size (but not necessarily square))
				+ Unit tests
			+ RenderContext:
				+ Make atlas and pass to ShipRenderContext
			+ ShipRenderContext:
				+ New VBO, VAO, etc.
					+ Copy from generic textures
					+ Same plane as fire, but will have deterministic deep sort: fire drawn first, explosion next
				+ Revert to no start/end
					+ Clear at RenderStart()
					+ Upload at RenderExplosions()
				+ New Explosion upload
					+ Args:
						+ vec2 centerPosition
						+ float halfQuadSize // of quad side
						+ float progress
						+ float personalitySeed
							+ Used for rotation, calc'd at ShipRenderContext::UploadXYZ(.)
				+ New render step
			+ Do initial testing by temporarily replacing Bomb's Upload() with new explosion upload
			+ Commit
			+ Make infrastructure for multiple explosions:
				+ Single shader, single atlas
					+ Atlas name: "explosions"
					+ Texture group name: "explosions"
			+ Ship: needs own state machine for explosions
				+ Does: rendering; creation of each frame's force field;
					+ i.e. has Update() and Upload()
					+ State is simulation-time based, as it's inherently physical
						! And after all, the current bomb explosions do a fixed number of steps at 20ms intervals,
						  hence they are basically frame-based
				+ Replaces normal bombs' blast callback: DoBombExplosion -> StartBombExplosion
					+ Start IShipStructureHandler while you're at it
					+ Fixed blast position (verify with the various bombs that it's fixed - should not move in fact)
				+ Mechanics update:
					+ 1) go through state machines, insert force fields
					+ 2) ...apply force fields...
					! 3) update bombs& combustion -> trigger explosions
						! Will come at next frame, like now
				+ Expires when progress reaches max lifetime parameter (float seconds)
				+ StateMachine update:
					+ Nail down blast
						+ See if need to force last blast (capped @ blastradius)
					+ Make gfx explosion size match blast radius
						+ Adjust gfx size at ShipRenderContext, if needed
					+ Nail down duration
			+ Cleanup bombs: (verify all call the same Ship::DoBombExplosion(.))
				+ No bomb does anymore Explosion state machine - they all expire at detonation,
				  after sending Explosion to ship
				+ Only explosions are in simulationTime, rest is still wallClockTime
				+ Do at:
					+ Impact Bomb
					+ Timer
				+ Remove DoBombExplosion from IShipStructureHandler
			+ Explosion physics: smoother, points entering radius at last get too much force
			+ Gfx improvements:
				+ Test temporarily w/very slow progress and make sure all frames are shown
				+ See if scaling should go or remain
				+ Need mipmapped atlas? Test w/zoom
				+ Fix two issues:
					+ Frame -1 is visible:
						+ Try with clamping to dead center
					+ Dark rectangles
				+ Frames
					+ Test without curves at frames (i.e. making them darker)
					+ Do other explosions
						+ Make sure may call new texture files "explosion2_..." and have them still matched by TextureDatabase
						+ RegularAtlas: need to live with incomplete power of two
							+ Fill-in with first frame
						+ Explosion 2
							+ [49, 60] (12), 62, 64, 66, 68
						+ Explosion 3
							+ Make psd
						+ Explosion 4
							+ [121, 130] (10), 133, 137, 140, 144, 147, 151
							+ Try without any mask boosting
							+ Then, try with center alpha brushed towards 1.0
							+ Reboost center
							+ Double-check final fade out
						+ Shader texture coords dead center:
							+ Make dead center at upload
						+ Speedup alpha pre-multiply
						+ Shader: take explosion index as input
							+ ShipRenderContext::UploadExplosion:
								+ For test, set index to one
								+ Then, takes ExplosionType as arg
									+ Deflagration: randomly choose between 0 and 2
									+ Swap explosions 3 and 4
							+ Struct, VAO
							+ Shader
			+ Cleanup:
				+ Complete IShipPhysicsHandler
					+ Move "structure handlers" into it
					+ Register IShipPhysicsHandler with each container
						+ Test all
					+ See if may move "Ship repaired" from repair interaction into both spring/triangle
					  restore handler
				+ Nuke old explosion textures
				+ Nuke GameTypes' texture groups for RC and Timer bomb explosions
				+ Bake atlas:
					+ Rearc textures:
						! There's a json for each TextureDatabase
						+ The json is 1:1 with an enum (and its traits for str<->enum):
							+ Enums are in GameTypes
							+ Traits are in Game/RenderCore
							+ CloudTextureGroups
								+ Cloud
							+ Land,OceanTextureGroups
								+ Land,Ocean,Border
							+ GenericTextureGroups
								+ RCBomb
								+ RCBombPing
								+ ...
							+ ExplosionTextureGroups
								+ Explosion
						+ Split jsons
						+ Refactor TextureDatabase
							+ Split Textures folder per-DB
							+ See if there's any "element-like" struct for which only the container
							  should reference TextureGroups, element might not have to know about its coords
						+ Refactor TextureAtlas
							+ Templated on groups
							+ TextureAtlasBuilder<Traits> has now also static builder method that takes an entire database - TextureDatabase<Traits>
							+ See if there's any "element-like" struct for which only the container
							  should reference TextureGroups, element might not have to know about its coords
						+ UploadedTextureManager: also per-groups
						+ RenderContext instantiates different TextureDatabase<Traits>'s
						+ Unit tests
						+ Commit
						+ Move non-generic texture groups from GameTypes into RenderCore.h
					+ AtlasBuilder: all methods take Options flags = None, AlphaPremultiply
						+ Also store flags in AtlasMetadata
					+ Test all texture groups
					+ Baker tool:
						+ bake_regular_atlas <DB name> <input_folder_path> <output_folder_path>
							+ Takes database name ("Explosion") as input
						+ 2 Files, using TextureAtlas::De/Serialize(folder)
							+ AtlasMetadata, json format
							+ Atlas image, png
							+ Deserialize
							+ See if need to do binary serialization
					+ RenderCore -> TextureTypes.h, ShaderTypes.h, RenderTypes.h (for Quad and Stats)
					+ See if we want to do explicit instantiation of TextureDatabase and TextureAtlas templates at
					  TextureDatabase/TextureAtlas.cpp
						+ ...which include TextureTypes.h
						+ Move back as many methods from .h to .cpp
				+ Move all ultra-violent mode (x3) to bombs' invocations of StartExplosion
					+ Move ultra-violent from blast strength to radius
				+ BombExplosionBlastForceAdjustment: new parameter
					+ Each bomb then adjusts on it (75%, 100%, 125%), sending 500_adjusted * adjustment to Ship
				+ Do explosion notification at Impact bomb
				+ Merge back into 1.14
		+ Rain wetting exposed parts
			+ Every leaking point, that is overwater, gets water in from rain density
				+ Just change externalWaterHeight so that it's max of ocean column height at that point, and rain density * constant
			+ Rearc rain density:
				+ Leave Storm::Parameters::RainDensity as-is
				+ Add new Storm::Parameters::RainQuantity: m/h
					+ Calculated as RainDensity * 50mm/h, not adjustable
					+ Only used by Ship::UpdateWaterIntake
						+ Uses GameParameters::RainFloodAdjustment: 0->1000->3,500,000
							+ Parameter is specific to water intake
						+ Ensure that at Xmax adjustment and 1.0 density, equivalent water height is 1m
				+ SettingsDialog
					+ Also conditionally enable new slider based off DoRainWithStorm
					+ Fix modulate wind's checkbox+slider expansion
			+ Test water bubbles
		+ Menu's: try look'n'feel of "foo/bar"
		+ Try to overlap bombs' disappearance with explosion
			+ And try to draw explosions *over* generic textures
		+ Explosive combustion
		+ changes.txt
		+ Interleaving Update's with Render's
		+ Smoke (*)
		+ Ropes are too strong - they prevent ship parts from sinking
		+ Send for testing
		+ Bump up version
		+ Switches (*)
		+ Slicer sound is not controller by Tools Volume
			+ Move SawedMetal and SawedWood sounds from MasterEffects to MasterTools
		+ Try transmogrifying all textures
		+ See keyboard shortcut for push switch
		+ Repair: better algo to restore points
		+ Re-try world border, using right total texture space width and height (i.e. - 1/S)
		+ Try flames with texture
			+ Add a new "Flame" texture to GenericTextures atlas
				+ Try to flange its bottom
			+ Test shader, using hardcoded atlas coords for flame texture
			+ Make it new flame mode, 1
				+ Rename others as 2 and 3
			+ Restrict two-stage rendering only to modes 2 and 3
			+ Test putting back vertical time-changing offset
				+ Texture has colors for all values of alpha mask
				+ Shader samples twice
				+ Do MipMapped and Linear Generic Textures
					+ Code
					+ Rename ship gen tex shader
					+ Shaders' parameter names: GenericTexture -> GenericMipMappedTexture
					+ Flame 1 shader parameter name: GenericTexture -> GenericLinearTexture
					+ WorldBorder/End parameter name: -> GenericLinearTexture
					+ WorldBorder: provide atlas coords for border texture into shader via param - once and for all at RenderContext initialization time
						+ Cleanup:
							+ RenderContext::RenderWorldEnd
							+ RenderContext::cctor:
				+ Change comment of flameSpacePosition (range) in shaders 2 and 3 as well
				+ See if alpha sampling is really necessary
				+ Color texture: do better wrapping
				+ Alpha texture: avoid vertically-separated parts
					+ Straighten up flames
				+ Cleanup last shader items
			+ Try to bend flame quad based on velocity
				+ Limit max length of Q (but not its direction!), being proportional to scale at the same time
				  (i.e. max length is more with a bigger scale and smaller with a smaller scale)
					+ Use simple edge function
				+ See how to impart inertia:
					+ Points::CombustionState has (current) FlameVector, which converges to
					  target vector
					+ Convergence speed should depend on velocity magnitude
						+ Try with linear step
			+ Provide atlas coords for flame texture into shader via param - once and for all at ShipRenderContext initialization time
			+ Test with flame size slider
			+ merge
			+ changes.txt
		+ Send for testing
		+ Spring and NonSpring force separation optimization (*)
		+ Sea floor collision revisit (*)
		+ Attempt to get rid of boundary checks at OceanFloor and OceanSurface sampling
		+ Bump up spring iterations
			+ 24 -> 30: 22.5ms/30.0fps
		+ changes.txt
		+ Multi-threading, phase I:
			+ ThreadPool
			+ Create at controller and pass as shared_ptr down the hierarchy
			+ Pre-perf:
				+ Dell: 21.8 ms/30.5 fps
				+ Samsung: 96 ms/9.15 fps; Szerszen: 312 ms/3.0 fps
				+ HP: 47.32 ms/15.7 fps
			+ BufferAllocator::Allocate() needs to become multi-thread friendly
			+ Get timings of Ship::Update
			+ Fork
			+ Ship::Update: Run concurrently:
				X 1) UpdateMechanicalDynamics:
					+ Nuke the old _ByPoints
					X Do n+1 iterations:
						+ First of all, call Points::AllocateWorkBufferVec2f to alloc Position2 and Velocity2
						+ First iteration does not need to integrate+collisions
						+ (n-1) iterations in parallel; at each step i, do in parallel:
							+ ApplySpringForces(pi, vi) -> (fsi+1)
							+ Integrate+Collision(pi, vi, fsi) -> (pi+1, vi+1)
						+ Last iteration does not need to apply spring forces
						+ Finally, call points:: SetPositionBuffer(std::shared_ptr<Buffer>) & Velocity(...), which swap
						  mBuffer and argument buffer
						X Doesn't work
				+ 2) TODOHERE: identify other parallelizable tasks; candidates:
					+ WaterDynamics, HeatDynamics, DiffuseLight
			+ Samsung post-perf: 94.5 ms/9.1 fps | 49.5 ms/16.9 fps; Szerszen: 298 ms/3.2 fps
			+ HP post-perf: 46.4 ms/16.0 fps
			+ Verify multi-threading
			+ Undo
			+ Try DiffuseLight + Whole thermal
				+ Pre-perf Titanic with Lights:
					+ Samsung: 165 ms/5.6 fps
				+ Post-perf Titanic with Lights:
					+ Samsung: 162 ms/5.7 fps
			+ Commit
			+ Merge
		+ Cursors at night
			+ RenderContext fires OnEffectiveAmbientLightIntensity whenever this changes
			+ ToolController is notified about effective ambient light changes
				+ Registers
				+ Changes mCurrentEffectiveAmbientLightIntensity
				+ Calls InternalSetCurrentToolCursor()
			+ Tools don't have mParentWindow anymore, but cctor gets IToolCursorManager &
				+ virtual void IToolCursorManager::SetCursor(std::shared_ptr<wxImage const *>, float strength = 0.0f)
			+ IToolCursorManager stored at base
			+ Tools invoke mToolCursorManager.SetCursor(.)
			+ ToolController::IToolCursorManager::SetCursor(std::shared_ptr<wxImage const *>, float strength = 0.0f) override
				+ struct ToolController::ToolCursor{sh_ptr<Image>, float strength}
				+ Store sh_ptr<Image> & strength at mCurrentToolCursor
				+ Calls InternalSetCurrentToolCursor()
			+ ToolController::InternalSetCurrentToolCursor():
				+ Make tmp image from mCurrentCursorImage and lighted based off mCurrentEffectiveAmbientLightIntensity
				+ Make power bar based off mCurrentCursorStrength
				+ Make wxCursor (local) and set on mParentWindow
			+ Power bar cursors: at power bar change, call mCursorManager.SetCursor(cur img, new strength)
			+ Do same formula at TextRenderContext
				+ New param: TextLighteningStrength
				+ Redo math in shader
		+ TrimForWorldBounds: clamp coords to zero after bounce
		+ Change light colors to match Mike's
			+ And add new render param for shaders
		+ Reduce sea's little waves from gusts

		+ Materials changes:
			+ Lower gunpowder strength
			+ Cardboard floats in air
				+ Also set thermal expansion so that it flies when hot
			+ Check Mike's changes
			+ Redo templates
		+ Hull should decay less
		+ Also GoodYear should be full of hydrogen
		+ Selector for panel background
			+ Right-click on panel -> new SwitchboardPanelBackgroundSelectorDialog:
				+ ...or a floating context window?
					- https://docs.wxwidgets.org/trunk/classwx_popup_window.html
					- https://forums.wxwidgets.org/viewtopic.php?t=15025
				+ Dialog uses ResourceLoader::GetIconFilePaths(pattern) -> vector
					+ Now that you're at it, rename ResourceLoader::"Icon" to "Image" where appropriate
				+ Then resizes imgs and populates combo box with thumbs + filenames (for internal use)
			+ New Preferences property: electrical panel background filename
		+ Do highlight also for water detector
		+ Broken water-sensing switch should not trip anymore
		+ Power probes (*)
		+ See if should take Mike's Titanic electricals
			+ Add instanced generator(s)
		+ Propulsion (*)
		+ Double-check strength (Titanic break test)
		+ Send for testing
		+ Bump up version
		+ Improve flame velocity vector: higher VelocityScale
			+ Check overall feeling w/new number
				+ Simplify number
			+ Try with non-linear growth
		+ Fix trapped bubbles
			+ Test if some debris also made it to the other side before the fix
			+ Test perf impact
		+ Test: points of Water are filled with water, and material is set to that of air
			+ First off, water material: buoyancy_volume_fill?
			+ At ShipBuilder
			+ Test with "Ball of Water and Air"
			+ Redo "Ball of Water and Air"
			+ Use constant at AirBubble et al for BuoyancyVolumeFill
			+ Instructions
		+ "is_hidden" in panel json to prevent elements from being shown
			! e.g. for many water-sensing switches
			+ Test w/circuit test
				+ 1 element
				+ all elements
					+ Make sure panel hidden afterwards
					+ Also in Debug
		+ Retire older ships
			+ Move them to "Legacy Floating Sandbox Ships Vol. I" Ship Pack
			+ Coalesce balls
			+ changes.txt
			+ Cleanup debug/release folders
			+ Publish pack
				+ Test
				+ 37 ships
		+ Horns and bells
			+ ElectricalMaterial
			+ GameEvents
			+ Dynamics
				+ Add
				+ Announce
				+ Destroy
				+ Repair
				+ SetSwitch
				+ Update:
					+ Transition conditions: power/isSelfPowered, conductivity, destroyness, mIsPlaying
					+ Fire ShipSound event w/material and underwater
				+ Highlight: tie it to operation (i.e. powered + switch state), not to switch state alone
					+ Avoid at SetSwitch
					+ Do at UpdateSinks()
			+ SwitchboardPanel
				+ Create switch on announcement
				+ New gfx, to be used w/push switch control
				+ Test Disable/Enable on destroy/repair
			+ Sound
				+ Horn
				+ Fix MultiInstanceLoopedSounds::Start: new SoundFileInfo might be different than current
				+ Other sounds:
					+ Rename existing sound file
					+ Nuke horn2
					+ Do new sounds
					+ Elec material: new "ship_sound_type" types
					+ json
					+ test ship
					+ SoundController:
						+ New sound types
						+ New naming convention for filenames
			+ SoundController
				+ Start: Hijack instance ID
				+ Hookup:
					+ Reset
					+ Mute
					+ MasterEffectsVolume
					+ Pause
			+ Materials json
			+ Add to circuit test
			+ Add bell 2 to Titanic
			+ Materials guide and template
			+ See if can merge engine sounds into MultiInstanceLoopedSounds
		+ Send for testing
		+ Bump up version
		+ Musica Bazzico
			+ Title: "The short journey to the seabed"
			+ Author: Soul Heater
			+ Make sure also in tags
			+ Add to license
			+ Test
			+ changes.txt
		+ Discord intake:
			+ SetDoubleBuffered on MAC
			+ Wood background for panel (mahogany)
			+ Sam's errors
			+ Lever dragging
				+ "When they click directly on a speed, it goes to that speed and it would only be one bell sound"
				+ PointToValue(.) -> value
				+ MoveToValue(.)
				+ Issue with LeftUp happening outside of control:
					+ Either:
						+ Register for leave doing exactly like up
						+ Or: capture mouse
			+ Paper material
			+ GameJolt post for those two videos
			+ Add motors: 230hp outboard motor and 550hp steam powered motor
			+ Legos:
				+ Make hull Lego as heavy as non-hull Lego (re-check literature)
					+ Test w/new ship from Mike
					! Density should be 401kg/m3 or 0.55g/cm3 == 550kg/m3
						! https://www.eurobricks.com/forum/index.php?/forums/topic/72114-lego-weight/
						! https://bricks.stackexchange.com/questions/9012/how-can-i-distinguish-floating-versus-sinking-lego-pieces
				+ Lego sounds
					+ Break
					+ Destroy
					+ Stress
					+ RepairSpring
					+ RepairTriangle
				+ Do one or two variations on plastic stress
			+ Bug: "if the heat dissipation is at 18.8 or higher it causes fabric to glitch out the whole ship"
				+ Could repro with Sailboat
				+ Check release perf impact
			+ Fix Hindenburg: doesn't float anymore
			+ captain noobinson
			+ Take mike's fireship
			+ Redo structural material template
			+ "Titanic with Power"
				+ Also take Mike's electricals
				+ Description: 4th funnel
				+ Also @ changes.txt
			+ Test new SS Hesleden
			+ Gunpowder: "Ok, for 2 ppl the explosion is a bit too strong, while for one it's fine - I'll lower it by half of a bit then!"
			+ Bug of that guy
				+ Tell him it's wood stiff
			+ Verify "circuit test" for release
			+ changes.txt
		+ Double gunpowder
			+ Material class
			+ Use strength at explosion
			+ Json
			+ Refresh palette
			+ Update materials guide with two new properties
		+ "Donate" link
			+ To new page @ www.floatingsandbox.com
		+ Sticky background music item (Bazzico's idea)
		+ John Smith's steam engine sound
		+ Guy's URL for About box
		+ New Concrete material, hull and non-hull
			+ Make ball of concrete
			+ Adjust thermal expansion coefficient
		+ Retrofit ships
			+ Cruise Vessel
			+ Yacht (and x-center)
			+ R.M.S. Oceana
			+ Passenger Tender
			+ M.S. Costa Concordia
				+ Set "SwitchHasBeenToggled" also for engine losing conductivity
					+ Should do opposite flag instead, "PowerHasBeenSevered"?
			+ Redo electrical template
			+ changes.txt
		+ Bell @ Titanic
		+ See ships under Dev Server
		+ See new ships just downloaded
		+ Take Paco's Base3
		+ Test floating crane
		+ Take DioxCode's ships
			+ Asked author
			+ Asked URL
			+ Add to About box
			+ Transatlantic too
				+ changes.txt
		+ Release "Legacy" ship pack (free!)
		+ Release:
			+ Make Release build
			+ Test Release build
			+ Make installer
			+ Test installer
			+ Send installer for testing
			+ Create zip
			+ Wait for installer test
			+ Git tag, with zip
			+ Release on GameJolt
				+ Also link to blog
			+ Upload and test changes.txt
				+ Test 1.13
				+ Test 1.14
			+ Nuke /Install under /build
			+ Commit & push
	+ 1.15.0
		+ Branch
		+ Bump up version

		+ Remove "Ship Art" from About box
		+ "Can you make ocean floor detail 's min back to 0? It's hard to get flat ocean land now with the min at 1."
			+ No sound
			+ Tell guy
		+ Electrical panel layout: sort by instance ID first
			+ Test with Post's ship
		+ Ship json: flags to explicitly say whether it's HD and has power
			+ Test HD
			+ Test Electrical
			+ Set to false for those ships that trick the user:
				+ HMHS Britannic (Mini): no power
				+ HMHS Ajax: no HD
				+ HMHS Ficier: no HD
				+ PM Goliath: no power
				+ PM PacMaster: no HD
				+ RMCV Siffiol: no both
				+ SS Ariara: no both
				+ SS Queen of Unova: no power
				+ Tubon I: no hd
		+ "ResourceLoader" -> "ResourceLocator"
		+ Pinch tool (*)
		+ Pumps (*)
		+ Batisphere with pumps
			+ Add 1000HP engine, both dirs
			+ Lower dive pump
			+ More pump power
			+ changes.txt
		+ Hide legacy_electrical materials from structural palette
		+ Drop air temperature with storm
			+ By 15 degrees (local constexpr)
			+ New storm parameter, with modulation
			+ Use everywhere we use GameParameters::AirTemperature
				+ ApplyWorldForces
				+ Others
		+ Robustness:
			+ DKuz's issue: trap error when ShipLoadDialog starts and finds file with invalid char ("Liberte'" issue)
				+ Try myself
				+ Flush log to disk on crash
					+ Logger::FlushToFile(fs path)
						+ Path at SysPaths class
				+ changes.txt
			+ Handle when error at default_ship on startup
				+ Test before:
					+ Broken json
					+ Missing altogether
				+ Impl:
					+ MainFrame:
						+ GameController::AddDefaultShip()
							+ If April 1st: call AddFallbackShip() instead
						+ If error:
							+ Display msg
							+ GameController::AddFallbackShip()
								+ Data/Misc/fallback_ship.png, new ResourceLocator method
				+ Test after:
					+ Broken json
					+ All fine
					+ Special day
			+ Catch corrupted settings jsons
				+ Main settings:
					+ Fuzzy-break them and see what happens at startup
					+ Handle somehow
					+ Test after
				+ Persisted settings (user only):
					+ Fuzzy-break them until SettingsWindows doesn't open
					+ Handle somehow
					+ Test after
				+ Verify it may be saved again
		+ Test About box in debug
		+ Cloud speed: adjust for wind being 2 or 4
			+ Close ticket then
		+ Secret typing state machine
		+ Flood doors (*)
		+ Visual notification for Pinch tool: simply circle around point
			+ Managed by points, somehow within "highlight" framework:
				+ HightlightMode: enum at RenderContext
					+ Name of new one: Circle
				+ ShipRenderContext stores vertices in different groups, depending on highlight mode
				+ ShipRenderContext::RenderHighlights() does all groups, each with own shader
					+ Rename shader (file & enums) from "ShipHighlights" to "ShipElectricalElementHighlights"
					+ New shader name: "ShipCircleHighlights"
			+ Pinch tool: simply add to points
			+ Points update
			+ Shader
		+ Mouse wheel issue:
			! Issue: wheel event is captured by SwitchboardPanel::mSwitchPanel (i.e. wxScrolled<wxPanel>) and explicitly blocked
			+ Repro on my box: only after clicking on switchboard
			+ Test wheel at LoggingDialog, LoadShipDialog
			+ Fix with focus
			+ Test that normal wheel in-game works
			+ Test wheel at LoggingDialog, LoadShipDialog
		+ Retrofit ships:
			+ SS Californian
				+ Nuke one "w/lights"?
			+ Britannic
				+ changes.txt
			+ Goodyear
			+ Hindenburg
		+ See if may raise max # of explosions
		+ Lower volume of engines
		+ Try _Astyuu_'s ships
			+ Said yes
			+ Try new pack to see if he's fixed the ordering of the electrical panel on the IJN Akitsu Maru
			+ Take latest IJN Akitsu Maru
			+ changes.txt
		+ Try new Hesleden
			+ Ask him whistle and horn
			+ Try to rewire
			+ changes.txt
			+ Take it
		+ Do "Unsinkable" ship
			+ Use texture from my own
			+ Add ropes
			+ Enlarge V water channels
			+ changes.txt
			+ Final test
		+ Klaxon sound
			+ Sounds:
				+ Non-underwater: 36117 55069
				+ Underwater
			+ Material in json
			+ Add to Red October
				+ Also add pumps & engine to it
			+ changes.txt
			+ Material template
			+ Materials' guide
		+ "Auto-Zoom at Ship Load":
			+ By GameController @ AddShip
				+ Only when changing ship
			+ Uses ViewModel::CalculateZoomForWorldWidth(.): calcs zoom required to fit that world width in screen
				+ Add (world) margin
				- See Boeing
			+ Then: if calculated zoom requires zoom out: use it;
				else: if calculated zoom requires zoom in and more than 1.0 (i.e. more zoom in than): set to 1.0; else: leave as-is
			+ UIPreferences - with storage @ GameController
		+ Music cleanup:
			+ Ti direi quindi di eliminare sicuramente sinkingship_2.ogg (piano) e sinkingship_3.ogg (violino).
			+ Circa sinkingship_4.ogg (violini) vedi tu, potrebbe anche essere passabile.
			Per quanto riguarda le altre:
			+ sinkingship_5.ogg e sinkingship_6.ogg (non mi piace quasi per niente. le note sembrano le stesse della mia ma pare una sveglia in entrambi i casi)
			+ sinkingship_7.ogg (non capisco se ï¿½ originale o presa da qualcosa. Non male, a parte qualche insolita stonatura all'inizio. Se fai mettere mano agli strumenti rendendola piï¿½ "seriamente orchestrale" puï¿½ andare bene)
			+ sinkingship_8.ogg (ï¿½ una melodia carina, ma non mi sembra una musica giusta per l'affondamento. Come sopra, se riescono a rivedere gli strumenti puï¿½ essere interessante, ma la sposterei nella musica del gioco vero e proprio).
		+ Commit & Merge
		+ Send for testing
		+ Bump-up version
		+ Post roadmap
		+ make gbenchmark optional
		+ Multiple instance ID error: say where they both are
			+ Test
		+ See "invalid extension" error message
			+ Test
		+ See if may get rid of ImageFileTools::Load...UpperLeft
			+ ShipBuilder
			+ OceanFloor
			+ ShipAnalyzer
			+ Nuke from ImageFileTools
			+ Add comment at top of class on all methods using a LowerLeft origin, and rename all remaining
			  ImageFileTools::LoadXYZ without "LowerLeft"
			  + Don't forget ShipAnalyzer
		+ Materials:
			+ Add "Ignition" material: just like heating element, but way faster
				+ "Heating Element HP/LP"
				+ Raise heat generated by heating element - test w/those two ships
				+ Send beta to John Smith
			+ Lower melting temperature of Lego
			+ Redo both templates
			+ changes.txt
		+ Auto-Texturizer
			! Spec: new ShipTexturizer class, owned by GameController
				- Created at GameController create time, and kept forever
					- Maintains cache
				- Also at create time does MaterialDB <-> actual textures check, brokered by GameController (see below)
				- Also holds auto-texturization mode setting, see below
				- Auto-Texturization mode (exposed @ SettingsDialog::Rendering), dictates what to do when ship doesn't come with a
				  texture; two modes:
					- "FlatStructure": builds texture using structural materials' RenderColor (as opposed to color key like now)
					- "MaterialTextures": using materials' "bump maps"
						- Textures are semi-transparent "bump maps" that are drawn on matte structural material color
						- Textures/Materials folder contains textures
						- Structural material has new mandatory "texture_name" string arg
							- Material DB <-> actual textures check: done by GameController at its Create() time,
							  invoking ShipTexturizer::VerifyMaterialsDatabase(MaterialsDatabase const &)
					- Setting storage is @ ShipTexturizer, brokered by GameController
				- Both texturizations implemented in ShipTexturizer class as invoked by ShipBuilder
				! Edge smoothing is already done by means of tessellation
			+ ShipAutoTexturizationMode At GameTypes
			+ ResourceLocator::GetMaterialTexturesFolderPath()
			+ Nuke TextureOrigin @ ShipDefinition & Ship/RenderContext
			+ ShipDefinition::TextureLayerImage is now optional
				= Copy structure->texture code to ShipTexturizer
			+ Path:
				+ GameController::AddShip:
					+ Load Definition
					+ World->AddShip(definition, ..., renderContext)
						+ ShipBuilder::Create -> [ship, texture image]
						+ RenderContext::AddShip(texture image)
							+ Validate texture size
			+ GameController creates instance of ShipTexturizer at Create time
				+ Simple member
				+ Then invokes ShipTexturizer::VerifyMaterialsDatabase(MaterialsDatabase const &)
			+ ShipTexturizer instance is passed by GameController to ShipBuilder (via World)
			+ ShipBuilder uses ShipTexturizer to create - and return - texture
				+ Args:
					+ ShipBuildTypes.h:
						+ Definition (using) of ShipBuildPointIndexMatrix
						+ ShipBuildPoint
				+ First experiment: current (legacy) structure texture
					+ Simple Nx magnify
				+ Invoke from ShipBuilder
			+ StructuralMaterial has new mandatory "texture_name" string arg
				+ For now just optional
			+ Do texturizations
				+ FlatStructure:
				+ MaterialTextures:
					+ MaterialTextureMagnificationFactor:
						+ Getter and setter
						+ Upon setting: store mMaterialTextureWorldToPixelConversionFactor = 1/.
					+ Do bilinear and multiply
					+ ShipTexturizer's cache:
						+ Has LRU cache of textures, maintaining count of accesses and sorting+purging with H and L watermarks
						+ Cache usage counts are reset at beginning of each new texturization - but textures are not purged
					+ Perf:
						+ Start: Heat Generation Test: 998/1050ms
						+ Try converting material texture to floats first
							+ New ImageData instantiation: vec3f
							+ ImageTools: conversion
							+ Do at load time and store in cache
						+ Factor out WorldW,Y and keep adding
						+ Heat Generation Test: 962/1032ms
						+ Verify Cartman
						+ Now: 962-997, roundf: 18.3%, fmodf: 17.09%
						+ Optimize roundf, fmod
						+ Now: 180-205
			+ I/GameController settings: ShipAutoTexturizationMode & MaterialTextureMagnification
				+ UIPreferencesManager
				+ PreferencesDialog
				+ Test:
					+ Saves
					+ Loads
					+ Reconciliation
					+ Magnification range & formula
			+ Test "special multiply" blend mode
			+ Do textures for all materials
				+ metal_riveted_1 (Steel, Iron) x 2 (non-hull, hull (small))
				+ metal_bulkheads_1 (Titanium)
				+ metal_riveted_2 (Aluminium)
				+ wood_planks_1 (Non-hull)
				+ wood_studded_1 (Hull)
				+ concrete_1/2
				+ glass_1
				+ cloth_1
				+ paper
				+ Re-check all so far
				+ cardboard
				+ carbon
				+ double-bottom others
				+ rubber
				+ lego
				+ fiberglass
				+ double-bottom wood
			+ Deal with unset StructuralMaterial' "texture_name"
				+ Use 'none'
			+ Implement ShipTexturizer::VerifyMaterialsDatabase
			+ Script to validate materials
				+ texture_name
				+ render_color==key_color
				+ Also run ship verification script
			+ Test transparency setting
			+ Finalize:
				+ GameTypes
					+ ShipAutoTexturizationSettings
					+ Use at ShipTexturizer as storage
					+ Use at UIPreferencesManager
				+ ShipDefinition/File has optional "auto_texturization" struct
				+ ShipTexturizer has new boolean setting: ForceSettingsOverShip
				+ This optional<AutoTexturizationMode> is passed to ShipTexturizer, which decides what to do
				+ Dialog:
					+ Transparency setting (and move to sliders now)
					+ Force checkbox
				+ Test:
					+ Saves settings
					+ Loads settings
					+ Defaults apply to png and shps without auto_texturization
					+ Ship's auto_texturization is honored when different than defaults
						+ Just mode - and verify defaults for other two
						+ Mode and other two
					+ Forcing works
			+ Default ship auto-texturization: ON
			+ Tooltips for auto-texturization:
				+ Add "...when ships don't have their own texture layer."
				+ Add "Changes are only visible after a ship is reloaded."/"next ship load".
				+ Also for strength: "not for rigidity"
				+ Also for rot: "...Set to zero to disable rotting altogether"
					+ Underwater constant is set to zero if acceler8r is zero
					+ Verify
			+ Perf:
				+ Smaller ships take longer
					+ Cap magnification factor and recalc texture size
			+ Tests:
				+ Ship with own texture too large than OpenGL's limits: verify we still display error and everything continues: 2012 Ark
			+ Remove cache clearing for testing
			+ merge
			+ changes.txt
		+ Send for testing
		+ Clouds bug
			+ Test again
			+ changes.txt
		+ Remove discord url's from About box
		+ Rename menus: "Simulation Settings" X 2 & "Game Preferences"
		+ Offset sinking water with Points::GetTotalFactoryWetPoints()
			+ Calc'd by Points at Add()
			+ Exposed as getter
			+ Used at sinking detection
			+ Test
				+ Ball of water
				+ 3 balls
		+ Non-instanced water-sensing switches
			+ Code: treat water-sensing switches differently
			+ Add material to json
			+ Test:
				+ Instanced
					+ Toggle
					+ Disable, enable
				+ Non-instanced
					+ Toggle
					+ Disable, enable
			+ changes.txt
			+ redo template
		+ Diesel engine
			+ Got new sounds from John Smith, check them out
			+ Add engine type to code
			+ Do electrical material in json
			+ Add material to a ship
			+ Redo electrical template
			+ Update materials' guide
		+ Rebuild with latest changes
		+ Import other changes:
			+ MainFrame:
				+ MainFrame style:  wxDEFAULT_FRAME_STYLE | wxMAXIMIZE,
				+ Panel & Canvas size: wxDefaultSize
				+ mMainFrameSize->"mMainPanelSizer"
				+ mMainPanel->Layout(); // after  mMainPanel->SetSizer(mMainPanelSizer);
				+ pass canvas size to rendercontext
				+ PRE:
					17:26:31.138270:ShipTexturizer: completed auto-texturization: materialTextureMagnification=1 structureSize=203x52 textureSize=4060x1040 magFactor=20 time=237792us
					17:26:31.138270:Created ship: W=203, H=52, 5231/9328buf points, 19932 springs, 9819 triangles, 6 electrical elements.
					17:26:31.300279:Layout: decoratedW=0, decoratedH=0, W=0, H=0
					17:26:31.301279:OnMainGLCanvasResize: 1350x668
					17:26:31.819288:Post-Initialize took 6.79314s
					17:26:32.159295:OnMainGLCanvasResize: 1366x684
					17:26:32.163295:OnMainGLCanvasResize: 1360x740
				+ POST:
					18:23:54.581699:ShipTexturizer: completed auto-texturization: materialTextureMagnification=1 structureSize=203x52 textureSize=4060x1040 magFactor=20 time=222195us
					18:23:54.581699:Created ship: W=203, H=52, 5231/9328buf points, 19932 springs, 9819 triangles, 6 electrical elements.
					18:23:54.729707:Layout: decoratedW=0, decoratedH=0, W=0, H=0
					18:23:54.733708:OnMainGLCanvasResize: 1350x668
					18:23:55.243715:Post-Initialize took 6.46163s
					18:23:55.405719:OnMainGLCanvasResize: 1360x740=
				+ Test:
					+ Ship w/out electrical panel
					+ Ship with electrical panel
		+ Fix issue with pick
		+ Undo (some of the) .shp changes
		+ Try Flugzeugdampfer_I (_Astyuu_)
			+ Ask for an update, with nicer panel and more powerful engine
			+ Check updated zip: unzipped at C:\Users\Neurodancer\Desktop\Ships contributions TODO\_ASTYuu_'s\DKM_Flugzeugdampfer
			+ All good, take 1; ask if will add new materials
			+ changes.txt
			+ Ship verify
		+ Test smaller PickNPull coefficient
		+ Make ball of lego
		+ Send for testing
		+ Bump-up version
		+ Do post with auto-texturization screenshots
			+ And link to TinCan's video
		+ Take Fox Assor's ships
		+ changes.txt
		+ Take new sleeping sun from Officer TinCan
		+ Enable Git LFS
		+ Ships:
			+ Nomadavid's
			+ Changes.txt: new ships

		+ "Get More Ships..." link
		+ Redo elec template
		+ Test whole ship preview

		+ Build release
		+ Run final test
			+ Ship preview (with log)
			+ Version
		+ Build installer
		+ Test installer
		+ Send installer for testing
		+ Release: the "Eternal Patrol" update
			+ Make zip
			+ Github tag (w/zip)
			+ GameJolt
				+ upload package x 2
				+ movie up to youtube
				+ publish release on gamejolt
				+ publish youtube movie
				+ post (w/link to youtube)
			+ changes.txt up to fs.com
			+ current version @ fs.com
	+ 1.15.1
		+ Bump-up version
		+ Merge llvm_fixes
			+ And verify performance, also of lighting
		+ Feedback:
			+ It seems the mouse wheel glitch still occurs; But only if you click on the panel itself, not the elements on them.
				+ Verify
				X Register for mouse wheel on SwitchPanel itself, and forward event to main frame
				+ Give back focus to canvas when l-clicking on it
					+ At electrical panel disappearing: lose focus
				+ Set focus on canvas at startup
				+ Try to redo by avoiding focus altogether
				+ Test:
					+ Verify re-layout at panel coming,disappearing,docking,undocking
					+ Verify fix
						+ Basic
						+ Disappearing panel when it has focus
					+ HintPanel
					+ Verify scrollbar in elec panel works
				+ changes.txt
			+ Plus 1: The terrain tool seems to be broken for some setting presets.
				! It seems to break if I set Ocean Floor Bumpiness and Ocean Floor Detail to both be 0.
				+ GameController::AdjustTerrain returns bool; do different notif's depending on it
					+ Sound: Error
					+ Red cursor
			+ Plus 2a: You can no longer navigate the ship explorer (folders) using arrow keys. (make the directory separator movable)
				! Plus 2b: You can no longer increase/decrease sliders using arrow keys.
				+ 1) Re-add char hook to mainframe (panel?)
				+ 2) Re-instate hook handler
				+ 3) MainApp: don't forward to main frame
				+ 4) Re-hyde bubble tool
				+ Redo 'B'
				+ Test:
					+ Secret typing
					+ Arrows @ Game (& +/-, PgUp/PgDown)
					+ Arrows on two dialogs
					+ Shortcuts of electrical panel, and key up @ push switch
					+ B
					+ query
		+ Release
			+ Make zip
			+ Build & test installer
			+ Github tag (w/out zip)
			+ GameJolt
				+ upload package x 2 & release
				+ post
			+ changes.txt up to fs.com
	+ 1.15.2
		+ Blog:
			+ all new electrical elements
		+ Bump up version
		+ Cleanup plan
		+ Load ship dialog:
			+ Ship Preview Cache (*)
			+ Arrow keys on ShipPreview window
			+ Text serch also on year, author
		+ #pragma pack(push, 1) // @ all instances
			+ See perf afterwards
		+ OpenGL:
			+ Remove stencil from context requirements
				+ And check all references to "stencil"
			+ Run w/OpenGL tracing to see if there's any errors
		+ SettingsDialog: move ship render mode to Debug
			+ As new "Ship Render Mode" radio option
				+ If we do so, do we need any of the debug ship draw options to support "color" instead of "texture"?
					+ See if e.g. we do "springs only" with both nowadays: NO, only with "structure (color)"
			+ Use lambdas at checkboxes
		+ Sparkles:
			+ Growing and then shrinking
		+ Water bubbles:
			+ Bigger as goes up
			+ Waves at surfacing
				+ Boolean flag => Points::m (or local?) AirBubblesOceanSurfaceDisplacementSurfaceOffsetThreshold = 0.5/0.0
				+ SettingsDialog
			+ Sound
		+ ARM OpenGL issue
			+ See https://groups.google.com/forum/#!topic/wx-users/sOuPgaB_uXo
			+ Ccontext is bound early to a temporary canvas that is shown, and after initialization it is
			  bound to the actual game canvas
				+ See if need to SetCurrent again
				+ See if new DC needs also to be visible
					+ SplashDialog needs to become member; OnPaint checks for it and if so, 1) transfers, and 2) destroy
					  mSplashDialog
				+ Test:
					+ Start w/elec panel
					+ Force Paint - minimize+maximize, move, close dialog, etc.
				+ Cleanup:
					+ Make Splash's canvas inconspicuous
		+ MacOS zero timeout issue:
			+ Calc millis for 1000/20 frames/sec and sleep by that
				+ Verify no FPS changes afterwards
		+ Parallelize OpenGL
		+ Bug: no terrain cursor appears if you are in tool 'M' and then hit 'J'
		+ Hard error if Splash can't find image
		+ Latest picojson
		+ Default ship @ Install: Titanic with Power
		+ Notification for muted sound
			+ Test with both false and true loaded at startup
			+ Test with ambient light
			+ Test CTRL+M shortcut
		+ Redo cross of light (use new one at https://www.shadertoy.com/view/Wt2czz)
			+ Adjust stitch between Imploding_5 and PreExploding_6
				+ Adjust progress @ shader
		+ Explosions:
			X Try with progress being sqrt
			+ More delta scale
		X Try [[likely/unlikely]] - checking assembly (and perf impact) of norm vector calculation
			+ Check assembly:
				+ Before:
					000000013F76F288  sqrtss      xmm7,xmm1
					000000013F76F28C  comiss      xmm7,xmm2  # xmm2=0
					000000013F76F28F  jbe         Physics::Ship::ApplySpringsForces_BySprings+0F6h (013F76F2A6h)
					000000013F76F291  movaps      xmm3,xmm8  # xmm8=1
					000000013F76F295  divss       xmm3,xmm7  # xmm3=1/len
					000000013F76F299  movaps      xmm6,xmm3
					000000013F76F29C  mulss       xmm3,xmm5
					000000013F76F2A0  mulss       xmm6,xmm4
					000000013F76F2A4  jmp         Physics::Ship::ApplySpringsForces_BySprings+0FCh (013F76F2ACh)
					000000013F76F2A6  movaps      xmm6,xmm2
					000000013F76F2A9  movaps      xmm3,xmm2
					000000013F76F2AC  movss       xmm1,dword ptr [r10+rax*8+4]
				+ After:
					000000013F4FFDE8  sqrtss      xmm7,xmm1
					000000013F4FFDEC  ucomiss     xmm7,xmm2
					000000013F4FFDEF  je          Physics::Ship::ApplySpringsForces_BySprings+0F6h (013F4FFE06h)
					000000013F4FFDF1  movaps      xmm3,xmm8
					000000013F4FFDF5  divss       xmm3,xmm7
					000000013F4FFDF9  movaps      xmm6,xmm3
					000000013F4FFDFC  mulss       xmm3,xmm5
					000000013F4FFE00  mulss       xmm6,xmm4
					000000013F4FFE04  jmp         Physics::Ship::ApplySpringsForces_BySprings+0FCh (013F4FFE0Ch)
					000000013F4FFE06  movaps      xmm6,xmm2
					000000013F4FFE09  movaps      xmm3,xmm2
					000000013F4FFE0C  movss       xmm1,dword ptr [r10+rax*8+4]
			X If wanna keep it: CMakeLists: if MSVC, set /std::latest, else CMAKE_CPP=17
		+ Add new detected characteristic: FS_REGISTER_WIDTH 32/64
			+ Change and use FastTruncate accordingly
		+ Do intrinsics only on FS_ARCHITECTURE_x86_64 (& 32?), else do C++
			+ Test with fake architecture detection, making sure no intrinsic header files are included
			+ Implement lights vectorized
				+ With unit tests
			+ Test lights, ocean floor, ocean surface
			+ Check speed of new vectorized one wrt naive, w/Szerszen
				+ Vect: 10-10.3, 71ms
				+ Naive: 9.7-10, 73ms
			+ Undo fake architecture detection
			+ Verify that, without intrinsics, FastTruncateInt64(-7.6) == -7
		+ 32-bit build
			+ Prepare 32-bit SDK:
				+ wxWidgets (UNICODE)
					+ Release
					+ Debug
				+ SFML
					+ Release
					+ Debug
				+ DevIL
					+ Release
			+ Need new build folder altogether, and new invocation of CMake with different generators
				+ UserSettings.cmake: see if may switch based off bitness
					+ https://cmake.org/cmake/help/latest/variable/CMAKE_SIZEOF_VOID_P.html#variable:CMAKE_SIZEOF_VOID_P
				+ benchmark issue
			+ Build:
				+ RelWithDebInfo
					+ Run unit tests
					+ Fix issue with sfml-d
					+ Rerun CMake
					+ Test run
				+ Debug
					+ Run unit tests
					+ Test run
				+ Release
					+ Test run
			+ Verify SSE intrinsics are fine in 32-bit process
				+ Run through them, and check assembly
			+ Add Arch+OS to AboutBox
			+ Re-test 64-bit
				+ Clear Data folder for all flavors
				+ Redo CMake
				+ Run unit tests Debug
				+ Test run Debug
				+ Test run RelWithDebInfo
			+ Check all png's for ocean and land
			+ If wxWidgets' Unicode is fine, re-build wxWidgets with Unicode for 64-bit as well
				+ Build SDK
				+ Add wxS to:
					+ SliderControl (takes wxString's as args)
					+ SettingsDialog
						+ Test saving settings
						+ See speedup
					+ PreferencesDialog
					+ MainFrame
					+ ShipLoadDialog
			+ Commit & push
		+ Texture notifications: recalc vertices at view model changes
			+ Store raw data, just like font
			+ Mark dirty at ApplyCanvasSizeChanges and recalc vertices @ RenderPrepareTextureNotifications
			+ Test w/panel
		+ GameController: just one special day
		+ Fix 1 second == 1 second
			+ Change simulation time step
			+ Fix calculation of timer step: round correctly!
			+ Test Titanic
				+ Find new strength: 0.643389
			+ Fix splash screen - Ready!
			+ Increase rigidity:
				+ SpringReduction Coeff = 0.5 + all materials' stiffness max=1.0 (change names when "stiff")
				+ Ropes are at 2.0
			+ Test Titanic
				+ Lower strength even more: less than 0.643389
					+ Or: lower strength of Titanic's breaking material - try first removing strength "version multiplier"
			+ Test ropes
				+ With Titanic cutting
			+ Test balls, etc.
			+ Test melting
				+ Increase strenghtening
			+ Test bombs
				+ Adjust strengths
			+ Test rotting speed (and gfx)
			+ Test repairing
			+ See if max StiffnessAdjust needs to be changed (so that spring displacement max is 1.0)
			+ Test on old dell
			+ Build new material template
			+ changes.txt: "Recalibrated..."
		+ Test szerszen
		+ See if may avoid green lines
			+ Wait for answer from Intel
		+ Day/night cycle
			+ New GameController state machine, running every X seconds (LowFreq update?) and taking current
			  ambient light to target ambient light (target based off next "12-hour")
			+ With texture notification when on
				+ Code
				+ Texture
			+ SettingsDialog: duration
			+ Issue: cursor of tool over SettingsDialog
			+ Try better (inverte-able) curve
				+ Move inverse to GameMath
			+ changes.txt
		+ MSBuild:
			+ Test /MP
			+ If ok: in CMake
		X Test speed with ElementIndex/Count being 64-bit
		+ Run with address sanitizer (32-bit)
		+ Send for testing (32-bit)
		+ Bubbles:
			+ Smaller wave
			+ Add checkbox for bubble sounds
				+ Storage owned by SoundController
				+ Cutoff happens @ SoundController
			+ Try vortex amplitude: random sign
			+ Limit derivative
				+ Do
				+ Test with one-sided derivative
				+ Test - in Debug - at world boundaries
				+ Test on Dell
		+ Logging & threads
		+ Adjust flames
			+ Thicker flames at texture
			+ Resolution
		+ Add latest Songe d'Automne
		+ Localization
			+ static std::opt<lang> UIPreferencesManager::LoadPreferredLanguage()
			+ Fixup dir structures
			+ Test w/manually setting language in ui_preferences.json
			+ LocalizationManager:
				+ Created by MainApp (uq_ptr<> member) at OnInit() passing UIPreferencesManager::LoadPreferredLanguage() -> std::opt<lang>
					+ Returned language type/cctor arg TBD
					+ via Create() factory method, not cctor
					+ Sets wxWidgets' wxLocale and language
				+ Passed as ref to MainFrame, which stores as member
				+ Provides:
					+ Language (type TBD, preferably 2-letter string)
					+ DefaultLanguage - "en" (TBD: or whatever is the type above)
				+ Log language identifier that we would choose at startup, when LocMgr::cctor gets nullopt
			+ Do UI preferences workflow
				+ UIPreferencesManager takes LocalizationManager as ref, which stores as member and uses it for storage
					+ Nuke own storage
				+ Warning on change from current
				+ Test whole workflow
			+ Splash screen progress strings
				+ "MessageType" enum at ProgressCallback, and methods take enum
				+ SplashScreenDialog creates array of _() strings at cctor
			+ StartupTip, Help: ResourceLocator::GetXXXFilePath: static, & take lang_identifier and default_lang_identifier as args
				+ Checks internally if lang file exists before returning default (with logged warning)
				+ Move startup, help HTML files under language dirs
					+ Help folder: maintain resources here, see if may use relative paths in HTML links
			+ Mark all strings as _(
				+ AboutDialog
					+ Also labels
				+ CheckForUpdatesDialog
				+ HelpDialog
				+ LoggingDialog
				+ MainFrame
				+ NewVersionDisplayDialog
				+ PreferencesDialog
				+ ProbePanel
				+ SettingsDialog
				+ ShipDescriptionDialog
				+ ShipLoadDialog
				+ SplashScreenDialog
				+ StartupTipDialog
			+ Prepare final, complete pot file
			+ Translations:
				+ Italian:
					+ StartupTip
					+ Help
					+ po
					+ Cross-reference Help with Menus
				+ Russian:
					+ Prepare po
					+ Test HTMLs
						+ Put content-encoding in master (en) as well
					+ po
			+ Mark TO-DO item under Technical Debt
			+ changes.txt
		+ Lava preset:
			+ Water density
			+ Heat coeffs? For smooth melting, aka Lord of the Rings
		+ ShipLoadDialog:
			+ Clear line from BG
			+ Add border to HTML
		+ Check Russian
			+ ask if comes immediately
			+ Ask to reduce "Mattia, Elia"...
		+ Run in Debug
			+ Bubbles
		+ Run on Dell
			+ x64 rel
			+ x64 debug
			+ x32 rel
		+ Test perf on Dell, before & after
		+ Ships:
			+ M.S. Esmeralda's horn name
			+ Add new variation of M.V. Chippewa (in Contrib's folder)
			+ Add Ferries_Of_The_Pacific (MatthewAnderson707)
				+ Credits: "Matthew Anderson"
				+ changes.txt
			+ Check out Floeddys Fictional Ship Pack (in Contrib's folder)
				+ Nice; asked permission on Discord - OK
				+ Credits: "Floeddy"
				+ Take ships in "OK" folder
				+ changes.txt
			+ M.V. panagiotis (sinking feeling)
				+ Tidy up electrical panel
		+ Fix Storm+Tsunami issue
			+ Test at world boundaries in Debug
			+ Test perf of bubbles on Dell
				+ Also test look'n'feel of flames at slower fps
		+ Fix tsunami rate
		+ Release 1.15.2
			+ 32-bit MSI
				+ Build Install
				+ Make MSI
				+ Test on New
				+ Test on Discord
				+ Test on old Dell
			+ 64-bit MSI
				+ Build Install
				+ Make MSI
				+ Test on New
				+ Test on Discord
				+ Test on old Dell
			+ Test upgrade from 1.15.1
			+ Cut tag on github
			+ Publish packages on GameJolt, scheduled
			+ After schedule:
				+ Post:
					Dear Shipmates, It's finally time for 1.15.2 to come out and find its rightful place on your computers!
					As previously anticipated, this release consists of mostly technical improvements across the board, which smooth out some rough edges of Floating Sandbox and pave the way for fantastic improvements in the future.
					Here's the list of changes in this release:
					...
					P.S.: this release was timed with theDARKTURRET's YouTube premiere: https://www.youtube.com/watch?v=UCEvFRpRv-0
				+ Update package instructions
			+ Add 32-bit to GameJolt's "System Requirements" section
			+ www.floatingsandbox.com:
				+ changes.txt
					+ Test
				+ FAQ:
					+ Current version
					+ 32-bit
	+ 1.15.3
		+ Version bump
		+ Add tester X 2
		+ Intel HD 2000
			+ Investigate:
				- No threading: lags
				- SwapBuffers log (@MainFrame, 3): lag (not swapbuffers)
				- SwapBuffers + UploadStart log (4): lag (neither of them)
				- UploadStart + Draw:
				- OnGameTimerTrigger: lag (one timer tick every 5 s) 05:05:43.515398:OnGameTimerTrigger; 05:05:47.873422:OnGameTimerTrigger; 05:05:52.227233:OnGameTimerTrigger
				- OnGameTimerTrigger (start and GameController::RunGameIteration) + PostGameTimer: lag (RunGameIteration takes 4 secs)
				- GameController::RunGameIteration::4 steps: lag (Render Draw -> end of function: takes 4 secs)
				- RenderContext::Draw: glFinish_start/glFinish_end/swapbuffers_end: NO lag
				- RenderContext::Draw: glFinish_end/swapbuffers_end: lag, none of these
			+ OpenGL switch
		+ Melting point adjust
		+ Run in debug
		+ Release:
			+ MSI variables
			+ 64-bit MSI
				+ Build Install
				+ Make MSI
				+ Test
				+ Test on Discord
			+ 32-bit MSI
				+ Build Install
				+ Make MSI
				+ Test
				+ Test on Discord
			+ Upload packages to www.floatingsandbox.com
	+ 1.15.x
		+ Fix that bug with vectors/highlights rendering (buffer size mismatch)
	+ 1.16.0
		+ Clouds in perspective (*)
			+ Changelist
		+ Frontier (*)
			+ Changelist
		+ 500K download post on GameJolt
		+ How to make a ship tutorial post on GameJolt: https://www.youtube.com/watch?v=7KhRdTv9fTo
		+ Frontier bug:
			+ 2 sides with frontier; both external frontiers, but different IDs
				+ Do factory positions
				+ Verify bug is due to discordant IsClockwise
		+ Directional water drag (*)
			+ Changelist
		+ Log not being created with close button, only with File->Quit
			+ Different "Close" events: X button vs. File->Quit
		+ Spanish translation
			+ Add Joadix to credits
			+ Changelist
		+ "Floating Sendbox x.y" @ beginning of log file
		+ ShipDB cache/last_modified: != instead of >
		+ Merge to master
		+ Clang build
		+ Fishes (*)
			+ Changelist
		+ Calibrate flying burning cardboard	
			+ Check also paper
			+ Changelist
		+ Fish turn improvement
			+ Y
			+ X
		+ Fish/smash radius
		+ Re-think issue with burnt out materials increasing temperature
			+ Makes for flying light material, like paper and cardboard
			+ Should burn-out materials clamp their temperature to their burning point?
				+ By multiplying heat given to neighbors by burning particles by neighbor.decay
			+ Re-check:
				+ Cardboard
				+ Paper
				+ Hydrogen
		+ See instability issue with Ark (& light materials on flat ocean)
			! Was there at least since 1.14
			+ See with "depth softening" for each water-surface interface
				+ See if these are both needed:
					+ @ Buoyancy
					+ @ Water pressure drag
						! Doesn't seem to affect cardboards too much					
				X See if also needed for ocean floor collisions
					+ Though it could be that ocean floor collisions already produce forces proportional to depth
			+ changelist
		+ See if better with water pressure drag adjust = 0.5
			+ Hydrodynamics test
			+ Titanic
		+ Localization of new strings
			+ IT
			+ RU
			+ ES
		+ Send for final testing
			+ Bump up version afterwards
	+ 1.16.1:
		+ Bump up version
		+ Commit, push, and branch
		+ Re-build DevIL as static lib (*)
		+ Reload last-loaded ship (the one that the game was closed with)
			+ Menu item: "Reload Previous Ship"
				+ Initialized as disabled
			+ Renamed "current" reload as "Reload Current Ship"
			+ Move whole management of "Reload Last Ship" and default ship loading to MainFrame
				+ GameController initialization must not do ships; initial ship loading must be explicit
				+ Also default ship choice moves to MainFrame
				+ mCurrentShipFilePath: set each time we've successfully loaded a ship
					+ ...and also stored at UIPreferencesManager as LastShipLoaded, for next time
						+ Saved at exit if set
				+ mPreviousShipFilePath: set to mCurrentShipFilePath each time we've successfully loaded a *different* ship
					+ ...and enables "Reload Previous Ship" menu item
				+ Enable menu item after UIPreferencesManager loaded, when LastShipLoaded is not empty
			+ New UI preferences flag: Reload last ship at startup, default=false
				+ Used at initialization
			+ changelist
		+ Credits:
			+ "Programmed in Amsterdam, the Netherlands"
			+ ShipBucket
		+ Smaller destroy radius - like at 5.0
			+ If no destroy but there was a closest point - within radius + 50% - then destroy (just) that
		+ See fishes flying with large size
		+ Move UIPreferencesManager::ReloadLastShipOnStartup to Ships tab
		+ Flag for velocity display
			+ At UIPreferencesManager & Dialog, saved and all
		+ Exclude hidden files (.whatever) from TextureDatabase, ShaderDatabase, and everywhere we enumerate files
			+ When enumerating, only look for expected extensions - making sure as well that we find everything we're looking for
				+ TextureDatabase
				+ Others
		+ Merge into master
		+ UpdateMasses: converge _slowly_ towards target
			+ Try to repro issue with ship having water material that breaks (my_ship_structure-water_air_issue.png on Desktop)	
				+ Air material appears to break with water jumping often, possibly because of high jumps in mass
		+ Lower rotting speed:
			+ 1.16: Titanic @ 12m is at 0.34 - let's shoot for 0.5
			+ changelist
		+ Optimize that decay process at Points::CombustionUpdateLowFrequency
			+ Test adjustment
		+ Air bubbles smaller at very beginning 
		+ Volume adjustment for engine sounds
			! Tests:
				! 1: S.S. Lurline
				! 10: S.S. Hesleden
			+ Option 1: number of engines used as divisor
				+ Announced by ElectricalElement (already), received by SoundController which updates mCurrentCount
					+ SoundsController: reset mCurrentCount to 0 at each Reset()
			+ Send to John Smith
		+ Bump up version
		+ Add new background music
			+ "Shadowlands 4 - Breath" - Kevin MacLeod (incompetech.com)
		+ Ship uploads take ShipRenderContext
			! Yet, RenderContext still exposes "Async" versions of buffer uploads
			+ RenderContext.h
			+ Ships::Upload and below
				+ Keep invoking those 3 "async" versions on RenderContext, however						
			+ Tests:
				+ Bombs
				+ PinnedPoints
				+ Temperature
				+ Frontiers
				+ Vector field length multiplier
				+ Highlights
		+ Flames: 
			+ Fix bottom issue with additional Y sorting
			+ Rearchitect way we push foreground flames into vector, so to maintain ordering
				+ Points::UploadFlames does two passes
			+ Fix alpha spots by only using sampled alpha at the top
			+ Fix color Y range
			+ Nuke flame render modes 2 and 3
				+ Nuke shaders
				+ Replace RenderContext setting with booleam "DoDrawFlames" (default=true)
				+ GameController interface
				+ SettingsDialog: remove radio's and add checkbox under advanced
			+ Test with finer resolution, now that we have alpha
			+ Check perf of many flames on old Dell, before and after
				! 96 max burning particles, Ark
				+ 1.15.4: start=30 end=17.7 upd=20.5 rnd=30-33
				+ 1.16.1: start=OK end=23.7 upd=20.6 rnd=21.4
			+ Make GameJolt poll
				+ Side-by-side video
			+ Test with high wind
			+ changelist
		+ Stop reset resetting zoom
			+ New GameController method: ResetAndReloadShip(...)
				+ Invokes internal helper that takes additional StronglyTypedBool
		+ Water surface improvement:
			+ Split shaders for all ocean types: "xxx_sq" and "xxx_hq"
			+ RenderContext setting, "detailed" by default
				+ Double members
				+ RenderStartBasic/Detailed: zero out just that buffer
				+ RenderPrepare: switch
				+ RenderDraw: switch
			+ Expose setting via GameController
			+ SettingsDialog: checkbox next to OceanRenderMode
				+ "... Requires more computational resources."
			+ OceanSurface::Upload: inspect setting and invoke private templated function
				+ For now, just same upload
			+ Verify switch works
				+ Debug build as well
			+ See if WorldRenderContext::UploadWater(x2) Depth mode really needs yWater
				+ If not: remove oceanDepth arg
			+ Do Detailed Shaders
				+ Exercise first on ShaderToy with parameter for back plane
				+ Texture
				+ Flat
				+ Depth
				+ Do BackToggle parameter at two draw's
				+ Adjust border thickness: redo vertex attributes so that yBack/Mid/Front are world, and texture is passed separately based off yMid
				+ Also adjust border thickness with zoom parameter
			+ Do WorldRenderContext machinery	
			+ Do OceanSurface::Upload
				+ Basic
				+ Decide which of the three planes is going to be the "at" plane
				+ Optimize w/whole samples
					+ Pre: UPDms=6.6
					+ Do
					+ POST: UPDms=6.5
				+ Test with Debug build
			+ See GLSL optimizations
				+ Beginning: RNDms=7.44
				+ Less smoothsteps: 6.4/6.7				
				+ Trimmed down shader with second pass: 5.5/5.6
					+ Using #define's and #ifdef's
						+ Make sure ShaderManager supports global #define's: in SplitSource, just duplicate everything above first ###VERTEX-120 into both portions
						+ Issue with "#version 120"'s: 
							+ Option 0: ###VERTEX-120
							+ Review HeatBlaster
				X Less fDxf calls? 5.47ms => 0_calls: 5.07ms == 0.4ms 1+1_calls: 5.26ms
				+ End: RNDms=5.4/5.6
			+ Use max for border widths
			X See whether main plane should be mid
			+ Test
				+ Tsunami
				+ All 3 render modes
					+ Also with ocean depth = 0
				+ Old Dell
			+ Default is ON, but set at Calibration anyway
				+ From gfx properties & CPU properties	
		+ Re-design little waves with wind gusts
		+ Interactive SWE state machine: 				
			+ Use smoothstep process
				+ Time to end of phase should be proportional to deltaH
					+ Try all the way
					+ Still, mid-deltaH is too slow
			+ Try restart with same algo as ParamSmoother
			+ Make duration based on delta between target and baseline, rather than delta between target and now
			+ Try with decay process on fall
			+ changelist
		+ Send to testers
		+ Fix issue with I.J.N.Yamato burning & new decay
			+ Calc parameters at Points cctor
				+ Move Ship::LowFrequencyPeriod to GameParameters as ParticleUpdateLowFrequencyPeriod
			+ Calc parameters at param changes
			+ Optimize application of params
			+ Test paper, wood, and iron decay
			+ Test ship with those settings
			+ Test adjustment
			+ Test normal rotting
		+ Send/complete localization
			+ Change copyright year
				+ License.txt
				+ EN (in-code)
				+ All .po files
			+ IT1
			+ ES1
			+ RU1
			+ IT2
			+ IT2
			+ ES2
			+ RU2
		+ Taureau_class
			+ Replace Vardenaux
			+ Take treaureax
			+ Asked if both Teaureaux's
			+ changelist
		+ Add styrofoam
			+ Density: 50 kg/mÂ³
			+ Melts at 513K
			+ https://en.wikipedia.org/wiki/Polystyrene
			+ Make new template
		+ Test:
			+ Localizations x 3
			! Flames, water surface, calibration:
				+ Samsung - take perf as well
				+ HP - take perf as well

		+ Merge to master
		+ Release 1.16.1
			+ Branch is merged into master (if applicable)
			+ MSI variables
			+ Commit & push
			+ 64-bit MSI
				+ Build Install
				+ Make MSI
				+ Rename MSI
				+ Test upgrade from previous version
			+ 32-bit MSI
				+ Build Install
				+ Make MSI
				+ Rename MSI
				X Test clean install
			+ Send both installers for testing
			+ Wait for test results
			+ Cut tag on github
			+ Upload packages to GameJolt
				+ Report file as safe (https://gamejolt.com/privacy)
				+ Post
			+ www.floatingsandbox.com:
				+ Upload changes.txt
					+ Test w/old FS
				+ Update current version in FAQ
	+ 1.16.3
		+ Branch to new branch
		+ Lantern fish at big depth
			+ Do selective spawning
				+ Redo fish<->shoal assignment algo @ spawn
				+ Test:
					+ Lantern fish with and without OK depth
					+ Decrease & re-increase # of fishes
		+ NewVersionDialog & other: display short version (i.e. no Build)
		+ Log date at startup
		+ Way to enable single-threaded rendering, one-shot
			+ Class GameCore::BootSettings
				+ bool DoForceNoGlFinish
				+ bool DoForceNoMultithrededRendering
				+ static factory Load(path)
					+ ResourceHelper provides helper (used by caller)
					+ If version not current => empty (w/defaults)
			+ Instantiated and loaded by MainFrame at init
				+ Local member
				+ Struct passed to each cctor/initializer that needs it
					+ RenderContext uses it for glFinish
						+ Cooks own mDoInvokeGlFinish
					+ RenderContext uses it for MT rendering
						+ Passes to thread
			+ Alt-D bootsettings:
				+ Opens window, w/large disclaimer on top
				+ Window also loads its own copy of settings
				+ Save: deletes if identical to defaults
					+ BootSettings default cctor is the defaults
						+ Used also to populate at BootSettings::Load
					+ Populates default one with checkboxes and then checks == with default-constructed BootSettings
				+ Revert to Defaults
					+ Populate checkboxes with defaults from default-constructed BootSettings
				+ Then saves upon "Save" button
		+ Add velocity probe gadget
			+ Requires Gadget Rearc (*) first
			+ Font rearc
				+ See first sizes of both font textures: 256x256
				+ TextureTypes: font groups w/one group only
				+ Move RenderTypes::TextType to private of NotificationRenderContext
					+ Specialize RenderContext/NotificationRenderContext methods, which simply fw to helper w/enum value
				+ TextNotificationContext carries FontMetadata & and atlas frame metadata & of own font
				+ Init: of all fonts, make one single texture (linear atlas)+vao+vbo
				+ Lines: per-type of text notification, rather than per-font
				+ Uploads:
					+ Mark individual TextNotificationContext's dirty flag 
				+ RenderPrepareTextNotifications:
					+ If any TextNotificationContext has dirty text:
						+ Regenerate its quad vertex buffer
						+ Clear TextNotificationContext dirty text flag
						+ Remember to re-upload whole vertex buffer
					+ If need to re-upload whole vertex buffer:
						+ Upload whole vertex buffer via multiple sub-uploads
				+ Font::Metadata rearc:
					+ Font::Fontmetadata is basic straight from font (integers, etc.), and no EmitQuadVertices
					+ A new struct in NotificationRenderContext ("FontTextureAtlasMetadata") contains the atlas/texture-scaled version
					+ A new EmitQuadVertices() method in NotificationRenderContext contains the code that was from Fontmetadata
					+ mFonts goes and store instead vector of FontMetadata
					+ Make allocation sticky
				+ Draw: make one single call
			+ GameController logic: always-present state machine 
				+ Implements driving of NotificationLayer's PhysicsProbePanel
				+ Emits panel sound events
				+ Implements event handler and decides when to pass probe reading event through to NotificationLayer					
			+ Move state machine from GameController into NotificationLayer
				+ NotificationLayer gets EventDispatcher at cctor
				+ Initial delay before starting panel
				+ Tells NotificationRenderContext when text should disappear (i.e. whet opened transitions from 1.0 to != 1.0)
			+ NotificationLayer:
				+ Uploads panel's opened to NotificationRenderContext at next Upload()
					+ Needs dirty flag
				+ Uploads reading and/or clear to NotificationRenderContext at next Upload()						
					+ mIsPhysicsProbeReadingDirty flag (like others)
			+ NotificationRenderContext:
				+ New NotificationRenderContext notification "type": PhysicsProbePanel
					+ Upload is sticky: when uploaded, clears buffers, creates vertices, and sets dirty flag
						+ When opened==0.0, clears the buffer and stops
					+ RenderPrepare: upload if dirty
						+ Alloc if size > allocated
						+ And clear dirty flag
					+ RenderDraw: draw if vertices not empty
					+ Texture for background of panel
						+ 200x100
						+ Speed
						+ Temperature
					+ See right noise texture (we want the "rough" one, i.e. small)
					+ Panel grows vertically first
				+ New NotificationRenderContext text notification type: PhysicsProbeReading
					+ UploadPhysicsProbeReading
						+ Emit vertices with two new anchor types
					+ ClearPhysicsProbeReading
					+ 7-segment font (including - and .)
						+ DSEG7 Modern-Regular, bold, 16 [18x18, adjust .], normal AL, (242, 255, 0)
						+ [Aug 2021] DSEG7 Modern-Regular, bold, 13 [15x15, adjust . as width modf=2], normal AL, (242, 255, 0)
						+ Color?
					+ Adjust panel: 
						+ Larger backdrop for reading (eventually larger panel altogether)
						+ See if need darker and/or smoother backdrop for better contrast
			+ New gadget & tool
				+ Enum
				+ MainFrame menu entry - no keyboard shortcut
				+ Tool
				+ IGameController::TogglePhysicsProbeAt
				+ Gadgets:
					+ TogglePhysicsProbeAt
					+ RemovePhysicsProbe
				+ Cursor: physics_probe_cursor
				+ Place/Removal Sound
					+ Event publishing
					+ Also underwater sound					
				+ Physics publishing at Update()
			+ Panel open/close sound, time-syncd with panel
				+ Event publishing
				+ Sound
			+ Cleanup:
				+ Gadgets spring->point rearc: 
					+ First off, verify gadgets currently freeze when their spring is destroyed - which we'll fix with this change
					+ Move "IsGadgetAttached" shebang from Springs to Points
					+ See if can move detachment from point (i.e. for mass) completely to Gadgets, just like
					  attachment is
					+ Overall: Gadget attachment: to ship points (no ephemeral) which are attached to at least one spring and which
					  have no other gadgets attached
						+ Gadget base remembers point's first spring index for giving back rotation angle
							+ "TrackedSpringIndex"
						+ On spring destroy: do same trick as now, crystallize angle
					+ PhysicsProbe final tasks:
						+ Gadgets::OnSpringDestroyed: also deal with PhysicsProbe
						+ Toggle algo:
							+ If there's a probe in radius: remove it and done
								+ Publish event: removal makes sound
								+ return false
							+ Else if found good candidate particle:
								+ If there's already a probe on the ship: remove it (basically we move it)
									+ No event: (we're moving it) (no removal sound)
								+ Create new probe
									+ If we are not moving: publish event (sound)
								+ return true if we are not moving, else nullopt
							+ Else:
								+ return nullopt
						+ See if may move mGameEventHandler->OnGadgetRemoved(.) call from each gadget's OnExternallyRemoved() to where we invoke
						  OnExternallyRemoved in Gadgets
						+ Merge removal code in Toggle() and RemovePhysicsProbe()
					+ Cleanup:
						+ Gadgets: see if may unify ToggleGadget<T>/TogglePhysicsProbeGadget
							+ Or at least use same procedures when adding and removing a gadget														  
						+ See if IGadget::GetPosition is really needed
							+ If it's needed, then also add GetPlaneId()
						+ Rendering: it seems order of gadgets and explosions is screwed
							+ It's a problem with the bomb being detached upon explosion and thus taking a new Z plane; freeze plane ID as well
					+ Tests:
						+ Run all scenarios in debug, for all gadgets
						+ Freezing of rotation axis @ spring destroy
						+ Detachment at bomb explosions: make sure explosion does not move
				+ Make RenderContext expose GetNoficationRenderContext() and nuke all forwards
				+ Improve gadget texture
					+ Antennas on top
				+ Cursor: slightly thicker stroke
					+ Or different altogether
					+ Adjust anchor
				+ Run panel open/close in Debug
				+ changelist: re-architected "bombs" as generic "gadgets"...
			+ Nuke inertial velocity notification
				+ GameController et al
				+ UI preferences
				+ Preferences dialog
			+ Test perf of panel opening on old Dell
		+ Boot settings:
			+ 3-valued optional's
			+ Consumers use flag exclusively if set
			+ Test
				+ glFinish
					+ Now
					+ Simulate Intel HD
				+ MultiThreaded:	
					+ Now
					+ Simulate Mac
		+ Scrub/Rot tool (*)
			+ Changelist
		+ Investigate missing pin/gadget sounds when paused
			+ It's due to game clock stopping and time used @ StartedTimestamp/duration
			+ Migrate SoundController away from GameClock
		+ Cursor change rate
		+ 0.8 water crazyness
		+ Sinking speed:
			! Real Titanic's bow sank at 10.7m/s or 15m/s, FS sinks at 6..7m/s				
			+ We get to 10m/s by lowering Global Damp Adjust to 0.08, so consider not applying global damp for underwater points, which means:
				+ Copy old exe first
				+ Take speeds with old:
					+ Titanic sinking: 6.4m/s (@ GlobalDampAdjust==0.00: 36.7)
					+ Plane falling: touchdown is at 41m/s (@ GlobalDampAdjust==0.00: 97m/s)
				+ Test with following global damps, looking at explosions, debris, etc. in *air*
					+ 1: with water intake at minimum, particles/springs dance for a very long time
					+ 0: some violent ejections of springs, but nothing broken
					+ 0: with water intake at minimum, particles/springs accelerate
				+ Old math:
					+ Verify global damp == 0 means no vel damping at Ship::IntegratePoints(.)
					+ globalDampingCoefficient=0.99988; velocityBuffer[i] = deltaPos / dt * globalDampingCoefficient;
					+ 30 iterations
					+ vN = (d^N)*v0; // d^N = 0.99640
				+ Impl:
					+ Global damp adjust=0.0f - for now
					+ Point-by-point: 
						+ !Underwater: add same drags (friction and pressure) as water, but different magnitude
						+ Pressure drag: interpolate coefficient close to interface, and thus nuke if/else (air/water is now in coefficient)
					+ First finalization:
						+ Parallel GameParameters settings for air drags
						+ SettingsDialog
							+ Mechanics, Air, and Fluids
								+ Move lights to Wind, Waves, Fishes, and Light
					+ Lower apd
						+ 0.5: barely visible on hydrodynamics test, but cardboard tower ok
					+ Optimize Mix
						X No need for by-point
						+ See if needed for by-frontier
					+ Tests: 
						+ Debris, with and without WaterIntake=0
							+ Now that the only brake to debris is friction, see if we need more friction
								+ Air
								+ Water - can't increase too much, or else air bubbles freeze
						+ Cardboard tower
							x With air pressure drag = 100, there's oscillations
							+ With air pressure drag = 10, there's no oscillations
						+ Cardboard ships
						+ Air/Water ship
						+ Hydrodynamics test
						+ Airplane falling
						+ Blimps
						+ Trellis
						+ Titanic splitting + sinking
					+ Zero-wind button
					+ Finalization:
						+ Interpolations for discontinuities
							+ Do all @ Ship::ApplyWorldForces
								+ Have a single multiplier used for all forces
							+ See to optimize Mix with 1 mult only
								+ Check assembly
						+ Test perf on old Dell
						+ Finalize good settings, reset all adjustments to 1.0
							+ Set coeffs accordingly
							+ Nail down adjustment ranges
						+ Nuke Ship::ByPoints
			+ changelist
		+ Aerodynamics, as well
			+ changelist, together w/drag
			+ video & post
		+ Optimization: OceanSurface and OceanFloor ::GetNormalAt(x)
			! Optimized: no second sampling needed!
			+ Track down all usages
				+ See if OceanSurface really needed: no
				+ Do OceanFloor
				+ Track usages of OceanFloor::GetHeightAt and make sure always in boundaries
					+ Then remove "allow for derivative taking"
					+ Also at OceanSurface
			+ Test in debug
		+ Send for testing
		+ HandleCollisionsWithSeaFloor optimization:
			+ Fast check: go away if y > max of two samples's y's
				+ 8.98%%: if (y > mSamples[sampleIndexI].SampleValue && y > mSamples[sampleIndexI + 1].SampleValue)
		+ See vector normalization optimization with mult's with 1/len
			X It's already assembled like that
			+ SSE version 2
			+ SSE version 2 with length
			+ Unit tests:
				+ normalize_approx()
				+ normalize_approx(len)
			x Use normalize_approx(len) at spring iteratations (w/profiling)
				+ Get assembly before & after
				+ Before: Ship::ApplySpringForces_BySprings: 54.87%, UPD=4.90ms (@20s)
				+ After: Ship::ApplySpringForces_BySprings: 54.73%, UPD=4.89ms (@20s)
			+ Use normalize_approx() at water dynamics (w/profiling)
				+ Before: 8.98%
				+ After: 7.95%
				+ Test
			+ Test perf on Dell
			+ Redo profiling above
		+ Rot tool:
			+ An option for the radius (also for scrub)
				+ SettingsDialog
			+ Faster rotting
		+ Send for testing
		+ ShipBucket:
			+ Split author by ';', put remainder on next line prefixed with "art by:"
				+ Do split at metadata load time, exposing "ArtCredits"
				+ Add check to verify_ships.py to make sure author contains 0 or 1 ';'
					+ Run on all
				+ Change dialog
			+ I also like a warning not to repost the work on youtube, though i'm sure people will ignore this (we cant control everything unfortunately :wink: )
			+ Ask Fernando for his ships
			+ Tell CPM/Wreno rules for using ShipBucket
				+ Credits format		
		+ Faster probe readings
		+ Water temperature goes down with depth (thermocline)
		+ Waves from ship (*)
		+ Send for testing
		+ DKUZ bug with yellow dots
		+ Repair improvement:
			+ See if it's due to triangle forming folded
				+ Add log when we calc a point's destination, if that point repair would result in a new triangle
				  that is NOT clockwise wrt current point positions
				+ Prevent CCW triangle from being formed altogether
			+ Improvements to try:
				X Attractor must have more springs attached than attractee
				+ Local consistency of attractor/attractee roles: ensure that if one particle is attractor, also its directed neighbors are
					! Spec:
						- Pass 1: for each point p that is in radius and which was an attractor in the previous step and which has not been an attractee in this step
						  and which needs reparation:
							- RepairFromPoint(p)
								- Conditions for being an attractee: not having been an attractor in this step
								- Upon spring restore: forget attractee role at this step
							- Visit all points p' from graph visit starting at p, such that: p' is in radius and needs reparation and has not been an attractor in this step and has
							  not been an attractee in this step
								- Do visit breadth first, truncating when not in radius or when doesn't need reparation or when has been attractee in this step or when has been attractor
								  in this step
						- Pass 2: find new points p that are in radius and which have not been already an attractor in this step and which have not been an attractee in this step
						  and which need reparation:
							- RepairFromPoint(p)
							- Visit all points p' from graph visit starting at p, such that: ...
					+ Impl:
						+ Move repair code to own source file
						+ Points::RepairState:
							+ LastAttractorRepairStepSequenceNumber, LastAttractee...: type is SequenceNumber
						+ Tool:
							+ Pass just sequence number
							+ Increase seq num (skip) at each mouse down
						+ Do
				+ See why roles sometimes flip
					+ Attractee from prev step becomes attractor
				+ Try to straighten out CCW structures
					+ Idea 1: as a separate, initial step, before repairing: for each two-now_naked-spring arc, make sure two springs are in right angle wrt central point
					+ Idea 2: expand idea 1: as a pre-step: for each in-radius point: for each naked spring: make sure it's in right angle
					+ If works, consider doing trying these which at the moment we can't do because of
					  folded structures:
						x Remove role-taking: allow attractor to take on role of attractee, and viceversa
						+ Lower distance tolerance (e.g. 0.03 or lower), to prevent newly-repaired springs from breaking up immediately again
						x Allow each particle to act as attractee only once per step
				+ Larger radius: 4
				+ Final velocity of restored particle is avg of all connected
				+ Velocities:
					X Issue with half titanic: try with more inertial velocity
					X Issue with dancing dots: try: target pos is half-way between offseted with attractor's velocity * dt
						+ Variable names for point/other endpoint: attractorPoint and attracteePoint
				+ Final boost after max consecutive number of steps
				+ Test 2 repair settings extremes
					+ Speed
						+ Fixed max
						+ Rewrite so that adjustment changes smoothstep's time horizon
					+ Radius: see why slows down @ 10
						+ Perf:
							+ Store in-radius points at first pass, and keep using it
								+ Nuke subsequent useless radius checks
							+ Avoid queuing for out-of-radius
				+ Expand delta2 trick to all deltas
				+ See if may simplify octant finding by considering just one spring (say, nearest CCW)
				+ Clear visit seq at repaired
				+ Scale forces on attractee depending on # of its springs
					+ Grow with # of springs
			+ Final:
				+ Perf: accumulate points from first pass in vector for 2nd pass
				+ Cleanup TODOs
				+ Run in Debug
				+ Check perf on old Dell
			+ changelist
			+ Merge
		+ Second look at DKUZ's bug
			+ Was there in 1.16.2 as well
			+ Repro's with float uniform, clamped between 0.0 and 1.0
			+ Ensure that it's due to negative values in fragment shader when vertex shader always has positive
				+ Test shader: remove fix; clamp at vertex
				+ Quantize at fragment when negative
			+ See if it only happens with Line primitives (i.e. that it doesn't happen with Triangle primitives)
				+ It doesn't happen with Triangle primitives
			+ Use #define's for turning on/off clamping - and for temperature
				+ ship_texture.glslinc:
					+ vec3: 6.83/6.81
					+ 3 floats: 6.84/6.84
				+ pre-perf: [vec3]: 5.39ms @20ms
				+ do
					+ ShaderManager: extract uniforms and vertex attributes from OpenGL APIs, not from parsing
						+ Actually, reduce extraction of things via parsing to nil, if there's anything else
					+ Nuke old shaders
					+ Check StressedSprings
					+ Fix ShaderManager unit tests
				+ post-perf: 5.22
		+ Waves:
			+ See Base III
			+ Try to smoothen peaks with avg=5
			+ Test perf with Base III (many frontiers) with and without displacement
				+ With: ApplyWorldForces=2.73%
				+ Without: 2.38%
			+ See maximum adjust
			+ Test all ships
				+ Add offsets where needed
		+ Adjust terrain lock
			+ Help
				+ Also add Rot, etc.
		+ Incandescence layer (*)
		+ Default settings: 
			X Flatten waves?
			+ Lower speed of (sin) ocean waves - now that we run faster


		+ Send for testing
		+ Send for localization
			+ Give GitHub diff for Help: https://github.com/GabrieleGiuseppini/Floating-Sandbox/commit/9ef5e00d5d1a35d63eea6ce757000951e043dd80?branch=9ef5e00d5d1a35d63eea6ce757000951e043dd80&diff=split
		+ Bump up version
		+ Fix Pac0master's bug
		+ Bump up version
		+ Fix bug 2
			+ Test on both cards
		+ Bump up version
		+ Localization
			+ IT
				+ strings
				+ help.html
			+ ES
				+ strings
					+ Fix "Sets wind speed to zero"
				+ help.html
			+ RU
				+ strings
					+ Fix "Sets wind speed to zero"
				+ help.html
		+ Timcan bug with engine sound goin' off
			+ "yeah just select a ship with an engine, it will start the engine sound and after 15-20 seconds the sound will cut off"
		+ Bump up version
		+ Release
			+ REMEMBER: remove debug logging for Mac, see above
			+ Branch is merged into master (if applicable)
			+ MSI variables
			+ Commit & push
			+ 64-bit MSI
				+ Cleanup Install
				+ Build Install
				+ Make MSI
				+ Rename MSI
				+ Test upgrade from previous version
			+ 32-bit MSI
				+ Cleanup Install
				+ Build Install
				+ Make MSI
				+ Rename MSI
				+ Test clean install
			+ Get both installers tested:
				+ Dev server
				+ John Smith: 64
				+ Fernando: 32
				+ LucaAlex: 64
				+ MMorin: 64
				+ Old dell: 32
			+ Cut tag on github
			+ Upload packages to GameJolt
				+ Report file as safe (https://gamejolt.com/privacy)
				+ Post
			+ www.floatingsandbox.com:
				+ Upload changes.txt
					+ Test w/old FS
				+ Update current version in FAQ
	+ 1.16.5:		
		+ Make branch
		+ Bump up version
		+ Cleanup TODO list
		+ Wix: delete Data folder on install
			+ https://www.hass.de/content/wix-how-use-removefolderex-your-xml-scripts
		+ Debris:
			+ When ship has water all over the place, debris particles start life without water and thus look too different than surroundings - at least for first 0.5 seconds
		+ Fix Gadgets: 
			+ Opposite assert at Gadgets::Update
			+ Each gadget must detach itself when expiring from state machine
			+ Test with vectors after bomb explosion (and thus disappearance)
		+ Rework explosion dynamics: they are too inconsistent at this moment
			+ RenderSetting: DrawExplosions, exactly like DrawFlames
				+ Rendering
				+ SettingsDialog, @ "Advanced Settings"
			+ Ship::ExplosionStateMachine:
				+ Factor that calcs blastProgress from CurrentProgress: 3.0 -> 4.0
			+ GameParams: bomb blast radius ~= 6
			+ Ship::ForceFields:
				+ Good force: 
					mPoints.GetNonSpringForce(pointIndex) +=
							pointRadius.normalise(std::sqrt(squarePointDistance))
							/ std::max(std::sqrt(squarePointDistance), 1.0f)
							* strength
							* 40000.0f // Magic number
							;
			+ Test with blast force on _all_ particles - not only just the ship ones
			+ Heat: lower heat at higher distances from center?
				+ Then see if it might make more sense to nuke ApplyBastForceField and put its code directly in explosion state machine
			+ Ultraviolent mode: changes all 3 (Radius, BlastForce, Heat)
				+ Expose BombBlastForceAdjustment first
				+ Do @ each bomb
			+ Tests:
				+ 3 Bombs
				+ Explosive combustion
				+ Blimp
				+ All: also with Ultra-Violent mode
				+ Bomb blast radius min/max
			+ changelist
			+ Send to Pac0 & John Smith
			X Try with scaling up forces with masses
			X See if need heat blast to be larger, in order to catch fire on the rim
		+ Whole OceanSurface: use FixedSizeBuffer's instead of std::unique_ptr<float[]>'s
			+ Perf measurements:
				+ Before: UPD=4.89/4.90
				+ After: same
			+ Run in DEBUG
			+ Check assembly
		+ Cut tool
			+ See issue
				+ Try 0.25 instead of 1.0
			+ Do "SHIFT lock"
		+ New tool: Blast
			! Spec:
				+ Same force field as Explosion state machine
				+ Hitting SHIFT makes it faster and stronger
			+ Impl:
				+ Cursor
					+ Cursor 1 and cursor 2
				+ Tool:
					+ When hitting:
						+ Cursor disappears
						+ Sound starts (depending on SHIFT)
						+ Tool's state machine starts
							+ Speed and strength depend on SHIFT
						+ End of blast doesn't change anything - only mouseup does
							+ ...and at mouseup, cursor reappears
					X Decide what to do during phase paused
					+ Finalize durations - seem a bit too long now
				+ Physics
				+ Shader: 
					+ Link between IGameController::TODOBlast and NotificationLayer->Context
					+ Basic shader
					+ Advanced shader, option 1: different blending: whiteish overlay expanding, thicker on rim
						+ Provide progress
						+ Do blending
						+ Add personality
					+ See if it needs noise
				+ Sounds:
					+ Sounds normal
					+ Sound faster
				+ Disturb ocean surface
					+ At World
				+ SettingsDialog:
					+ Refactor: 
						+ Fonts
						+ 1: new SettingsDialog
							+ Take all screenshots
							+ Do
								+ Try using StaticBoxSizer instead of static boxes
								+ See to center notebook panels that are less wide
								+ Fix single checkbox + slider vertical cell
									+ Set size of row == constant, taken from button
								+ Move UltraViolent to first panel
								+ Rendering panel
								+ Sound and Advanced Settings
									+ Add:
										+ GenerateSparkles (New box)
										+ GenerateDebris
										+ Draw HeatBlaster Flame (Extra Draw Options)
								+ Settings Management
								+ Multiline notebook
								+ Nuke settings:
									+ air bubbles displace waves: honor global displacement instead
									+ generate air bubbles: use zero density
							+ Nuke old source files and old code in remaining source file						
						+ 2: Shorten labels
							+ Fluids: remove redundant "Water" 
							+ Remove other redundant parts of labels
							X "Adjust" -> "%" ?
						+ Final test
					+ BlastToolRadius
					+ BlastToolForceAdjustment
					+ merge
				+ Finalize all three current default radii
				+ Finalize maxima of all settings, & ultra-violent mode			
			+ changelist
			+ Update help
		+ Change rot tool with UV mode
		+ New rain: https://www.shadertoy.com/view/tttyDB
			+ Do
			+ Wind rearc:
				+ Wind uploads speed vector to RenderContext
				+ RenderContext calcs magnitude, runs avg, and if different dispatches to WorldRenderContext and to each ShipRenderContext
				+ WorldRenderContext: 
					+ UploadWind: store and set dirty, both as "RainWindAngle"
					+ RenderPrepareRain: only if will be drawing rain: pick up dirty flag, set param, and clear flag
				+ ShipRenderContext:
					+ UploadWind: store and set dirty, both as "FlameWindAngle"
					+ RenderPrepareFlames: only if will be drawing flames: pick up dirty flag, set param, and clear flag
				+ RenderContext::Reset: 
					+ Reset average
						! Enough, as next wind upload would generate different value than current member value and thus trigger param set's
				+ Stop uploading wind with flames
					+ Nuke Ship::mWindSpeedMagnitudeToRender
				+ Tests (also across reloads)
					+ Flame
					+ Rain
			+ Wind magnitude
				+ More vertical at beginning and less horizontal at max
					! Wind speed magnitude during storm: 60-125
					+ Function we want: 60 => 0.1, 120 => 0.8
			+ Check spatial density
			+ Check density dynamics: goes from zero to max too quickly
				+ See if MaxRainDensity calc'd at Storm needs to be adjusted - see progression from no rain to max rain, and also setting
			+ Test viewport size change
			+ Test perf drop on Dell - simply perf during storm before and after
				+ Old: 30fps/12-13msRND, Storm: 18fps/35msRND
				+ New: Storm: 18/35 @ 2:20
			+ Changelist
		+ Interim localization (help + po)
			+ IT
			+ ES
			+ RU
		+ Fix "cycle of sounds" issue with sounds
			+ Limit stress and break sounds' proximity *regardless* of chosen buffer
				+ But allow greater size
			+ Cut initial silence @ all break sounds
			+ AddVolume becomes exponential: v' = v + (100-v) * dv
				+ Remove exponential from InternalSetVolume
			X See if break's minTime might be lowered
			+ Medium<->Large boundary
			+ Double-check sounds
				+ Metal; replace:
					+ break_metal_large_2
					+ break_metal_large_3
					+ break_metal_large_underwater_5
					+ stress_metal_large_underwater_1 (clicks)
				+ Wood
				+ break_glass_small_1
			+ Take new wood stress sounds
			+ More stress metal sounds, to dilute "cycle of sounds"
		+ Cached depths (*)
			+ 1.16.3: Titanic: 7.92, now: 7.65
			+ Check perf on old Dell:
				+ Before: 29.6/29.9 FPS, 20.04/20.2 UPD
				+ After: 30.4/30.5 FPS, 18.8/19.1 UPD
		+ Larger world
			+ GameParameters
				+ Double size
			+ Restrict tsunami creation area so that it won't travel more than 5k
				+ Or alternatively, lower its height
			+ Check rogue waves as well
			+ OceanFloor
				+ Keep # of samples
				+ Double the width of default ocean floor so that it's more dense
					+ Add more to the left and to the right
					+ Also change depth at middle so that it fits with new bumpiness and it's ~-283
						+ Or simply change the bumpiness frequency or phase, whichever looks best
				+ Test Mariana's Trench
			+ OceanSurface				
				+ Fix manual waves
					+ Try to re-instate full SWEs
						X If works, see if can put back tsunami's parameters
					+ Look back at SWEs (*)
						+ changelist
							+ Improving the stability of a simple formulation of the shallow water equations for 2D flood modeling, https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2011WR011570,
							  de Almeida et al (2012)
				+ Double # of samples
				+ See if Update() becomes too heavy
			+ changelist		
		+ Send for testing
			+ bishobe64 as tester
				+ Invite
		+ Bump up version
		+ OpenGL optimizations
			+ Clear color
			+ Perf: 5.88/5.90
			+ All dirty flags at RenderParameters
				+ See assembly
			+ Edge springs
				+ See how heavy: quite
				+ Springs has new ElementCount member, CoveringTrianglesCount
					+ Triangles: need new immutable container, "CoveredSprings", similar to SubSprings - so to act at Triangle::Destroy later
					+ Springs::Upload: consider this count instead of count of SuperTriangles
					+ Populated by ShipBuilder with same triangles as in SuperTriangles, plus covering triangles for traverse springs
						+ Triangles::CoveredSprings
						+ Springs::CoveringTrianglesCount
					+ Maintained at Triangle Destroy and Repair
						+ Should be exactly as with SuperTriangles container, but updating only counts
			+ Profiling w/Basic
				+ Ocean SOLs (35% + 30%)
					! (https://developer.nvidia.com/blog/the-peak-performance-analysis-method-for-optimizing-any-gpu-workload/)
					+ starting TEX=44.9
					+ Tests:
						+ Texture format: no alpha
			+ Profiling w/Bubbles
			+ Perf: 5.68/5.71
			+ Old dell: 
				+ Before: 30.4 (19.0, 12-13)
				+ After: 31.9 (19.1, 11.8)
		+ Add whistle: pipe_steam_whistle_for_fs.mp3
			+ changelist
		+ See if can get SHIFT key state via ProcessKeyDown/Up instead of hack at GameTimer
		+ Force rendering: avoid rendering expired ephemeral particles
			+ Transform ShipRenderContext::UploadVectors from a one-time Upload call with batch to a Start/NxUpload/End call pattern,
			  with Start() doing the reserve() call we currently do at the one-time Upload call
		+ Pressure implosions / pressure crush (*)			
		+ See issue with ocean texture shading: texture coords change depending on cam: repro with pause and high zoom
		X See if also on Windows "High Quality Rendering" of water is faster than normal
		+ Test optimization: ApplyWorldSurfaceForces: only consider *external* frontiers
			! No drag, no displacement for internal frontiers. We are fine with it
			+ Test Base III before: UPD=17.30ms, plus weird water displacement
			+ Test Base III after: UPD=16.9ms, no more weird water displacement
			+ If ok:
				+ Remove checks for type==External @ AABB updating
		+ Electric Spark tool
			+ Infrastructure (tool, sound, cursor)
			+ Rendering
				+ ShipRenderContext machinery
					+ Rethink: it's bad that we continuously flag vertex buffer as dirty: it can be assumed to be always dirty when it's not empty;
					  use same strategy then that we use for...clouds?
				+ Shader
				+ Ship::Upload
					+ New Ship buffer: ElectricSpark, simple std::vector
						+ Reset at first update that was not preceded by the interaction
						+ Uploaded by Ship::Upload
			+ Redo rendering:
				+ Rendering struct contains immediately positions, rather than indices
					! We'd save on normalizations
					! It might also be better visually, allowing for sparks to "leave" the structure
				+ Starting point, ending point
				+ Direction
				+ Previous index or None (opt size_t)
				+ Review if all PointsToVisit members and RenderSparkle members are needed
			+ Fix sea disappearing: Titanic with strength=max engineThrust=max and sparkled engine, hitting ocean floor spike
				+ Test with clamping absVerticalVelocity to 10000 or 20000
			+ Fix juncture
				+ Previous and Next normalized vectors need to be passed to each Upload()
				+ Optimize locally
				+ Wireframe
				X Fix fork: substitute "nextDirection" with "nextL/RDirection"
					+ R is direction with min cross product
					+ L is direction with max cross product
					+ Both default-init'd with max/min limit
				+ Fix sharp angles (Goodyear test): clamp to 0.01
			+ Interaction
				+ Spark expansion logic
					+ Issue with parallel arms: see if reintroducing third-best helps
					+ Try with alignment being exclusively on original spring
					+ Change prob's:
						+ Fork: less absolute but more uniform along path
						+ Reroute: slightly more prob when distance~1
					X Fork probabilities: try with using pv.EquivalentPathSinceLastFork
					+ Fork probabilities: try with pre-calculated EquivalentPathLengthToNextFork
						+ Value = uniform(min, max), calculated at emplace time
					X After fork, proceed in both new directions
				+ Interactions: private OnPointElectrified(...):
					+ Takes also ElectricalElements
					+ Driven by interaction: upon energizing a point, calls into ElectricalElements
					+ Heat
						+ Depends on size of incoming, cumulative
						+ Lower the dependency on size (goal: longer to catch fire at center, more read hot at periphery)
							+ Avoid too much heat on central point: pass strength, and make it inversely proportional to size
					+ Rotting
						+ Depends on size of incoming, cumulative
					+ Interactions with ElectricalElements:
						! Call causes same "damage" to selected types of electrical elements as EMP tool (*), i.e. stores simulation timestamp in 
						  state of that electrical element, make it not working for a limited period of time
							! For each non-destroyed generator|pump|sounder|etc. that is in radius:
								! XYZ.state.DisabledEndTimestamp = now + small random variation
							! ElectricalElements::Update: generator|pump|sounder|etc.:
								! If now >= XYZ.state.DisabledEndTimestamp: XYZ.state.DisabledEndTimestamp.reset()
							! ElectricalElements::UpdateSource/Sink/Whatever:
								! XYZ is off if XYZ.state.DisabledEndTimestamp.has_value()
						+ Generator
						+ Lamp
							+ Sound controller: flicker sound should have some inertia
						+ Engine (on/off is from generator though, so only thrust here)
							+ EngineState: SuperElectrificationEndTimestamp
								+ Set at OnElectricSpark
								+ Checked for expiration at beginning of engines update loop
								+ Checked for ON-ness and thrust multiply at engine state management
					+ Gadgets
						+ Replace OnNeighborhoodDisturbed() with OnElectricSpark(pointIndex), & precise check for index
							+ Undo OnPointDetached change
			+ Shader:
				+ Different ratio of inner white vs. body
				+ Wider halo (linear? linear+smoothstep?)
			+ Test:
				+ Disconnected components
			+ Nuke EMP tool in this spec
			+ changelist
		+ Move ExternalPressure calc'n from Spring loop to right after that
			+ Test resultant net and torque before & after, with "Basic Shapes"
		+ Tests:
			+ Dynamic forces visualization
		+ Clear dynamic forces at position-changing interactions
		+ Add depth to physics probe
			+ Reading
				+ Interface
				+ Gadget
				+ Notification layer & display
			+ Do triple-system while you're at it ("SI (Kelvin)", "SI (Celsius)", "USCS")
				+ UnitsSystem GameType enum
				+ GameController-owned setting: "DisplayUnitsSystem"
					+ Storage
					+ Setters/Getters
						+ Setter: Tell NotificationLayer
				+ NotificationLayer:
					+ Own translation of reading into text
					+ On change:
						+ GameController's setter also tells RenderContext, who then sets parameter as dirty and NotificationLayer picks it up and passes it via a parameter at ProcessParameterChanges
							+ Shader: get and use AtlasTile1LeftBottomTextureCoordinates parameter
							+ NotificationRenderContext::UploadPanel: use texture-agnostic coords
						+ Re-publish reading - requires storing current raw values:
							+ OnReading -> StoreRawValues -> (Make Strings? &&) Make dirty -> Strings made at upload?
							+ OnChange -> (Make Strings? &&) Make dirty -> Strings made at upload?
				+ Redo panel for USCS
				+ UI settings manager
				+ PreferencesDialog
		+ Another hydrostatic pressure attempt: Frontier: do not act on non-hull points, but then compensate net resultant force (and may be resultant torque as well)
			+ Only on edges that are the center of three consecutive hull points
			+ Try adaptive net_force/net_torque zeroing
				+ See paper
				+ Rewrite algo so pressure force stem multiplication is last step - use 1.0 for stems before that
					+ Assert initially that dynamic forces is empty
						+ Verify in Debug						
				+ Best-each-time approach
					+ See if can integrate minimization, i.e. not only lambda=0:
						+ Calc net_total at both minimal-and-clamped lambdas, and use best of the two
							+ Store lambda as bestLambda, to use when min found
				+ Alternating approach:
					+ 1. Find point that makes force closest to zero
						+ When a tie (via tolerance, i.e. radius), compare also torque and choose one with torque being closest to zero
					+ 2. Find point that makes torque closest to zero
						+ When a tie (via tolerance, i.e. radius), compare also force and choose one with force being closest to zero
					+ See if Red October still explodes: yes - but it was already exploding even before stem multiplication
					+ Other lambdas
				+ See why explodes
					+ Should be order: Strain => Hydrostatic, but it's Hydrostatic => Strain
					X See if last beta also exploded at high depth
					+ See why pressureForceStem is so jumpy
						+ It's because UpdateForStrains causes new frontiers and their AABBs are not initialized yet
						+ Use geometric center
					+ Abnormal force at frontier knots: due to pressure force stem multiplied twice
				+ See if can initialize best'es with current nettorque/netforce
					+ Calc average # of iterations, F, and T before and after
						+ With numeric_limits::max: Hemisphere: 53/0.37/0.00... Triton: 8.4/0.05/0.00...
						+ With current nettorque/netforce: Hemisphere: 42/0.7/0.00... Triton: 8.0/0.05/0.00...
					+ Undo: we want to choose contributions > current net
				+ Algo for optimization *and* avoidance of double stem (explosion)
					+ 0a. Confirm by multiplying all DynamicForces by stem - once across all points
					+ 0b. Take perf measurements (default_ship, depth -= 200): Update:4.90ms, ApplyHydrostaticPressureForces: 3.47%
						Hesleden: Update:67.8ms, ApplyHydrostaticPressureForces: 6.27%
					+ Copy exe
					+ 1. Comment out current
					+ 2. Move ApplyWorldForces after UpdateForStrains
					+ 3. ApplyWorldSurfaceForces: calculate geometric center and store it with Frontier, together with AABB
					+ 4. Buffer:
						+ Struct member of Ship: HydrostaticPressureOnPoint
							- ElementIndex PointIndex
							- vec2f TorqueArm
							- vec2f ForceVector
						+ Buffer is owned by Ship, cctd'd at cctor of Ship
						! Buffer can be populated for same point multiple times, each time for a different "surface" of a frontier
					+ 5. Initial population of HydrostaticPressureOnPoint buffer:
						! Allow particles that appear twice in same frontier to appear twice in buffer
						+ Make loop inline
					+ 6. Equalization
					+ End: DynamicForces are only populated at end, by multiplying ForceVector with stem and adding to Points.DynamicForces
					+ Optimize
				+ Fix getting stuck at lambda=1:
				+ Optimizations:
					+ Start: Update=5.68ms, ApplyHydrostaticPressureForce=13.40% (LogMessage=7.88%)
					+ See if "min-3-consecutive-hulls" is still needed
						+ If decide to remove it, cleanup code
					+ End: Update=4.66ms, ApplyHydrostaticPressureForce=1.57%; Hesleden: 64.5ms, 2.01%
				+ Run in Debug
				+ Remove exhaggerations
			+ Test on melted long springs - after removing exhaggerations
			X Try moving dynamic force to last spring iteration, so it gets integrated and springs might break before propagation
			+ Apply air pressure as well
				! InternalPressure and hydrostatic pressure will never be zero - zero is really "somewhere" above MaxWorldHeight
				! Pressure at ocean surface zero (aka "PressureAtZero") is == column of air above (atmospheric pressure at sea level)
				+ Formulae class: implements formulae below
					+ Calcs effective air density, given temperature
					+ Cals effective water density, given temperature					
					+ Calcs volumetric water pressure, given temperature - VolumetricWaterPressure
					+ Calcs pure air pressure at height x - AirColumnPressure
					+ Calcs pure water pressure at depth x - WaterColumnPressure
					+ Calcs total pressure at height x - TotalColumnPressure
						+ airColumnPressure(clamp(height)) + waterColumnPressure(clamp(depth))
				+ @ ApplyHydrostaticPressure: 
					+ PressureAtCenter from Formulae::TotalPressure
					! Internal pressure counterbalance formula: denominator will never be zero
				+ @ Internal pressure intake:
					! Structural delta internal pressure and delta water are independent from each other
					! Forced delta internal pressure only depends on water
					+ Redo algo
				+ @ Flood tool:
					+ Use Formulae
				+ SettingsDialog: tooltip of HydrostaticPressureAdjust: add "atmosphere"				
			+ Try with internal pressure, again
				+ Re-instate internal pressure code
				+ Re-instate hull particles getting the average of all their non-hull neighbors
				+ Commit
				+ Use hull's internal pressure to counteract external pressure, at initial forceVector calculation
					+ forceVector *= 1.0 - internalPressure(Pi)/externalPressure * adj
				+ If goes thru: 
					+ Do all the internal pressure sidework:
						+ Flood tool
							+ Remove pressure only if water has been removed - remove pressure by effective water wuantity removed
							+ Test both incoming and outgoing
						+ Make sure pumps play nicely
							+ Pumping-in: internal pressure grows
							+ Pumping out: internal pressure decreases
						+ Rendering							
					+ SettingsDialog: make new group with new setting for internal pressure "contribution"						
					+ Optimize
						+ EqualizeInternalPressure: try with local buffer remembering all we do in the first loop
							+ Before: 4.96ms, 4%
							+ After: 4.91ms, 2.73%
			+ Internal pressure counterbalance:
				+ Counterbalance adj = 1: reasonable (Titanic still breaks at depth)
				+ See if can cheat and have "basically" counterbalance adj = 1, except at higher depths
				+ Remember GameParameters default is now 1
			+ Rearc settings:
				+ HydrostaticPressureAdjustment: becomes StaticPressureAdjustment, in Mechanics
					+ SettingsDialog: Mechanics, and exponential
				+ HPCounterBalance: stays
					+ SettingsDialog: merge with other water, and say "hydro"
			+ Custom probe for net force
			+ Explain counterbalance in tooltip
			+ Changelist
				+ Both (hydro)static pressure and internal pressure
			+ Merge back into master
			+ Mark internal pressure TODO item for internal pressure * as complete
			+ Send for testing
				+ Bump up version
			+ Cleanup commented out code
				= Make video first
					+ "1: the basics"
					+ With Triton large sinking slowly: "A hydrostatic pressure field consists of forces perpendicular to the exterior hull of the ship..."
						"...but simulating it in a particle system is not as easy as it may sound."
					+ ...
					+ @ Titanic unequalized: "The problem becomes even more pronounced with bigger structures"
					+ "2: iterative net effect minimization"
					+ ...
					+ Music				
		+ Send for testing (build 4)
		+ MaterialsDB rearc:
			! 170 materials
			+ Substitute N identical instances, in which only key color changes, with one instance having an _array_ of keys
				+ The key element in json may be either a string or an array of strings
				+ When it's an array of strings, there can't be a RenderColor element
				+ A missing RenderColor means it's the same as KeyColor
			+ At load time, that one material becomes multiple materials (non-invertible transformation)
			+ Coalesce already-existing materials
			+ Update palette-generation script
		+ Strength randomization
			+ Visualize strength first to ensure we don't already have fault lines
				+ New visualization mode
					+ SettingsDialog
			+ Inject: at ShipBuilder, after frontiers are created (i.e. almost at end); requires:
				+ Frontier creation: needs to come after points but before Springs are created
					+ Reasons in terms of SpringInfo's
						+ See if can also reason in terms of PointInfo's
				+ InjectCracks
					+ Do basic
					+ Try another crack algorithm
						+ Batik
							+ Finish region-relativity
							+ Find better way of doing index math/relativity
								+ vec2i @ vectors.h, replacing Matrix2Index and RectRegion
								+ Batik takes vec2i as Origin and Span arguments
							+ Convert also PointInfoMatrix to Matrix2
								+ Remove unneeded structureImageSize args
							+ Optimization (for e.g. BaseIII): initial random point is chosen on triangles
							+ Update distance map after each crack
							+ Density of cracks
								+ Largest dimension (among W & H) / 4..8 
								+ Use settings
							+ Set points' strengths at end, by making distance map = struct{distance, bool}
								+ Set strength only on points that have connected triangles
								+ Use settings
							+ Take & log running time
								+ Ark: 62/63ms, max density
							+ Consider optimizing for exclusive use of distance map, not point index matrix
								+ "PixelMatrix" -> "DistanceMatrix"
								+ And integral distances
								+ Distance map init:
									+ Init with 0 distance everywhere (will be the outside)
									+ Set to +inf all vertices of triangles
									+ Set to 0 for frontiers
								+ During algo: avoid points with distance 0							
								+ New time:72/73ms
								+ Finalization:
									+ Verify assembly for using lambda at UpdateDistances
								+ See if time increase is due to matrix indexing
								+ See what time increase is due to
									+ New matrix: 68/69
									+ float distances: 63/64
						+ Finalization:
							+ Skip randomization if any of the settings are zero
							X Consider using original distance (the one set at distance map initialization time) for scaling strength
								- Strength lowering is max at small distances, min at higher distances
					+ Parameters from outside:
						+ First off: refactor auto-texturization
							+ "DefaultSettings" -> "CommonSettings"
							+ Make ShipBuilder an instance of GameController, and make AutoTexturizer a member of ShipBuilder instead of GC
								+ ShipBuilder exposes setters for AutoTexturizationCommonSettings
						+ Then, make "ShipStrengthRandomizer" class
							+ Also member of ShipBuilder
							+ Dynamics of settings is same as AutoTexturization
						+ Density
						+ Magnitude (room for change)
						+ Add to GamePreferences
						+ Verify it is saved and loaded
			+ Default parameter values based on slider steps
			+ Test Titanic without breaking fault line: see if breaks by itself
				+ Make new ship given that you are at it
			X Checkout impact of sinking ship on sea floor; if gets pulverized, decrease weakening
			+ Tests:
				+ Paper
				+ Cardboard
				+ Blimps
				+ Base
				+ Ball of water and air
			+ Final params:
				+ change density so 0.803 is new 1.0
				+ 2, 0.6 (good for Triton)
		+ Do some normal wrecks and decide on default static pressure adjust value
			X First of all: try randomizing pressure with square of random: N, generates phantom forces and torques
			+ 0.242	
			+ See why Titanic is bunch of particles at 10Km: rotting?
				+ Full 10K fall w/out rotting: not pulverized, but quite shattered
				+ Full 10K fall with rotting: half pulverized
		+ Way to remove all pins (*)
		+ Menu with text and icon
		+ Hydrostatic pressure follow-ups:
			+ Repair tool:
				+ Ship has float mPostRepairGracePeriodMultiplier, from 0.0 to 1.0 - default is 1.0
				+ At end of update, converges towards 1.0 - with tolerance check to become 1.0
				+ Used at:
					+ ApplyStaticPressureForces for final multiplier of forces
				+ Test repair first
				+ Repair():
					+ At end sets mPostRepairGracePeriodMultiplier to 0.0
					+ Also at end, clears out whole dynamic forces buffer
						+ Remove ad-hoc setting of dynamic forces to zero
			+ Pressure tool:
				+ Like Flood tool was before, but only acting on InternalPressure
				+ Could repurpose bubble tool - does bubbles when no ship is found
				+ Shift modifier
				+ SettingsDialog - breakout tab, "Destructive Tools" and "Other Tools"
				+ Help
				+ Visual feedback
					+ Shader
					+ NotificationRenderContex: see disassembly for calls to RenderPrepare/Draw, and eventually inline
					+ Direction
				+ Sound feedback
					+ Tool: needs to remember which sound it was doing, in order to stop it
						+ See if fish tool structure serves the purpose
					+ Sound
					+ See if makes sense to have pssst sound always
				+ Try with larger visual feedback
				+ Not on hull
				+ Higher max flow
					+ Or higher UltraViolent mode			
			+ Blimps might need a hull, of a new material that's structurally not different than their current shell, but just hull - and may be less strong
				! Goodyear's current shell is currently normal cardboard (c1a46a)
				+ New material: Mylar, of "cloth" sound type
					+ Copy from cloth: stiffness and strength
					+ Hull
					+ Use real combustion properties
				+ Fix Mylar's weird bouncing on water
				+ Make inflatable balloon
					+ Inject pressure issue due to expanded graph and not finding particle: find triangle if can't find
						+ If ok: nuke InjectPressureRadius setting, and use GameParameters::ToolSearchRadius directly at Ship::InjectPressureAt()
					+ Internal pressure at start
					+ See if want to make it break at higher pressure by increasing stiffness of hull
						X See then if can lower strength					
					+ Description
					+ Issue with melting:
						X See if due to *decay*
						+ Implement adaptive extra melting-induced tolerance
							+ Store in precacld buffer, once and for all (immutable), with:
								+ MaterialStiffness (!GetMaterialStiffness)
								+ MaterialStrength (!GetMaterialStrength)
								+ MaterialMeltingTemperature (!)
				+ Change Goodyear's hull to Mylar
				+ Do also other blimp
				+ Regenerate materials palette
				+ changelist, also for material
					+ Mention also other colors for materials, with total # from 170
			+ Turn off hydrostatic pressure counterbalance adjustment when above water
			+ Add AirDensityAdjustment setting-ability
				+ Nail down max
				+ Fix zero
				+ See if can increase max WaterDensityAdjustment (was: 4.0) - 10.0 is fine, 100.0 cool, but generates weird upward displacement
					+ Fix upward displacement
				+ changelist
			+ Finalize StaticPressureAdjustment
				! No adjustment for air pressure, it is redundant - we have air density now, and it's the same with water
				+ Goal: high air pressure causes things to explode high up
					! No need to extend counterbalance upwards
				+ Rename "StaticPressureAdjustment" as "StaticPressureForceAdjustment"
			X Create new "Hot Air Balloon" ship
			+ Physics probe: internal pressure
				+ USCS: psi
			+ Find right setting value and range for InternalPressure tool
				+ Option 1: "Quantity" is really # of atmospheres
					+ If it's atmospheres, say "Atmospheres" in tooltip
			+ Ship definition: add optional value for default internal pressure
				+ When not specified, it's PressureAtZero (calc'd via Formulae)
				+ Move Offset out of metadata
			+ Optimizations:				
				+ EqualizeInternalPressure:
					+ Take perf now: 3.03% (default ship)
					+ See if can assign avg immediately: YES, verified
					+ Final perf: 1.43% (default ship)
		+ SHIFT for Electric Spark tool
			+ Add SHIFT: length multiplier
			+ Help
		+ Water Impact - when ship touches water for first time (*)
		+ Splash sounds at displacement:
			+ Piggyback on water displacement factors, after all magnitude of splash sound depends on kinetic energy, ~= displacement magnitude
				+ Try then to use displacement magnitude directly, after normalizing it wrt its own max
			+ Aggregate splash sound
			+ See why doesn't sound like different sounds
				x Try with minTimeDelta
					! It's because the different sounds can start even within minTimeDelta
			+ Idea: two types of sounds played together
				! Spec:
					- More wave-like: predominant at low displacement
						- Single sound
					- More splash-like: predominant at high displacement
						- The different sounds we have now, but different name: "displacementsplash"
				+ WaterDisplacementWave and WaterDisplacementSplash
				+ 1. Wave sound:
					+ Use current wave sounds
						+ Make sure name is proper generic "wave"
						+ Make sure has no min time
					+ See if can make sounds with shorter attack time
						+ If so: "WaterDisplacementWave"
					+ See if can reduce frequency of sounds firing
					+ Finalize code for displacement waves
					+ Try shorter sounds
				+ 2. Splash sound:
					+ Nuke old sounds, including types
					+ New "WaterDisplacementSplash" sounds, with splashy sounds, not much wave
					+ Algo
			+ Sound reorg:
				+ SoundFile::Load -> uq_ptr<SoundFile>, w/SoundFile::SoundBuffer not uq_ptr
			+ Optimize
			+ changelist
		+ Make sure we don't have custom probes; convert each needed to actual method
		+ Sky: satellites and shooting stars (*)
		+ See explosions issue with Marine Electric (now on Desktop)
			+ It's just too strong
		+ Fix issue with rotation: move first, and hit SHIFT during the move
		+ Fix texture changer for electrical panel
			+ MSW
			+ Test on Ubuntu
		+ bishobe644 in Credits
		+ Night vision (*)
		+ Help intro: add all new physics
		+ Silting:
			+ HandleCollisionsWithSeaFloor: position restore is scaled down when particle between 0 and SiltThickness below sea floor
				+ Scaling down is smaller (i.e. floor is harder) the closer to SiltThickness we get; linear might be jsut fine
				+ Then see what to do with velocity
				+ Work in progress:
					+ float const siltingCoeff = (depth < 40.f) ? 0.5f : 1.0f;
						+ 0.5 looks good - but limits bouncing, 0.75 does nothing
					! See if without silting things were less...brokey when hitting the ocean floor
					+ Use depth and absolute velocity
				+ Check what happens now with friction and elasticity
					+ Verify wheels still roll
				+ Test underneath world min Y in Debug
			+ Parameters and SettingsDialog @ OceanFloor
			+ Optimize
				+ Get perf before (without silting) 
					% default: 4.57%/4.85%
					% Ark splattered: 5.76%/6.30%
					Update ms Ark splattered: 10.2/10.3
				+ Export OceanFloor from parent world
					+ Substitute ocean floor methods with export
					X ...and see if below is still needed: check assembly
					+ Do same for ocean surface
						+ Moving three helpers to OceanSurface
				+ Try with approx_normalize
				+ Sample ocean floor only once
					+ 1: we first check if under floor, then take normal
						+ Assembly shows we're calculating index twice
						+ Make function to calc index & dx, and then query by index & dx:
							+ BUT: still have to check if below, so: GetOceanFloorHeightIfUnderneath(...) -> bool, register_int, float
								+ New GameType: register_int, defined based on FS_IS_REGISTER_WIDTH_32/64
									+ Replace "auto" at all uses
								+ Check assembly for tuple
							+ GetOceanFloorHeightAt(integral index, dx)
							+ GetOceanFloorNormalAt(integral index, dx)
					+ Nuke old code @ World.h, OceanSurface.h, OceanFloor.h
				+ Verify assembly
				+ Get perf after
					% default: 4.34%/4.39%
					% Ark splattered: 5.85%
					Update ms Ark splattered: 10.3/10.4
			+ changelist
		+ Send for testing:
			+ Win to testers
			+ Win to JohnSmith
			+ Ubuntu to guy
		+ Bump up version
		+ Test on Dell
			+ Test that these work: 
				+ Pressure crush
				+ ElectricSpark
			+ Perf:
				+ Before: FPS:30.2/30.6 UPD:18.9/19.6ms UPL:0.18ms RND:13.18ms
				+ After: FPS:30.65 UPD:19.5ms UPL:0.18ms RND:12.80ms
		+ Check Smith's feedback
			+ Explosions
			
		+ Localization:
			+ IT
				+ Help
				+ Check out changed SettingsDialog strings
			+ ES
				+ Help
				+ Check out changed SettingsDialog strings
			+ RU
				+ Help
				+ Check out changed SettingsDialog strings
		+ New ships
			+ Test BeamierBoomer
				+ Take: IJN_Mikasa.png, USS_C-13_Minneapolis.png
				+ Add to credits: BeamierBoomer
			+ PocketWatch
				+ Take: SS Avain Pocket 1852, SS King Christian, Andrea Doria
				+ Add to credits: Pocketwatch
			+ Replace egg carrier - tested and works good
			+ Test: den2006's front ships
				+ Take them all - he confirms they're all his
				+ Add to credits: Denis
			+ FERZCL's M.S. Costa Smeralda
				+ Take it, after he confirms texture credits
			+ At least 15 so far
		+ Release 1.16.5:
			+ Windows
				+ MSI variables
				+ Commit & push
				+ 64-bit MSI
					+ Cleanup Install
					+ Build Install
					+ Make MSI
					+ Rename MSI
					+ Test upgrade from previous version
				+ 32-bit MSI
					+ Cleanup Install
					+ Build Install
					+ Make MSI
					+ Rename MSI
					+ Test clean install
				+ Get both installers tested on dev server
			+ Ubuntu
				+ Pull 
				+ Build clean
				+ Make tar ("cd floating-sandbox && tar -cvf ../FloatingSandbox-1.16.5-x64.tar . && cd -")
				+ Smoke-test tar ("tar -xf FloatingSandbox-1.16.5-x64.tar")
				+ Zip tar
				+ Get tar tested on dev server
			+ Wait for test results
			+ Cut tag on github
			+ Upload packages to GameJolt
				+ Report file as safe (https://gamejolt.com/privacy)
				+ Post
				+ Edit description and add Ubuntu
			- www.floatingsandbox.com:
				X Upload changes.txt
				+ Update current version in FAQ
				+ Add Ubuntu to versions
		+ Fix derivative in ocean shader
		+ Release 1.16.6
			+ Windows
				+ MSI variable
				+ 64-bit MSI
					+ Cleanup Install
					+ Build Install
					+ Make MSI
					+ Rename MSI
					+ Test upgrade from previous version
				+ 32-bit MSI
					+ Cleanup Install
					+ Build Install
					+ Make MSI
					+ Rename MSI
					+ Test clean install
				+ Get both installers tested
			+ Ubuntu
				+ Pull 
				+ Build clean
				+ Make tar ("cd floating-sandbox && tar -cvf ../FloatingSandbox-1.16.5-x64.tar . && cd -")
				+ Smoke-test tar ("tar -xf FloatingSandbox-1.16.5-x64.tar")
				+ Zip tar
			+ Wait for test results
			+ Commit & push
			+ Cut tag on github
			+ Upload packages to GameJolt
			+ www.floatingsandbox.com:
				+ Update current version in FAQ
		+ Fix UpdateDialog re-entrant code
			+ Verify Ubuntu
		+ Update version to 1.16.7
		+ Release 1.16.7:
			+ Update changes.txt to 1.16.7
			+ Windows
				+ MSI variable
				+ Commit & push
				+ 64-bit MSI
					+ Cleanup Install
					+ Build Install
					+ Make MSI
					+ Rename MSI
					+ Test upgrade from previous version
				+ 32-bit MSI
					+ Cleanup Install
					+ Build Install
					+ Make MSI
					+ Rename MSI
					+ Test clean install
			+ Ubuntu
				+ Pull 
				+ Build clean
				+ Make tar ("cd floating-sandbox && tar -cvf ../FloatingSandbox-1.16.5-x64.tar . && cd -")
				+ Smoke-test tar ("rm -rf tmp && mkdir tmp && cd tmp && cp ../FloatingSandbox*.tar.gz . && tar -xf FloatingSandbox*.tar.gz")
				+ Zip tar
			+ Cut tag on github
			+ Upload packages to GameJolt
				+ Post
			+ www.floatingsandbox.com:
				+ Update current version in FAQ
			+ Announce on Discord server

	+ 1.17.0:
		+ Change version minor
		+ Nuke Ship Editor request for help from Readme
		+ FindSFML
			+ Windows
			+ Ubuntu

		+ Fix slice tool + SHIFT (no locking at all)		
		+ Lower heat radius in Ultra-Violent mode
		+ Preferences flag for starting full-screen
		+ See if can avoid "splash/flood" sound when just ropes are flooded
		+ https://www.reddit.com/r/FloatingSandbox/comments/riq290/found_an_interesting_bug/
			+ Can repro
			! It's due to multiple particles insisting on same depression
			+ OceanSurface::DisplaceAt: set to value that's larger (abs'ly) between current and new
				+ Test all callers of OceanSurface::DisplaceAt:
					+ Air bubbles
						+ Make more incisive
					+ Water displacement
						+ Make more incisive
						+ Compare with old
					+ Fishes up
					+ Fishes down
					+ Blast Tool
					+ Explosion blast
					+ Engine
						+ Try different depth curve
							+ Half-smoothstep
							X Try linear
				+ Cleanup OceanSurface.h::DisplaceAt()
					+ See assembly
		+ Wind tool
			+ Need non-zero wind receptivity for all materials
				+ Test first with hacking WindReceptivity in interaction
					+ Test 0.1
				+ Then, test normal wind with hacking WindReceptivity in materials, 0.1
					! Goal: use a single WindReceptivity for both normal Wind and for WindTool
					+ Test look'n'feel of various ships under wind, and then under storm
						+ Storm
						+ Fallback ship
						+ Blimps move a lot with default wind
					+ If can go ahead with this:
						+ Remove cheating at ShipInteractions
						+ Remove cheating at Material
						+ Update json
							+ Check cardboard and paper
						+ Mention in changes.txt
			+ Visual feedback (shader)
				+ Move radii calcn to GameController
				+ Invoke notification from GameController
				+ NotificationRenderContext
				+ Shader
					+ Finalize blending
			+ Sounds
				+ Make new "sudden wind gust" sounds
				+ Gust at left down, iff shift
				+ Gust at shift down, iff engaged
				+ Background wind
					+ New sound member of SoundController: WindMakerWindSound
					+ And stop at Deinitialize()
			+ World:
				+ Velocity used for radius should also depend on intensity
				+ Ocean surface
					+ Use pre-front, its radius and intensity
			+ Flames:
				+ Flame shader's FlameWindRotationAngle parameter must become vertex attribute
					= New step at Points::UpdateCombustionHighFrequency, populating new CombustionState member: rotation angle (or whatever it is we do now)
						+ Step 1: use global wind like now
							! But without smoothing wind speed
							+ Populate CombustionState
							+ Upload it from CombustionState to ShipRenderContext
								+ Remove old from ShipRenderContext
							+ Compare with previous
								+ See if need again smoothed wind speed: it does need it
								+ If so, see if can do it with convergence rate
						+ Step 2: global wind wrt flame vector
							+ Add temporary debug code to make flames at an auto-rotating angle
						+ Step 3: own velocity added to global wind
						+ Step 4: add interactive wind
							+ Wind interaction: store temporary wind @ Ship (WindField) (pre-front radius & main velocity, or TODO: both?)
								+ Reset it at end of Ship::Update
					+ Uploaded to ShipRenderContext when we upload flames at Points
					+ Taken by shader in VertexAttribute instead of uniform
				+ See if ShipRenderContext still needs wind afterwards
					+ Note: WorldRenderContext would still need it
			+ Tool:
				+ Tool should be reset at ship reset/load
					+ @ MainFrame::LoadShip(...)
				+ Problem with shift boost/main front intensity is not 1
				+ State machine:
					+ Remove zero front - after all intensity is going down anyway
				+ Lock position at TearDown
				+ Change cursor
					+ Molen
					+ Shift modifier
			+ Finalize:
				+ Check tool wind speed setting range in SettingsDialog
				+ Merge into master
				+ Changes.txt
		+ Fix OceanSurface/WaveMaker bug
			! It's due to interactive state machine populating DeltaBuffer, which then gets added to main buffer
			+ Fix
				+ Load only target-cur in delta (rather than target, like now)
			+ Test tsunami and rogue waves
			+ changes.txt
		+ Test Titanic sinking to floor and see what really happens
			+ 1: add count of spring breakages (temporarily) - as CustomProbe
				+ Test 1:
					- Concrete ball: 0 -> 435-442
					- R.M.S. Titanic: initial hole 45-50 -> 670 (split) -> 735 (sinking) -> 4373
					- R.M.S. Titanic: V-cut in half + hole 88 -> 3920
			+ 2: backup exe
			+ Test separately the impact of:
				+ Velocity change (w/no position): cb: 228, tit: 2750
					X BUT: fast things penetrate floor
				+ Position change (w/velocity zero'd): cb: 508, tit: 3760
			+ Test how it goes with doing (again) impact calc'n for each cycle: cb: 361, tit: 4100
			+ Test how it goes with no weakening: cb: 243, tit: 2830
			+ Test look'n'feel with previous version of FS - the one before static pressure but after hydrodynamics (i.e. after right speed)
			+ Fix StrengthRandomizer: instead of making weaker, make both weaker and stronger (i.e. center)
				+ Constraint to satisfy: total sum of point.Strength stays the same
				+ Calc number of particles first which will be weakened
				+ Result: cb: 235, tit: 3000-3300
				+ Lower weakening: 0.5
					+ Result: cb: 271, tit: 3000
				+ Lower weakening: 0.453
					+ Result: cb: 229, tit: 2700
				+ Test:
					+ Triton
					+ Sub
				+ Do not load from usersettings for lower versions
					+ Add version, default is previous one
				+ Finalize weakening setting
			+ Cleanup ProbePabel, leaving breakage count
			+ Send for opinion
			+ changes.txt
		+ Check WaterPump power adjust
		+ Lower volume of pump sound when many pumps are playing
			! We are lucky that we know # of pumps in advance; copy code from engines then
		+ Fix problem with strength randomization preferences screwing up game because they are persistent
			+ Move strength rnd settings to SettingsDialog
				+ Remove from preferences
				+ Fix Preferences dialog height: GamePanel
				+ Fix layout of SettingsDialog page
					+ Tighter H
			+ Test values
			+ changes.txt
		+ Make command-line arg for main exe
			+ MainFrame cctor takes opt<fs::path> for ship
		+ Re-make material templates
		+ Fix splash sound flanger
			! It's the WaterDisplacementWave sound, not the Splash sound
			+ Min delay for WaterDisplacementWave sound
		+ See rogue waves
		+ Do final ShipBuilder tasks (*<--)
		+ Train issue w/ocean floor
		+ Merge back into master
		+ Tests:
			+ New changes.txt found (aka old bug)
				+ Verify doesn't happen again
				+ Check how many older FS's exist, to see if can enable/upload changes.txt again
					+ Jan, Feb: 70% 1.16.7, 30% 1.16.4
		+ Localization
			+ IT
				+ Do first & second
				+ Update (probe panel)
				+ Test
					+ Including error ship
				+ Update po
			+ RU
				+ Take first
				+ Update & send second + initial tips
				+ Get back po file
				+ Get back initial tip line
				+ Update po
				+ Send final po
				+ Test
					+ Including error ship
			+ ES
				+ Take first
				+ Update & send second + initial tips
				+ Get back po file
				+ Get back initial tip line
				+ Update po
				+ Send final po
				+ Test
					+ Including error ship
		+ Test on NVidia
		+ Ships:
			+ Raynair updates
				+ A-320 update
				+ BAE					
				+ Skoda
					+ Tell him has holes - by design
			+ Pocketwatch ships
				+ SS Belgenland 1914
			+ Tank from AvSimplified
				+ Pick
				+ Asked for credits + AvSimplified
					+ CreditPanel
					+ Tank itself
			+ R.M.S. Atlantic's ships
				+ I'll take the S.Stephen
				+ Add to credits: "R.M.S. Atlantic"
			+ Finalize those in _TO_TAKE
				+ Make all .shp2
					+ Fixup names
				+ changes.txt
				+ Move to Ships/
				+ Verify fresh game can list them in LoadDialog
		+ MSI Installer:
			= Also install ShipBuilder.exe
				+ Test clean install
				+ Test upgrade
			+ Set shell handler for .shp2 files
				+ See https://stackoverflow.com/questions/138550/how-to-register-file-types-extensions-with-a-wix-installer
				+ Invoke main exe with command-line arg
				+ Also file icon
					+ See https://www.firegiant.com/wix/tutorial/getting-started/beyond-files/
				+ Test clean install
				+ Test upgrade

		+ Release
			+ Windows
				+ MSI variable
				+ Commit & push
				+ 64-bit MSI
					+ Cleanup Install
					+ Build Release Install
					+ Make MSI
					+ Rename MSI
					+ Test upgrade from previous version
				+ 32-bit MSI
					+ Cleanup Install
					+ Build Release Install
					+ Make MSI
					+ Rename MSI
					+ Test clean install
						+ Also do some random 32-bit testing
			+ Ubuntu
				+ rm -rf
				+ Pull 
				+ Make clean, make install
				+ Make tar ("cd floating-sandbox && tar -cvf ../Floating-Sandbox-1.17.0-x64.tar . && cd -")
				+ Zip tar
				+ Smoke-test tar ("rm -rf tmp && mkdir tmp && cd tmp && cp ../Floating-Sandbox*.tar.gz . && tar -xf Floating-Sandbox*.tar.gz")
			+ Get 3 installers tested on dev server
			+ Wait for test results
			+ Cut tag on github
			+ Upload packages to GameJolt
				X Report file as safe (https://gamejolt.com/privacy)
				+ Post
				+ Tear down GoogleDrive links
			+ www.floatingsandbox.com:
				+ Update current version in FAQ
				+ Upload changes2.txt
					+ Test w/old FS
					+ Test w/new FS
	+ 1.17.1:
		+ Update plan
		+ Commit & push
		+ Switch branch
		+ Rebase onto master
		+ Take Joadix's change
		+ Take DIOX's
		+ Update version
		+ Fix: CTRL^Z crashes ShipBuilder
		+ Sampler tool (*)
		+ Paco's water doors dance
			+ ElectricalElements: have state also for switches, and set a countdown (in sim time) before next transition
				+ Add state for them
		+ Fix: max wind with Ultra violence + shift key + toppling the crane + some how moving the thing that's attach to the crane up and down into the water = instate crash
			+ Repro? See video
			+ the fan at max speed + ultra violence mode + the shift
			+ Do fix
			+ changes.txt
		+ Test:
			+ Sampler tool
			+ SHIFT lock
		+ Add test target to UnitTests's CMakeLists.txt (for Ubuntu)
			+ Verify on Ubuntu
		+ Check discord
			+ See other crash with loading ship
		+ Release:
			+ Branch is merged into master (if applicable)
			+ Windows
				+ MSI variable
				+ Commit & push
				+ 64-bit MSI
					+ Cleanup Install
					+ Build Release Install
					+ Make MSI
					+ Rename MSI
					+ Test upgrade from previous version
					+ Send to testers
				+ 32-bit MSI
					+ Cleanup Install
					+ Build Release Install
					+ Make MSI
					+ Rename MSI
					+ Test clean install
			+ Ubuntu
				+ rm -rf floating-sandbox
				+ pull 
				+ rm -rf build; mkdir build
				+ cd build
				+ cmake -DCMAKE_BUILD_TYPE=Release -DFS_BUILD_BENCHMARKS=OFF -DFS_USE_STATIC_LIBS=ON -DwxWidgets_USE_DEBUG=OFF -DwxWidgets_USE_UNICODE=ON -DwxWidgets_USE_STATIC=ON -DFS_INSTALL_DIRECTORY=~/floating-sandbox ..
				+ make install
				+ Cleanup tar
				+ Make tar ("cd floating-sandbox && tar -cvf ../Floating-Sandbox-1.17.1-x64.tar . && cd -")
				+ Zip tar
				+ Smoke-test tar ("rm -rf tmp && mkdir tmp && cd tmp && cp ../Floating-Sandbox*.tar.gz . && tar -xf Floating-Sandbox*.tar.gz")
			+ Get 3 installers tested on dev server
			+ Wait for test results
			+ Cut tag on github
			+ Upload packages to GameJolt
				X Report file as safe (https://gamejolt.com/privacy)
				+ Post
			+ www.floatingsandbox.com:
				+ Update current version in FAQ
				+ Upload changes2.txt
					+ Test w/old FS
	+ 1.17.2:

		+ Update version, commit, & push
		+ Make branch
		+ Update Visual Studio

		+ -> ShipBuilder

		+ Material system improvements (*)

	+ 1.17.3:

		+ 1.17.2 release: wait a day or two, then upload changes2.txt
			+ Test w/old FS

		---------

		+ Commit and push

		+ Add ShipBuilder to github's ReadMe
			+ And to GameJolt's

		+ Fix WIX onto Visual Studio 2022
			! https://marketplace.visualstudio.com/items?itemName=WixToolset.WixToolsetVisualStudio2022Extension
			+ Test clean install, upgrade, and removal
				+ With new FS version

		+ Merge from master into 1.17.2.next
		+ Cleanup plan(s)

		+ Try bubbles with different buoyancy
			+ Use counter
			+ Try correlation with vortex

		X Test with SpringReductionFraction = 0.6 (@GameParameters)

		+ Better sparkles shader
			+ Make more transparent @ tail

		+ Fix strings @ WaterlineAnalysisDialog
			+ Trim "~0^A0" on old Dell
				+ Test on old Dell

		+ Fix: load 1.17.2 ship in 1.17.1: "non-standard materials/non-release version"
			+ Need to also include patch in check at ShipDefinitionFormatDeSerializer.cpp:1312
				+ Shouldn't we then include the entire version, given that we're at it?
			+ Tests:
				+ Load sodium with 1.17.1: verify gives wrong message
				+ Make ship as version "1.17.5" with missing material; load in this version and verify OK message
				+ Try to also load this new ship with 1.17.1, which won't recognize ShipAttributes

		+ Fix UpdateNotification while LoadShip is open

		+ See if can display error message when user starts FS on an unloadable ship

		+ Check if template png is ok
			+ Cardboard hull blue
			+ Add validation to script
			+ Redo template

		+ Option to disable lightning making damage - people want to sail in the storm
			+ Lightning Hit Probability
			+ SettingsDialog
			+ Test:
				+ Manual: 0, 1
				+ Storm: 0, 1
				+ Verify setting saved and reloadable
			+ changelist
			+ Custom setting: strong and logn storm, zero lightnings
				+ Test
				+ Make production

		+ Update water velocities with blast
			+ Adding velocities during blast

		+ Continuous Auto-focus (*)
			+ Send for testing, w/auto-focus being on by default
			+ Re-send for testing, again - !!! WITH AUTO-FOCUS ON
			+ Bump up build
			+ Decide whether auto-focus should be on by default: YES, ON BY DEFAULT
				+ Do
				+ Ctrl+HOME to toggle
					+ No more ESC
			+ Problem with ocean floor moving line by line
				+ Try first with alpha/anti-aliasing @ ocean floor
					+ This fixes only horizontal: float alpha = mix(0.0, 1.0, textureCoord.z / 0.2);
					+ This should be the winner; see if can do also for "vertical" edges
				X ViewManager:
					+ Figure out first if due to zoom or pan only
						+ Zoom does it (when no pan enabled)
						+ Pan does it (when no pan enabled)
					X World X/Y: no move if abs < 0.2
					X Zoom: no move if abs/current < 0.01
			X Ignore AABBs that are "too small"
				+ AABB::Add: Track largest area
				+ AABBSet: MakeUnion templated overload taking predicate - other calls this one
					+ Unit tests
				X Ignore AABBs with area smaller than a fraction of that
					+ Internal (inline) helper
					+ InternalFocusOnShip
					+ Update
			+ Ocean floor tool's SHIFT lock: stable w/camera moving
				+ Convert from screen to world in tool
			+ changelist
			+ Test land anti-aliasing on old Dell

		+ ShipBuilder lag with pencil tool px-1 moving across the screen
			+ See if texturization is done for right area
			+ See if OpenGL uploads are done for right area: NO
				+ Pre:
					+ ShipBuilder::MainFrame::OnWorkCanvasMouseMove: 63.31%
						...
						+ ShipBuilder::View::UploadGameVisualization: 55.67%
							+ GameOpenGL::UploadTexture: 55.61%
						+ ShipTexturizer::AutoTexturizeInto: 0.36%
						+ Controller::RefreshToolCoordinatesDisplay: 5.74%
				+ Do region like we used to do
				+ Post - also structural:
					+ ShipBuilder::MainFrame::OnWorkCanvasMouseMove: 23.47% - 23.29%
						+ ShipBuilder::View::UpdateGameVisualization: 3.16% - 5.22%
							+ GameOpenGL::UploadTextureRegion: 3.05%
						+ ShipBuilder::View::UploadStructuralLayerVisualization: 2.94% - 0.69%
							+ GameOpenGL::UploadTexture: 2.90%
						+ Controller::RefreshToolCoordinatesDisplay: 14.27% - 14.80%
			+ Test on old Dell:
				+ Save exe version without fix and use as benchmark
			+ Send to TimCan and WOLFF and other guy
			+ changelist
		+ Engines rearc (*)
		+ Jet engines @ Material system improvements (*)			
			+ Redo material template
			+ changelist (both rearc and jet engines)
			+ Air boat
			+ Promote rocket and air boat
			+ Merge into 1.17.2.next
		+ MainFrame's progress: make ShipBuilder take progress callback
			+ And move calls now done from MainFrame into that
		+ Spread out rotting:
			! Now: at step 20/49
			! Old: 
				static constexpr int UpdateSinkingPeriodStep = 6; -- Can stay as one step
				static constexpr int CombustionStateMachineSlowPeriodStep1 = 13;
				static constexpr int RotPointsPeriodStep = 20;
				static constexpr int CombustionStateMachineSlowPeriodStep2 = 27;
				static constexpr int SpringDecayAndTemperaturePeriodStep = 34; - Spread out spring coeffs' recalculations (*)
				static constexpr int CombustionStateMachineSlowPeriodStep3 = 41;
				static constexpr int CombustionStateMachineSlowPeriodStep4 = 48;
			! Steps: 13 steps, period=(39) // If not: 52
				UpdateSinking
				CombustionStateMachineSlow1
				CombustionStateMachineSlow2
				CombustionStateMachineSlow3
				CombustionStateMachineSlow4
				RotPoints1
				RotPoints2
				RotPoints3
				RotPoints4
				SpringDecayAndTemperature1
				SpringDecayAndTemperature2
				SpringDecayAndTemperature3
				SpringDecayAndTemperature4
			+ New: period=36
				+ 2: CombustionStateMachineSlow1
				+ 5: SpringDecayAndTemperature1
				+ 8: RotPoints1
				+ 11: CombustionStateMachineSlow2
				+ 14: SpringDecayAndTemperature2
				+ 17: RotPoints2
				+ 18: UpdateSinking
				+ 20: CombustionStateMachineSlow3
				+ 23: SpringDecayAndTemperature3
				+ 26: RotPoints3
				+ 29: CombustionStateMachineSlow4
				+ 32: SpringDecayAndTemperature4
				+ 35: RotPoints4
			+ Test:
				+ Verify spring melting does not show as localized
				+ Verify rotting does not show as localized
				+ 0..5 points/springs
				+ Old dell
			+ Cleanup logging
		+ Structural Tension View (*)
			+ changelist
		+ Send for testing
		+ See windows timer/50fps thing
			! http://mirrors.arcadecontrols.com/www.sysinternals.com/Information/HighResolutionTimers.html
			+ @ 50fps: Windows timer resolution (min/max/cur): 15.625 / 0.500 / 15.621 ms
				   Windows timer resolution (min/max/cur): 15.625 / 0.500 / 15.620 ms
				   Windows timer resolution (min/max/cur): 15.625 / 0.500 / 15.621 ms
			+ @ 64fps: Windows timer resolution (min/max/cur): 15.625 / 0.500 / 0.997 ms
				   Windows timer resolution (min/max/cur): 15.625 / 0.500 / 0.997 ms
		+ Affinitize threads:
			+ At MainApp and at first line of each TaskLoop: CoreLib/SystemThreadManager.GetInstance()::InitializeThisThread()
				+ Also SystemThreadManager::GetNumberOfProcessors()
				+ Change into "InitializeThread"
					+ Also doing floating point checks
				+ Thread affinitization with set
			+ Also do SetProcessPriority
			+ Main thread (@GameController)
			+ Rendering thread (@TaskThread)
			+ Task threads (@ThreadPool)
			+ Tests:
				+ SetProcessPriority
				+ Floating point settings

		+ ShipBuilder things
		+ Send localization files
		+ See core dump
			+ Fix telegraph control
			+ See if it's also in other controls
		+ See horizontal oscillations, e.g. with SS_Kbenhavn
		+ Tensile display: try with green at 0, blue at tensile, red at compressive
			+ Add new value to enum
				= SettingsDialog
			+ ShipRenderContext: react to changes in StressRenderMode and set array param accordingly
			+ Shader: 12 brackets, new formula
			+ Springs::UpdateForStrain: figure out how to replace max thing	
			+ Test on old Dell
		+ Check all those new ships
			+ S.S. Arctic
				+ "Menta1ity"
				+ Add him to credits
			+ Estonia
				+ "braun"
				+ Add him to credits
			+ Great_Grandeur_1956
				+ Pocketwatch
			+ S.S._Hoogbeke
				+ Pocketwatch
			+ SS_Kbenhavn_1923
				+ Pocketwatch
			+ U.S.S. Rhode Island
				+ Pocketwatch
			+ M.S_Bjeli_Orao_2: 
				+ BeamierBoomer
			+ changelist

		+ Release:
			+ Localization:
				+ IT
				+ ES
				+ RU
			+ Windows
				+ MSI variable
				+ Commit & push
				+ 64-bit MSI
					+ Cleanup Install
					+ Build Release Install (after clean)
					+ Make MSI
					+ Rename MSI
					+ Test upgrade from previous version
				+ 32-bit MSI
					+ Cleanup Install
					+ Build Release Install (after clean)
					+ Make MSI
					+ Rename MSI
					+ Test clean install
			+ Ubuntu
				+ rm -rf floating-sandbox
				+ pull 
				+ rm -rf build; mkdir build; cd build
				+ cmake -DCMAKE_BUILD_TYPE=Release -DFS_BUILD_BENCHMARKS=OFF -DFS_USE_STATIC_LIBS=ON -DwxWidgets_USE_DEBUG=OFF -DwxWidgets_USE_UNICODE=ON -DwxWidgets_USE_STATIC=ON -DFS_INSTALL_DIRECTORY=~/floating-sandbox ..
				+ make install
				+ Make tar ("cd floating-sandbox && tar -cvf ../Floating-Sandbox-1.17.3-x64.tar . && cd -")
				+ Zip tar
				+ Smoke-test tar ("rm -rf tmp && mkdir tmp && cd tmp && cp ../Floating-Sandbox*.tar.gz . && tar -xf Floating-Sandbox*.tar.gz")
			+ Get 3 installers tested on dev server
			+ Wait for test results
			+ Cut tag on github
			+ Upload packages to GameJolt
				+ Post video
				+ Post
			+ www.floatingsandbox.com:
				+ Update current version in FAQ
				+ Upload changes2.txt
					+ Test w/old FS

	+ 1.17.4:

		+ Bumpup version

		+ ShipLoadDialog Toolbar (*)
		+ Fix ship exploding at max strength
		+ Update checker: more indentations
		+ Remove Floeddy's ships
			+ Also from credits
			+ M.S. Breadmaster (Without Interior)
			+ M.S. Breadmaster
			+ M.S. Fluffic
			+ S.S Library
			+ S.S. Research
		+ Upgrade 
			+ GoogleTest
			+ Google Benchmark

		+ Try sparkles becoming narrower with time
			+ Do
			+ Also rewrite them with "right" quad and simple shader
				+ Do quad
				+ Finish shader: https://www.shadertoy.com/view/7l3yzr
					+ Do early bailout 4 transparency
			+ Think of "tail problem" (sparkle appearing far from cut because of tail being transparent)
				~ Try: alpha = smoothstep(0.0, 1.0, alpha);
				~ Try: yp * 0.9
				+ Try square
			+ Shorter sparkles (less velocity @ generation)
				+ But then wider dependency of width w/velocity

		+ Fix: allow users to adjust zoom speed
			+ Smoother
			+ Preferences UI
			+ Commit
			+ Slow convergence problem

		+ ShipBuilder rope crash (*)
			+ Changelist

		+ BitmapRadioButton: & BitmapToggleButton make it more highlighted when "checked"
			+ Do
			+ Chase all other UI buttons to ensure they're all ok as well
				+ BitmapToggleButton: handler takes bool
				+ Nuke all usages of:
					+ wxBitmapToggleButton
						+ SettingsDialog: UltraViolentMode
				+ Test:
					+ ShipPropertiesEditDialog::PopulateAutoTexturizationPanel
			+ Test also on:
				+ Win 7
				+ Win 10
			+ changelist ("Windows 11 ready")

		+ Win 11 issue
			X NOT DUE TO THIS - ALSO HAPPENS WITH MULTI-THREADING DISABLED: wxGLCanvas::SwapBuffer() invoked from other thread; impl:
				- ::SwapBuffers(m_hDC) 
					- According to https://community.khronos.org/t/swapbuffers-in-another-thread/70349:
						- DeviceContexts are actually thread-affine, and GDI functions should only be called on them in the threads that created them
			+ Next to test: reduce OpenGL calls to minimum
				+ Happens with neither RenderUpload nor RenderDraw, but SwapBuffers
				+ Does not happen when SwapBuffers is NOT called, even with the *WHOLE* OpenGL upload+draw
			+ Next: retry minimal repro w/OpenGL canvas and invoking SwapBuffers in timer callback
			+ Try wxWidgets upgrade to 3.2.0 (https://www.wikiwand.com/en/WxWidgets) on repro
				+ Build SDK
				+ Try repro with it
			+ Report to MS

		+ Kukan's track
			+ Add to changelist
			+ Make it first

		+ Add new testers to Credits:
			+ minch
			+ Rpr5704
			+ Pocketwatch

		+ Localization:
			+ IT
			+ RU
			+ ES

		+ Sparkle length, again (TimCan)

		+ Release
			+ Windows
				+ MSI variable
				+ Commit & push
				+ 64-bit MSI
					+ Cleanup Install
					+ Build Release Install (after clean)
					+ Make MSI
					+ Rename MSI
					+ Test upgrade from previous version
				+ 32-bit MSI
					+ Re-generate from CMake
					+ Cleanup Install
					+ Build Release Install (after clean)
					+ Make MSI
					+ Rename MSI
					+ Test clean install
			+ Ubuntu
				+ rm -rf ~/floating-sandbox
				+ pull 
				+ rm -rf build; mkdir build; cd build
				+ cmake -DCMAKE_BUILD_TYPE=Release -DFS_BUILD_BENCHMARKS=OFF -DFS_USE_STATIC_LIBS=ON -DwxWidgets_USE_DEBUG=OFF -DwxWidgets_USE_UNICODE=ON -DwxWidgets_USE_STATIC=ON -DFS_INSTALL_DIRECTORY=~/floating-sandbox ..
				+ make install
				+ Make tar ("cd ~/floating-sandbox && tar -cvf ../Floating-Sandbox-1.17.4-x64.tar . && cd -")
				+ Zip tar
				+ Smoke-test tar ("rm -rf tmp && mkdir tmp && cd tmp && cp ../Floating-Sandbox*.tar.gz . && tar -xf Floating-Sandbox*.tar.gz")
			+ Get 3 installers tested on dev server
			+ Wait for test results
			+ Cut tag on github
			+ Upload packages to GameJolt
				+ Report file as safe (https://gamejolt.com/privacy)
				+ Post
			+ www.floatingsandbox.com:
				+ Update current version in FAQ
				+ Wait a day or two, to exclude disastrous bugs
				+ Upload changes2.txt
					+ Test w/old FS

		+ Cleanup plan, commit & push

	+ 1.17.5:

		+ Laser Cannon tool (*)

		+ Fix: GameController ends up being deleted by SwitchboardPanel - might be the cause of the "blocking" issue on GTK
			! It happens because mElectricalPanel (SwitchboardPanel uq_ptr) is added to MainFrame, hence it's deleted by it *AND* by later uq_ptr
			+ Major issue: everything that's added to sizers, etc. should NOT be a uq_ptr
				+ EventTicker
				+ ProbePanel
				+ MainGLCanvas
			X See if GTK issue is gone

		+ At lights going off because of flooding of power, before flickering: flash w/spread and luminiscence		
			+ "lights severed" flag becomes opt<enum> ("for water", "for severed")
				+ Set as "For water" when power source is cutoff because of water
					! Note: current causes for "severed":
						- Destroyed elements
						- OnElectricSpark
						- UpdateSourcesAndPropagation: Power generator transitioning into NotProducingCurrent
					! Note: "severed" is consumed at lamp state machine transitioning from LightOn (for any cause), to decide whether
					  to turn off immediately or through flicker
					+ Make sure only set at PowerSource being down and at destroyed elements (not at lamp being down)
				+ Severed is cleaned up at end of UpdateSinks
					+ So clean here whole opt<enum>
			+ At lamp state machine: use a single opt<PowerFailureNextState> storing first decision on whether or not to do it
			+ Lamp::State contains TransientApertureMultiplier, and that's the one messed with by state
				+ And of course it's used when uploading to lights buffer, multiplied with actual aperture
				+ Reset at Restore()
				+ Better profile
					+ See 1:53 at https://www.youtube.com/watch?v=yg9rkceLOzA:  ...t.TTT..
			+ Put back randomness when choosing overcharge
		
		+ Lower volume of wind sound

		+ Electric Sparkle tool: sparkles can cause lights to explode (*)
		+ Lamps breaking under pressure (*)
			+ changelist for both

		+ Laser cannon
			+ Cut with prob inverse to mass
				+ Remove laser_ray_cut_receptivity
			+ Shader: more smeared on the outside
			+ More prob when SHIFT is down
			+ Sound for cut

		+ Ukrainian (uk)
			+ 2 .mo files
			+ 2 HTML files
			+ changelist

		+ Merge into master

		+ Send for testing
			+ Ask specifically to check lamps in sinking ships
			+ Ask to check Ukrainian

		+ Bump up version

		+ ShipBuilder things (*)
		
		+ Check ship move beyond world borders
			+ in Debug mode
		+ Add Ukrainian to credits

		+ Max sim quality: 5.0

		+ Send for testing & localization

		+ Localization:
			+ IT
			+ ES
			+ RU
			+ UK

		+ Test flames with heightened luminosity
			+ Test perf of flames on Dell

		+ Ships:
			+ Take S.S. Avila 2 (Matthew Anderson) (ToTake folder)
			+ Take B-17 Flying Fortress (DKUZ) (ToTake folder)
				+ Credits
				+ Asked for texture credits
			+ Take A_single_Blue_Angel (Kazindel) (ToTake folder)
				+ Wrong credits - shipbucket? (ASKED)
					+ TaskForce51 http://shipbucket.com/forums/viewtopic.php?t=10424&start=180 That is (And I am 100% sure) not where I got it from but it was so far the only mention of it
				+ "Kazindel" in Credits
			+ Take Normandie
				+ Find author - "P1X"
					+ Author in properties
					+ Credits: "P1X"
			+ Take R.M.S. Oceanic
				+ Ask Golden
					+ Author in properties
					+ Credits
			+ Take Antonia Graza - left server
				+ Find author
					+ Author in properties
					+ Credits: "MTF"

		+ Investigate crash upon exit on Dell
			+ Also test on ubuntu
			+ Wait for testers

		+ Bump up version
		
		+ Release:
			+ Branch is merged into master (if applicable)
			+ Windows
				+ MSI variable
				+ Commit & push
				+ 64-bit MSI
					+ Cleanup Install
					+ Build Release Install (after clean)
					+ AV executable
					+ Make MSI
					+ Rename MSI
					+ AV installer
					+ Test upgrade from previous version
						+ Verify bitness & version
				+ 32-bit MSI
					+ Cleanup Install
					+ Build Release Install (after clean)
					+ Make MSI
					+ Rename MSI
					+ Test clean install
						+ Verify bitness & version
			+ Ubuntu
				+ rm -rf ~/floating-sandbox
				+ pull 
				+ rm -rf build; mkdir build; cd build
				+ cmake -DCMAKE_BUILD_TYPE=Release -DFS_BUILD_BENCHMARKS=OFF -DFS_USE_STATIC_LIBS=ON -DwxWidgets_USE_DEBUG=OFF -DwxWidgets_USE_UNICODE=ON -DwxWidgets_USE_STATIC=ON -DFS_INSTALL_DIRECTORY=~/floating-sandbox ..
				+ make install
				+ Make tar ("cd floating-sandbox && tar -cvf ../Floating-Sandbox-1.17.5-x64.tar . && cd -")
				+ Zip tar
				+ Smoke-test tar ("rm -rf tmp && mkdir tmp && cd tmp && cp ../Floating-Sandbox*.tar.gz . && tar -xf Floating-Sandbox*.tar.gz")
			+ Cut tag on github
			+ Upload packages to GameJolt
				+ Upload
				+ Wait for a few downloads
				+ Post
			+ www.floatingsandbox.com:
				+ Update current version in FAQ
				+ Wait a day or two, to exclude disastrous bugs
				+ Upload changes2.txt
					+ Test w/old FS

		-----------------
